---
title: "Figure1_proof_of_concept"
author: "Brendan F. Miller"
date: "3/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# MERFISH mPOA

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mpoa_merfish_clean.RData")
# has `annot.table`, `counts`, and `features` objects

# annot.table: table of the individual cells and data like coordinates, cell types, bregma, animal
# features: has cells and additional features. Also dataset they belong to
# counts: gene counts of cell in annot.table for 130 merfish genes profiled

# unique(features$dataset_name)
#  [1] "170908_FN3_2_M22_M26"    "170917_MN1_1pp_M22_M26" 
#  [3] "170919_FN4_1_M22_M26"    "170921_FN4_2_M22_M26"   
#  [5] "170923_FN4_1pp_M22_M26"  "170925_MN2_1p_M22_M26"  
#  [7] "171021_FN7_2_M22_M26"    "171023_FN7_1_M22_M26"   
#  [9] "171024_MN5_2p_M22_M26"   "171027_MN5_1p_M22_M26"  
# [11] "171104_MN6_2_M22_M26"    "171112_MN8_2pppp"       
# [13] "171114_MN8_M22_M26_2pp"  "171208_MN9_2ppp_M22_M26"
# [15] "171118_BD3_1pp"          "171119_BD5_1pp"         
# [17] "171121_BD5_1"            "171123_BD5_2p"          
# [19] "171124_BD6_2ppp"         "171126_BD6_1pppp"       
# [21] "171128_BD7_1ppp"         "171129_BD7_1ppp_actual" 
# [23] "171201_BD_2ppp"          "171203_BD8_1pp"         
# [25] "171210_BD9_1pp"          "171211_BD9_2ppp_M22_M26"
# [27] "171214_BD10_2_M22_M26"   "171216_BD11_1_M22_M26"  
# [29] "171217_BD11_2_M22_M26"   "171219_BD12_1p_M22_M26" 
# [31] "171221_BD12_2p_M22_M26"  "171223_BD13_2p_M22_M26" 

```

Simulate ST spots for each bregma slice for a given MERFISH experiment data set

171021_FN7_2_M22_M26

```{r}

# select cells that are part of given data set:
selected_cells <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26')]

spatial_position_and_class <- annot.table[selected_cells,
                                          c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]

# remove rows with NA
spatial_position_and_class <- na.omit(spatial_position_and_class) 

```

```{r}

# reduce set of major cell class labels. Convert OD types to "OD" and
# "Endothelial types to "Endothelial"
spatial_position_and_class[grep(pattern = "OD",
                                x = spatial_position_and_class$Cell_class),]$Cell_class <- "OD"

spatial_position_and_class[grep(pattern = "Endothelial",
                                x = spatial_position_and_class$Cell_class),]$Cell_class <- "Endothelial"

# number of cells in the experiment across bregmas
dim(spatial_position_and_class)
# [1] 36329     5

# gene counts for individual cells
bregmaCellsGexp <- counts[rownames(spatial_position_and_class),]

# remove "Blanks" from data
bregmaCellsGexp <- bregmaCellsGexp[,!grepl("Blank", colnames(bregmaCellsGexp))]

```

```{r}

# to expand to neuronal subtypes, make a secondary vector of "Cell_class" where
# "Excitatory and "Inhibitory" are replaces with the respective "Neuron_cluster_ID"

Cell_class_major <- spatial_position_and_class$Cell_class

Cell_class_with_neuronal <- unlist(lapply(rownames(spatial_position_and_class), function(cell){
  class <- spatial_position_and_class[cell,]$Cell_class
  neuron <- spatial_position_and_class[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

length(Cell_class_with_neuronal)

```

The `buildBregmaCorpus` output contains a "gtCtGenes" ground truth cell type - gene expression matrix, but this is built by combining cells of the same Cell_class in the given bregma (and therefore may also be missing reference for cell types not present).

Let's also make a reference using all the cells across the bregmas.

```{r}

cellTypes <- spatial_position_and_class$Cell_class
cells <- rownames(spatial_position_and_class)

mat <- bregmaCellsGexp[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtGenes <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtGenes <- gtCtGenes[,!grepl("Blank", colnames(gtCtGenes))]
gtCtGenes <- gtCtGenes/rowSums(gtCtGenes)

dim(gtCtGenes)

```

```{r}

# simulate spots for each bregma and contain in a hash table
FN7_2_M22_M26 <- simulateBregmaSpots(spatial_position_and_class,
                                          counts = bregmaCellsGexp,
                                          patch_size = 100)

# now simulate but use all the neural types as well
spatial_position_and_class$Cell_class <- Cell_class_with_neuronal
FN7_2_M22_M26_neuro <- simulateBregmaSpots(spatial_position_and_class,
                                          counts = bregmaCellsGexp,
                                          patch_size = 100)

```

Let's also make a reference for all of the cell types including the neuronal ones

```{r}

cellTypes <- spatial_position_and_class$Cell_class
cells <- rownames(spatial_position_and_class)

mat <- bregmaCellsGexp[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtNeuronalGenes <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtNeuronalGenes <- gtCtNeuronalGenes[,!grepl("Blank", colnames(gtCtNeuronalGenes))]
gtCtNeuronalGenes <- gtCtNeuronalGenes/rowSums(gtCtNeuronalGenes)

dim(gtCtNeuronalGenes)

```

Construct corpuses using the simulations with the 9 major cell classes, or expanded to all of the neuronal subtypes

```{r}

simBregmas <- lapply(keys(FN7_2_M22_M26), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_2_M22_M26, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmas) <- keys(FN7_2_M22_M26)

simBregmas_neuro <- lapply(keys(FN7_2_M22_M26_neuro), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_2_M22_M26_neuro, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmas_neuro) <- keys(FN7_2_M22_M26_neuro)

```

Recall that the `$gtSpotTopics` are of primary interest to compare the fitted models to for each bregma. The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches.


When comparing to reference-dependent methods, could use a single scRNAseq reference made from all of the individual cells in `bregmaCellsGexp`. Or for each bregma, can make a reference based on the individual cells that were present in the spots. So that the models are restricted to the identical data that the LDA is presented,

```{r}

# "scRNAseq" reference using all the cells:
bregmaFullSeur <- CreateSeuratObject(counts = t(bregmaCellsGexp), project = "bregmaFull scRNAseq Ref")

# add cell class labels to the meta.data for assigning clusters later
bregmaFullSeur[["Major_class"]] <- Cell_class_major
bregmaFullSeur[["All_classes"]] <- Cell_class_with_neuronal

```

```{r}

# if using a "scRNAseq" reference for a given bregma in order to restrict to the same data as LDA:

# vectors of the class labels for the cells in the bregma patches:
breg_Cell_class_major <- simBregmas$`-0.04`$annotDf$Cell_class
breg_Cell_class_with_neuronal <- unlist(lapply(rownames(simBregmas$`-0.04`$annotDf), function(cell){
  class <- simBregmas$`-0.04`$annotDf[cell,]$Cell_class
  neuron <- simBregmas$`-0.04`$annotDf[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

# cells in the bregma patches:
breg04_patch_cells <- rownames(simBregmas$`-0.04`$annotDf)

# the gene counts for the bregma patch cells
breg04_scRNAseq <- FN7_2_M22_M26[["-0.04"]]$cellGexp[breg04_patch_cells,]

# "scRNAseq" reference using all the cells:
bregma04Seur <- CreateSeuratObject(counts = t(breg04_scRNAseq), project = "bregma scRNAseq Ref")

# add cell class labels to the meta.data for assigning clusters later
bregma04Seur[["Major_class"]] <- breg_Cell_class_major
bregma04Seur[["All_classes"]] <- breg_Cell_class_with_neuronal

```

# MOB

Using the mOB from MERIGNUE and the 12 Stahl et al mOB replicates (13 total data sets), find a common set of genes to use in the corpus for each replicate so that they can be compared equally

```{r}

data(mOB) # from `MERIGNUE`
cd <- mOB$counts # 15928 genes   262 spots

```

```{r}

# list of either the mob data sets or paths to the data for inputs into `preprocess`

mob_paths <- list()
mob_paths[[1]] <- t(cd) # preprocess input needs to be spot x genes

# paths to Stahl data:
p <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/"
stahlMobDatPaths <- list.files(path = p, pattern = "*MOB_count_matrix-1.tsv", full.names = FALSE)
# add to the list
i <- 1
while(i < length(stahlMobDatPaths) + 1){
  mob_paths[[i+1]] <- paste0(p, stahlMobDatPaths[i])
  i <- i + 1
}

```

```{r}

mobRepGenes <- lapply(mob_paths, function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = FALSE,
                   selected.genes = NA,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 100,
                   min.lib.size = 100,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.25, # increase due to filtering by intersection of reps
                   gam.k = 5)
  colnames(dat$corpus)
})

commonMobGenes <- Reduce(intersect, mobRepGenes)
length(commonMobGenes)

```

Now construct corpuses for each mob dataset using the common set of mob genes

```{r}

# first do the Stahl data because can get positional information from the spot IDs
mobCorpus <- lapply(mob_paths[2:13], function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = TRUE,
                   selected.genes = commonMobGenes,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 100,
                   min.lib.size = 100,
                   ODgenes = FALSE,
                   od.genes.alpha = 0.05, # ODgenes ignored; so is this
                   gam.k = 5) # ODgenes ignored; so is this
  dat
})

names(mobCorpus) <- unlist(strsplit(stahlMobDatPaths, "_MOB_count_matrix-1.tsv"))

```

```{r}

# now do the MERINGUE mob. Positions added in separately
mobCorpus[["mob"]] <- preprocess(mob_paths[[1]],
                                 alignFile = NA,
                                 extractPos = FALSE,
                                 selected.genes = commonMobGenes,
                                 nTopGenes = NA,
                                 genes.to.remove = NA,
                                 perc.spots = NA,
                                 min.reads = 100,
                                 min.lib.size = 100,
                                 ODgenes = FALSE,
                                 od.genes.alpha = 0.05, # ODgenes ignored; so is this
                                 gam.k = 5) # ODgenes ignored; so is this

# positions already included in `mOB$pos` but make sure only use the filtered positions in the corpus
mobCorpus[["mob"]]$pos <- mOB$pos[rownames(mobCorpus[["mob"]]$corpus), ]

```

## MOB scRNAseq ref

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

mob_se_wt <- mob_se[,wt_cells]

meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

```

Construct proxy "beta" by combining gene expression of cells of same cell types

```{r}

mobWtCellClusters <- meta.data.wt$ClusterName
names(mobWtCellClusters) <- meta.data.wt$X

mobWtCellProxyBeta <- model.matrix(~ 0 + as.factor(mobWtCellClusters))

rownames(mobWtCellProxyBeta) <- names(mobWtCellClusters)

# fix names
colnames(mobWtCellProxyBeta) <- unlist(lapply(colnames(mobWtCellProxyBeta), function(x) {
  unlist(strsplit(x, ")"))[2]
}))

mobWtCellProxyBeta <- t(as.matrix(mob_se_wt) %*% mobWtCellProxyBeta)

mobWtCellProxyBeta <- mobWtCellProxyBeta/rowSums(mobWtCellProxyBeta)

dim(mobWtCellProxyBeta)

```

# =========================

# Figure 1

```{r}

fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/figures/"

```


# A - Merfish mPOA (-0.04)

Show the individual cells in the bregma colored by the major cell class and overlay the simulated spot boundaries

```{r}

breg <- simBregmas$`-0.04`

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank())
ggsave(filename = filename = "Fig1_A-1_breg04_mjrcts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "black") +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank())
ggsave(filename = "Fig1_A-2_breg04_mjrcts_patches.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

# for all neuronal cell types 
# 72 types now so legend and assigned colors gets messy
breg <- simBregmas_neuro$`-0.04`

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        legend.position = "none")
ggsave(filename = "Fig1_A-3_breg04_neurocts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "black") +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        legend.position = "none")
ggsave(filename = "Fig1_A-4_breg04_neurocts_patches.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

# B - LDA results

Fit LDA models

```{r}

# fit models to a range of K's that include 9 (for 9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

Recall that `simBregmas$`-0.04`$sim` and `simBregmas_neuro$`-0.04`$sim` have the same corpus, but the assigned ground truths constructed in "buildBregmaCorpus" differ because one used the 9 major cts and the other used major plus extended neuros.

So can use either "simBregmas" or "simBregmas_neuro" input corpuses to fit.

# -0.04

```{r}

start_time <- Sys.time()

pdf(file = paste0(fig_path, "Fig1_B-1_breg04_mjrcts_lda_fit.pdf"))
bregma04_LDAs <- fitLDA(counts = simBregmas$`-0.04`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

Get beta, theta matrices and clusters of topics for model assessment and visualization

## k = 9 major cts

```{r}

bregma04_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(9)

```

```{r}

m <- bregma04_k9$theta # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.5,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_B-2_breg04_k9_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


set.seed(1)

m <- simBregmas$`-0.04`$gtSpotTopics # The ground truth proportions for 9 major cts
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=randomcoloR::distinctColorPalette(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.5,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_B-3_breg04_gt_mjrcts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Individual topics visualized separately

```{r}

m <- bregma04_k9$theta # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

cc <- as.factor(colspace)
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## theta correlation

bregma -0.04 fitted with k=9 vs gt 9 major cts

```{r}

thetaCor_breg04_k9_vs_gt <- getCorrMtx(m1 = bregma04_k9$theta,
                                       m2 = as.matrix(simBregmas$`-0.04`$gtSpotTopics),
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_B-4_breg04_k9_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCor_breg04_k9_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-4_breg04_k9_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_breg04_k9_vs_gt)
gplots::heatmap.2(x = thetaCor_breg04_k9_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## beta correlation

bregma -0.04 fitted with k=9 vs gt 9 major cts

```{r}

betaCor_breg04_k9_vs_gt <- getCorrMtx(m1 = bregma04_k9$beta,
                                       m2 = as.matrix(simBregmas$`-0.04`$gtCtGenes), # gt made from cells in bregma
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_breg04_k9_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_breg04_k9_vs_gt)
gplots::heatmap.2(x = betaCor_breg04_k9_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

Compare with global gt for all of the cells

```{r}

betaCor_breg04_k9_vs_globalgt <- getCorrMtx(m1 = bregma04_k9$beta,
                                       m2 = as.matrix(gtCtGenes), # the global beta from all bregma cells in `bregmaCellsGexp` (36329)
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_globalGt_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_breg04_k9_vs_globalgt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_globalGt_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_breg04_k9_vs_globalgt)
gplots::heatmap.2(x = betaCor_breg04_k9_vs_globalgt[pairs$rowix, pairs$colsix],
                  Rowv = NA,
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## k = 75 all neuronal cts

```{r}

bregma04_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = "min"),
                      deepSplit = 2, # collapsed more to reduce number of clusters to 17
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(75)

```

### individual topics

```{r}

m <- bregma04_k75$theta # theta for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

# Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
# in every spot. It might be worth removing topics from specific spots if they are below a certain proportion

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01, # many more topics so make lines very thin
             showLegend = FALSE,
             plotTitle = "bregma -0.04 k=75 topics")
ggsave(filename = "Fig1_B-2_breg04_k75_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


set.seed(1)

m <- simBregmas_neuro$`-0.04`$gtSpotTopics # The ground truth proportions for the actual 72 of 75 present cts in bregma
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=randomcoloR::distinctColorPalette(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01,
             showLegend = FALSE,
             plotTitle = "Ground truth proportions 75 cts")
ggsave(filename = "Fig1_B-3_breg04_gt_75neurocts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Because so many topics, collapse the individual topics into topic clusters to better visualize and assess

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(ncol(bregma04_k75$thetaCombn))

```

### topic clusters

```{r}

m <- bregma04_k75$thetaCombn # theta of the combined topic clusters for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

# Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
# in every spot. It might be worth removing topics from specific spots if they are below a certain proportion

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01, # many more topics so make lines very thin
             showLegend = FALSE,
             plotTitle = "bregma -0.04 k=75 topic-clusters")
ggsave(filename = "Fig1_B-2_breg04_k75_clusters_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Lets visualize each topic cluster separately but also observe the proportions of the individual topics that make up each cluster. For example, a topic cluster clearly captures the ependymal cells, but there is no single individual topic that captures this. Instead, the LDA appears to capture additional transcriptionally distinct subtypes of the ependymal cells.

```{r}

m <- bregma04_k75$theta # theta for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = bregma04_k75$cols, # factor for the 75 topics where the levels are the color of assigned cluster
                 sharedCol = FALSE, # so that each topic in a cluster is colored as a shade of the cluster color
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

Break down even more but just looking at specific individual clusters

```{r}

m <- bregma04_k75$theta[,c(22,23,32,41,46,60)] # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# C - Example ependymal

# bregma -0.04 k=9 mjr cts

```{r}

# Topic 7 highly correlated with ependymal cells
topic7ependymalTopGenes <- head(bregma04_k9$beta[7,order(bregma04_k9$beta[7,], decreasing = TRUE)], n=10)
topic7ependymalTopGenes

```

Visualize genes:

```{r}

# input df for `vizGeneCounts`
df <- bregmaCellsGexp[,labels(topic7ependymalTopGenes)]
df <- merge(as.data.frame(spatial_position_and_class[,c("Centroid_X", "Centroid_Y")]), as.data.frame(df), by=0)
colnames(df)[which(names(df) == "Centroid_X")] <- "x"
colnames(df)[which(names(df) == "Centroid_Y")] <- "y"
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Mlc1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Mlc1",
              showLegend = TRUE)
ggsave(filename = "Fig1_C-1_breg04_k9_ependy_gexp_Mlc1.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Cd24a",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cd24a",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Aqp4",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Aqp4",
              showLegend = TRUE)

```

# bregma -0.04 k=75 neuro cts

Above, it was observed that the ependymal cells are captured by the topic cluster of the following topics:
F0FF00 : 22 23 32 41 46 60

When the topics are visualized separately, the individual topics appear to capture additional transcriptionally distinct subpopulations of the ependymal cells.

Let's visualize the top genes for the cluster in general, and also for the individual topics

```{r}

bregma04_k75$clusters

```

Note that topics "22 23 32 41 46 60" are part of cluster `4`

```{r}

breg04_k75_ependymalTopGenes_tclust <- head(bregma04_k75$betaCombn[4,order(bregma04_k75$betaCombn[4,], decreasing = TRUE)], n=10)
breg04_k75_ependymalTopGenes_tclust

```

The genes for the overall cluster are very similar ro what was found with k=9. So representative of ependymal cells overall.

But what about the individual topics in the cluster?

```{r}

print("Topic 22")
head(bregma04_k75$beta[22,order(bregma04_k75$beta[22,], decreasing = TRUE)], n=10)

print("Topic 23")
head(bregma04_k75$beta[23,order(bregma04_k75$beta[23,], decreasing = TRUE)], n=10)

print("Topic 32")
head(bregma04_k75$beta[32,order(bregma04_k75$beta[32,], decreasing = TRUE)], n=10)

print("Topic 41")
head(bregma04_k75$beta[41,order(bregma04_k75$beta[41,], decreasing = TRUE)], n=10)

print("Topic 46")
head(bregma04_k75$beta[46,order(bregma04_k75$beta[46,], decreasing = TRUE)], n=10)

print("Topic 60")
head(bregma04_k75$beta[60,order(bregma04_k75$beta[60,], decreasing = TRUE)], n=10)


```

Again, Mlc1 is a top gene for all of them. Cd24a also top marker.  

```{r}

genes <- c("Mlc1", "Cd24a", "Aqp4", "Cd24a", "Cxcl14", "Sema4d", "Ndrg1")

# input df for `vizGeneCounts`
df <- bregmaCellsGexp[,genes]
df <- merge(as.data.frame(spatial_position_and_class[,c("Centroid_X", "Centroid_Y")]), as.data.frame(df), by=0)
colnames(df)[which(names(df) == "Centroid_X")] <- "x"
colnames(df)[which(names(df) == "Centroid_Y")] <- "y"
rownames(df) <- df$Row.names

```

Topic 32 appears to be very specific at the bottom of the ependymal layer. It is the strongest expression wrt Mlc1 compared to the other topics and also has "Cd24a", "Sema4d" and "Ndrg1"

It's possible that this topic is picking up more of an "artifact" for bregma -0.04 specifically as Mcl1 is particularly high in this region compared to other bregma slices. However, the possibility remains that this is a distinct subpopulation for this particular slice in space.

```{r}

vizGeneCounts(df = df,
              gene = "Mlc1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Mlc1",
              showLegend = TRUE)
# ggsave(filename = "Fig1_C-2_breg04_k75_ependy_gexp_Slco1a4.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

vizGeneCounts(df = df,
              gene = "Cd24a",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cd24a",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Sema4d",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Sema4d",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Ndrg1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Ndrg1",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Cxcl14",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cxcl14",
              showLegend = TRUE)

```

# D - MOB 

Original Txn clusters

```{r, mob-qc, fig.width=8, fig.height=3}

# Remove poor datasets and genes
mob_counts <- MERINGUE::cleanCounts(counts = mOB$counts, # from mOB data set
                      min.reads = 100, 
                      min.lib.size = 100, 
                      plot=TRUE,
                      verbose=TRUE)
mob_pos <- mOB$pos[colnames(mob_counts),]

# CPM normalize
mob_cpm <- MERINGUE::normalizeCounts(counts = mob_counts, 
                       log=FALSE,
                       verbose=TRUE)

```

```{r}

# Dimensionality reduction by PCA on log10 CPM expression values
pcs.info <- prcomp(t(log10(as.matrix(mob_cpm)+1)), center=TRUE)
nPcs <- 5
pcs <- pcs.info$x[,1:nPcs]

# 2D embedding by tSNE
emb <- Rtsne::Rtsne(pcs,
             is_distance=FALSE,
             perplexity=30,
             num_threads=1,
             verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)

# Graph-based cluster detection
k <- 30
com <- getClusters(pcs, k, weight=TRUE)

# Manually annotate identified clusters with cell-types
mob_annot <- as.character(com); names(mob_annot) <- names(com)
mob_annot[com==4] <- '1: Granule Cell Layer'
mob_annot[com==1] <- '2: Mitral Cell Layer'
mob_annot[com==3] <- '3: Outer Plexiform Layer'
mob_annot[com==2] <- '4: Glomerular Layer'
mob_annot[com==5] <- '5: Olfactory Nerve Layer'
mob_annot <- as.factor(mob_annot)

# Plot
par(mfrow=c(2,2), mar=rep(1,4))
plotEmbedding(emb, groups=mob_annot, 
              show.legend=TRUE, xlab=NA, ylab=NA,
              verbose=FALSE)
plotEmbedding(mob_pos, groups=mob_annot, 
              cex=1, xlab=NA, ylab=NA,
              verbose=FALSE)

```

# E - LDA results

Fit LDA models

```{r}

# fit models to a range of K's that include 5 (5 original txn clusters) and
# 37 and 38 (for the cts in the scRNAseq refs; 38 originally but SL doesn't find and Meis2 so dropped)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, 37, 38, seq(from = 15, to = 75, by = 10))

```

Recall that `simBregmas$`-0.04`$sim` and `simBregmas_neuro$`-0.04`$sim` have the same corpus, but the assigned ground truths constructed in "buildBregmaCorpus" differ because one used the 9 major cts and the other used major plus extended neuros.

So can use either "simBregmas" or "simBregmas_neuro" input corpuses to fit.

# mob (meringue data)

```{r}

pdf(file = paste0(fig_path, "Fig1_D-1_mob_lda_fit.pdf"))
mob_LDAs <- fitLDA(counts = mobCorpus$mob$slm,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

## k = 15 kOpt2 kneed

```{r}

mob_k15 <- buildLDAobject(LDAmodel = optimalModel(mob_LDAs, opt = "kneed"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(15)

```

```{r}

m <- mob_k15$theta # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

### topic clusters

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(6)

```

```{r}

m <- mob_k15$thetaCombn # theta for 6 topic clusters of the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_E-2_mob_k15_clusters_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- mob_k15$theta
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

```{r}

m <- mob_k15$thetaCombn
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k15$clustCols,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

Check out the individual topics that make up each cluster

```{r}

m <- mob_k15$theta
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k15$cols,
                 sharedCol = FALSE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## theta correlation

See which topics correlate with the 5 cell layer annotations based on txn clustering

```{r}

# proxy theta for the txn clusters
mobProxyTheta <- model.matrix(~ 0 + mob_annot)
rownames(mobProxyTheta) <- names(mob_annot)

# fix names
colnames(mobProxyTheta) <- unlist(lapply(colnames(mobProxyTheta), function(x) {
  unlist(strsplit(x, ": "))[2]
}))

mobProxyTheta <- as.data.frame.matrix(mobProxyTheta)

```

```{r}

thetaCor_mob_k15_vs_gt <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k15$theta,
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCor_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_mob_k15_vs_gt)
gplots::heatmap.2(x = thetaCor_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
dev.off()

```

Topic cluster theta correlations

```{r}

thetaCor_combined_mob_k15_vs_gt <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k15$thetaCombn,
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor.pdf"))
gplots::heatmap.2(x = thetaCor_combined_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_combined_mob_k15_vs_gt)
gplots::heatmap.2(x = thetaCor_combined_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
dev.off()

```

## beta correlation

Correlate to a mob scRNAseq reference to see if certain topics also correlate with known cell types.

```{r}

betaCor_mob_k15_vs_gt <- getCorrMtx(m1 = mob_k15$beta,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_mob_k15_vs_gt)
gplots::heatmap.2(x = betaCor_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

```

```{r}

betaCor_mob_k15_combined_vs_gt <- getCorrMtx(m1 = mob_k15$betaCombn,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined.pdf"))
gplots::heatmap.2(x = betaCor_mob_k15_combined_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_mob_k15_combined_vs_gt)
gplots::heatmap.2(x = betaCor_mob_k15_combined_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

```

# -------

# explore beta vs gene counts

Hows does the beta and the actual cell type txn profiles (gene counts) correspond? They are different, especially when looking at spotlight W and the Seurat ref. Agreement, but correlation is about 0.68 across the paired topics in W (the gene weights or probabilities) and the averaged expression of genes for the scRNAseq mob clusters. See `merged_workflow.Rmd` "scRNAseq cluster gexp".

Ex: If 2 cell types express gene A at 10 and 20, is the beta probability going to be 2x higher for gene A in second cell type? Does the relationship between beta and gene counts relate in terms of z-scores? Or logFC, or just the rank of the gene wrt the cell types (higher expressed genes have higher beta? Maybe not this because I would think that if the counts were 1000 and 2000 (higher overall compared to other genes, but the relative distance (2X more expression) the same, then maybe the association with the corresponding topic would have the same beta (2x higher in second cell type, but same beta as the gene that is onlt 10 and 20?). Unclear)

## mob_k15$beta vs mobWtCellProxyBeta

```{r}

m1 <- mob_k15$beta
m2 <- as.matrix(mobWtCellProxyBeta)

betaCor <- getCorrMtx(m1 = m1,
                      m2 = m2, # gt proxy beta
                      type = "b")


keep_genes <- intersect(colnames(m1), colnames(m2))

m1_filt <- m1[,keep_genes]
m2_filt <- m2[,keep_genes]

pairs <- lsatPairs(betaCor)
gplots::heatmap.2(x = betaCor[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Predicted topics",
                  # ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))

diag_cors <- diag(betaCor[pairs$rowix, pairs$colsix])

hist(diag_cors, breaks = 10)
mean(diag_cors)
sd(diag_cors)

```

```{r}

# Mes1 and topic 4 correlate strongly (0.827). What about the genes?
plot(m2_filt["Mes1",], m1_filt[4,])

# N4 and topic 3 correlate weakly (0.37). What about the genes?
plot(m2_filt["N4",], m1_filt[3,])

# OEC5 and topic 14 in correlate moderately (0.65). What about the genes?
plot(m2_filt["OEC5",], m1_filt[14,])

```

The genes that are chosen to be highly associated with the topic in the beta are not necessarily the ones that are expressed the highest in the cell type. Instead, maybe they are actually reflective of the deferentially expressed genes?

In cases where the beta correlates strongly, it is due to the expression of a few genes that are highly expressed. These also appear to be significantly differentially expressed in the ct (see below) but not always the case. For instance, N4 has a lot of sig dif genes, but a weaker correlation. Maybe too many specific genes for the LDA to chose as a defining marker to weight heavily? Some cts with no specific sig dif genes still correlate well. Again, this may point to the fact that the LDA is looking primarily for, and weighting on, genes that are more unique to a certain ct and not necessarily whether they are differentially expressed or not. 

However, consider that the LDA topics were derived from a completely different data set than what the scRNAseq was derived from.

So should really try this using the "W" matrix from spotlight which is trained using a reference scRNAseq data set. Then see how these two correspond.

```{r}

difExpAll <- MERINGUE::getDifferentialGenes(cd = mob_se_wt, cols = mobWtCellClusters)

# also try with just the genes in the LDA corpus
# this actually ends up being very similar in terms of the p.adj, Z, M, fe values
# assigned even with a limited set of genes to begin with. Just stick to all genes above
difExp_limitedGenes <- MERINGUE::getDifferentialGenes(cd = mob_se_wt[keep_genes,], cols = mobWtCellClusters)

```

```{r}

difExpAll_sig <- lapply(difExpAll, function(x) {
  x <- x[x$p.adj < 0.05,]
  x <- na.omit(x)
  x <- x[x$highest,]
  rownames(x)
})

difExp_limitedGenes_sig <- lapply(difExp_limitedGenes, function(x) {
  x <- x[x$p.adj < 0.05,]
  x <- na.omit(x)
  x <- x[x$highest,]
  rownames(x)
})

```

```{r}

# difExpAll$Mes1[names(m2_filt["Mes1",]),]$fe

# Mes1 and topic 4 correlate strongly (0.827). What about the genes?
plot(difExpAll$Mes1[names(m2_filt["Mes1",]),]$Z, m1_filt[4,])

# N4 and topic 3 correlate weakly (0.37). What about the genes?
plot(difExpAll$N4[names(m2_filt["N4",]),]$Z, m1_filt[3,])

# OEC5 and topic 14 in correlate moderately (0.65). What about the genes?
plot(difExpAll$OEC5[names(m2_filt["OEC5",]),]$Z, m1_filt[14,])

```

In cases where the beta correlates well with the ct expression, there are a few top genes that are highly expressed in the cell type that the beta picks up on. But the weights are not direct correspondences with the gene expressions.

Then looked at the total number of unique sig dif "marker" genes for a cell type but that doesn't seem to affect correlation. The idea being that gene expression profiles the beta correlates strongest with could be due to the LDA picking up on significantly differentially expressed genes in the ct and weighting the beta based on this differential expression. But doesn't seem to be the case wrt number of marker genes.

```{r}

# colnames(betaCor[pairs$rowix, pairs$colsix])

numSigGenes <- unlist(lapply(colnames(betaCor[pairs$rowix, pairs$colsix]), function(ct){
  length(difExpAll_sig[[ct]])
}))

plot(numSigGenes, diag(betaCor[pairs$rowix, pairs$colsix]))

```

## *** SL W mob vs scRNAseq ref

Make a proxy beta using the 38 cell type clusters of the mob scRNAseq reference

```{r}

mob_cell_type_clusters <- as.factor(mob_se_wt@meta.data$ClusterName)
names(mob_cell_type_clusters) <- rownames(mob_se_wt@meta.data)

mm <- model.matrix(~ 0 + mob_cell_type_clusters)
colnames(mm) <- levels(mob_cell_type_clusters)
scRNAseq_mob_cluster_gexp <- t(as.matrix(mob_se_wt@assays$RNA@counts) %*% mm)
scRNAseq_mob_cluster_gexp <- scRNAseq_mob_cluster_gexp/rowSums(scRNAseq_mob_cluster_gexp)
dim(scRNAseq_mob_cluster_gexp)
scRNAseq_mob_cluster_gexp[1:10,1:10]

```

Compare to Spotlight trained NMF, with a fitted W matrix (the "beta" topic-gene probability matrix)

This one was fit using `mob_counts`, so the seurat cluster genes were additionally removed if they were not kept in the `mob_counts` spatial data set.

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_ls.RData")
# nmf_mod_mob_wt_countsClean_ls

W_countsClean <- nmf_mod_mob_wt_countsClean_ls[[1]]@fit@W

keep_genes <- colnames(scRNAseq_mob_cluster_gexp)[colnames(scRNAseq_mob_cluster_gexp) %in% rownames(W_countsClean)]
length(keep_genes)

```

```{r}

# for comparison, use the intersection of genes that are present in the W matrix and the scRNAseq proxy beta

keep_genes <- colnames(scRNAseq_mob_cluster_gexp)[colnames(scRNAseq_mob_cluster_gexp) %in% rownames(W_countsClean)]
length(keep_genes)

```

correlate each, then plot gene expression vs betas for a variety of different topics/cell types

# -------


# F - cell layer example

Can start to annotate topics based on where they are spatially and how they correlate with known cell types. Viz marker genes and also orthogonal validation with ISH data.

Topic 4 beta had one of the highest gene expression correlations with the mobProxyBeta from the scRNAseq data set and correlated with the "Mes1" cluster. Topic 4 also was predicted to be correlated at least moderately with the Glomerular layer

```{r}

sortedGenes <- order(mob_k15$beta[4,], decreasing = TRUE)
mob_k15$beta[4,sortedGenes][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,labels(mob_k15$beta[4,sortedGenes][1:10])]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Ptgds",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Ptgds",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Ptgds.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Apod",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Apod",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Apod.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Fabp7",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Fabp7",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Fabp7.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Igf2",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Igf2",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Dcn",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Dcn",
              showLegend = TRUE)

```

Next, consider the Granule cell layer (central txn cell layer). Topic clusters 1 and 6 actually seem to cover this area. And within these, additional individual topics.

```{r}

m <- mob_k15$thetaCombn # theta for 6 topic clusters of the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = as.character(mobProxyTheta$`Granule Cell Layer`),
             group_cols = c("0" = "white", "1" = "black"),
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.8,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_F-2_mob_k15_clusters_granule.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

The topic clusters can be broken down into individual topics 3, 5 (cluster 6) and 9, 10, 12 (cluster 1) are present 

```{r}

print("topic cluster 6")
mob_k15$betaCombn[6,order(mob_k15$betaCombn[6,], decreasing = TRUE)][1:10]

print("topic cluster 1")
mob_k15$betaCombn[1,order(mob_k15$betaCombn[1,], decreasing = TRUE)][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,c("Tubb2b", "Atp1b1")]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Tubb2b",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Tubb2b",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_clust6_granule_Tubb2b.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Atp1b1",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Atp1b1",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_clust1_granule_Atp1b1.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Top gene of each topic seems to capture even more "layers" of the granule cell layer

Even within topic cluster 6, the individual topics break down even more:

```{r}

print("topic cluster 6, topic 3")
mob_k15$beta[3,order(mob_k15$beta[3,], decreasing = TRUE)][1:10]

print("topic cluster 6, topic 5")
mob_k15$beta[5,order(mob_k15$beta[5,], decreasing = TRUE)][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,c("Nrgn", "Penk", "Nrep", "Tubb2b")]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Nrgn",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Nrgn",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic3_granule_Nrgn.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Penk",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Penk",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic3_granule_Penk.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Nrep",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Nrep",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic5_granule_Nrep.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Tubb2b",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Tubb2b",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic5_granule_Tubb2b.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Nrep and Tubb2b particularly correspond to that very central region.

Any cell types that may be expressing these genes?

# =========================

# Figure 2

lda k equal to other methods

merfish assess all cell types - which cell types do methods struggle most with? rare ones?

have merfish "scRNAseq" ref that you can use to assess what happens when a ct is removed for SL and RCTD

consider mob scRNAseq ref as gt and compute correlation. best matched and do RMSE?


beta probabilty versus actual gene counts...scatter plot of predicted beta vs actual cell type gene counts

there is that Interactive correlation heatmap might be useful here.

For example, the W vs the scRNAseq gene exp correlation. I did this at some point. Revisit the correlations by seeing the individual genes. Does transforming gene counts make them correlate better with beta/W?


# RMSE with MERFISH

# build seurat reference

Both Spotlight (SL) and RCTD require a Seurat object of gene counts for individual cells and meta data assigning these cells to clusters.

Combine cells from all of the bregmas to use as the reference. Have one reference with the 9 major cell classes and a second one that expands the cell types to the 75 types that include the neuronal types.

```{r}

# have already built this above. In the meta.data there is a column for major cell classes and another for all 75

bregmaFullSeur

```

# SL 9 Major Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFullSeur) <- bregmaFullSeur@meta.data$Major_class

levels(bregmaFullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFullSeur_markers9cts <- Seurat::FindAllMarkers(object = bregmaFullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Finally, lets train the model 

Note here that the training only keeps genes that are also in the spatial data that will be deconvolved. So it is important that the ST data used here will be what is deconvolved later. Otherwise during one of the NNMF steps during deconvolution, the *entire environment will actually crash!* Unless if one carefully filters for shared genes beforehand if a different ST object is used with the same trained SL model. Otherwise retrain for each new ST dataset to deconvolve.

However, here, at least for the MERFISH data, the same 125 genes are used for all simulated ST datasets so this should not be an issue. (For mOB ST sets, this will be)

```{r}

set.seed(888)

SL_bregmaFull9cts_04fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.04`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

really fast...makes me think that the number of genes is the real determinant of time and not really number of cells. Esp since it downsamples cells anyways.

Repeat for all the bregmas:

```{r}

set.seed(888)

SL_bregmaFull9cts_09fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.09`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_14fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.14`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_19fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.19`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_24fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.24`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_29fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.29`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

## Collect RMSE


# SL 75 Neuronal Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFullSeur) <- bregmaFullSeur@meta.data$All_classes

levels(bregmaFullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFullSeur_markers75neuocts <- Seurat::FindAllMarkers(object = bregmaFullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Some types do not have assigned marker genes. I wonder how this will affect the subsequent model training

Now fit:

```{r}

set.seed(888)

SL_bregmaFull75neurocts_04fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas_neuro$`-0.04`$sim)), # actually same sim as "simBregmas". Just that the gt refs differ
  clust_vr = "All_classes", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers75neuocts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

The number of clusters or cells types also makes a major contribution to time.
Same genes (125) but 75 cts instead of 9 and significantly slower...

Now fit the remaining

So, because all corpuses have the same genes, I should be able to use the same fitted model to deconvolve all of them. If there were different genes then there is a risk that the W and ST data set may not match wrt genes and the nnls step would crash.

To this point, looking at the W and H matrices of the NMF object for the `SL_bregmaFull9cts_` objects, they are the same for each instance of training SPOTlight.

Training is by far the slowest part. So to speed things up, wrote a wrapper function that performs the subsequent steps in SPOTlight after training the NMF model (and in turn, also extracts additional potentially useful information)

```{r}

SL_bregmaFull75neurocts_09fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.09`$sim)))

SL_bregmaFull75neurocts_14fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.14`$sim)))

SL_bregmaFull75neurocts_19fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.19`$sim)))

SL_bregmaFull75neurocts_24fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.24`$sim)))

SL_bregmaFull75neurocts_29fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.29`$sim)))

```

## Collect RMSE


# RCTD 9 Major Cts Train

The input reference and data to be deconvolved need to be placed into directories, labeled a special way, and have specific columns in the files. 

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_ref/"

ref <- bregmaFullSeur

meta_ref <- ref@meta.data[,c("Major_class", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
d <- simBregmas$`-0.04`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma09/"
d <- simBregmas$`-0.09`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma14/"
d <- simBregmas$`-0.14`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma19/"
d <- simBregmas$`-0.19`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma24/"
d <- simBregmas$`-0.24`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma29/"
d <- simBregmas$`-0.29`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

```

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_ref/"
bregmaFull_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

bregma -0.04

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
bregma04_RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_bregma04 <- RCTD::create.RCTD(bregma04_RCTDspatial,
                        bregmaFull_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_bregma04_fit <- RCTD::run.RCTD(RCTD_bregma04, doublet_mode = TRUE)

RCTD_bregma04_results <- RCTD_bregma04_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_bregma04_results_norm <-  sweep(RCTD_bregma04_results$weights, 1, rowSums(RCTD_bregma04_results$weights), '/')

```

Do the rest of the bregmas

```{r}

set.seed(888)

rctd_ref <- bregmaFull_RCTD_ref
bregmas <- c("bregma09", "bregma14", "bregma19", "bregma24", "bregma29")
p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/"

rctd_thetas <- lapply(bregmas, function(breg){
  datadir <- paste0(p, breg, "/")
  
  spatial <- RCTD::read.SpatialRNA(datadir)
  rctd <- RCTD::create.RCTD(spatial,
                        rctd_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)
  
  rctd_fit <- RCTD::run.RCTD(rctd, doublet_mode = TRUE)
  
  results <- rctd_fit@results
  # normalize the cell type proportions to sum to 1.
  norm <-  sweep(results$weights, 1, rowSums(results$weights), '/')
  norm
})
names(rctd_thetas) <- bregmas

```

## Collect RMSE

# RCTD 75 Neuronal Cts Train

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_75cts_ref/"

ref <- bregmaFullSeur

meta_ref <- ref@meta.data[,c("All_classes", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$All_classes),
                         Name = unique(ref@meta.data$All_classes)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

Same as what was used for RCTD 9 Cts

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_75cts_ref/"
bregmaFull_75cts_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

bregma -0.04

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
bregma04_RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_bregma04_75ct <- RCTD::create.RCTD(bregma04_RCTDspatial,
                        bregmaFull_75cts_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_bregma04_75ct_fit <- RCTD::run.RCTD(RCTD_bregma04_75ct, doublet_mode = TRUE)

RCTD_bregma04_75ct_results <- RCTD_bregma04_75ct_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_bregma04_75ct_results_norm <-  sweep(RCTD_bregma04_75ct_results$weights, 1, rowSums(RCTD_bregma04_75ct_results$weights), '/')

```

although 75 cts in ref, only 72 reported here. Maybe 3 cell types not detected at all and dropped

Do the rest of the bregmas

```{r}

set.seed(888)

rctd_ref <- bregmaFull_75cts_RCTD_ref
bregmas <- c("bregma09", "bregma14", "bregma19", "bregma24", "bregma29")
p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/"

rctd_thetas_75cts <- lapply(bregmas, function(breg){
  datadir <- paste0(p, breg, "/")
  
  spatial <- RCTD::read.SpatialRNA(datadir)
  rctd <- RCTD::create.RCTD(spatial,
                        rctd_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)
  
  rctd_fit <- RCTD::run.RCTD(rctd, doublet_mode = TRUE)
  
  results <- rctd_fit@results
  # normalize the cell type proportions to sum to 1.
  norm <-  sweep(results$weights, 1, rowSums(results$weights), '/')
  norm
})
names(rctd_thetas_75cts) <- bregmas

```

## Collect RMSE

# LDA train additional Bregmas

```{r}

# fit models to a range of K's that include 9 (for 9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

```{r}

pdf(file = paste0(fig_path, "Fig1_B-1_breg09_mjrcts_lda_fit.pdf"))
bregma09_LDAs <- fitLDA(counts = simBregmas$`-0.09`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg14_mjrcts_lda_fit.pdf"))
bregma14_LDAs <- fitLDA(counts = simBregmas$`-0.14`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg19_mjrcts_lda_fit.pdf"))
bregma19_LDAs <- fitLDA(counts = simBregmas$`-0.19`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg24_mjrcts_lda_fit.pdf"))
bregma24_LDAs <- fitLDA(counts = simBregmas$`-0.24`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg29_mjrcts_lda_fit.pdf"))
bregma29_LDAs <- fitLDA(counts = simBregmas$`-0.29`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

## Collect RMSE

Use either K=9 or K=75 trained models to be comparable with SL and RCTD

# ---------

# A - RMSE compare

Each spot, all bregmas, 9 cts

Each spot, all bregmas, 75 cts

Then above but each bregma separately?

Instead, can I compute RMSE for deconvolving each cell type instead of all cell types across the spots. Identify which cell types are easy and which are hard for the models to predict

# B - Correlations between GT

Each method wrt 9 major cts across all spots, do for each bregma separately

Boxplot of correlations
Also show heatmaps of best matched

# C - Remove CT from MERFISH

Recompute the RMSE and correlations

# -----
# D - MOB 

Correlations between predicted cell types for each method (LDA vs SL vs RCTD)

Cell types which SL and RCTD correlate poorly on?

# E - Remove OECs

# F - MOB Cortex

Compare to the mob scRNAseq reference to be considered as ground truth

So for SL or RCTD, compare the cortex predictions to the mob scRNAseq predictions (wrt beta and theta)

Also correlate the two scRNAseq refs to see which cell types relate the most transcriptionally

# =========================

# Figure 3

# Breast ST




