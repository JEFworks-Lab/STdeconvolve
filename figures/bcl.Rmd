---
title: "Untitled"
author: "Brendan F. Miller"
date: "3/25/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# BCL layers 1-4

# Intersect 152 OD genes

```{r}

# save(bcl_countsClean,
#       bcl_CPM, # 12821 filteres genes and 1029 spots after cleaning and CPM normalized
#       bclCorpus, # corpus of the 152 genes and 1029 spots (2 dropped)
#       bcl_k12, # LDA trained on OD gene intersection (152 genes between layers 1-4 with alpha = 0.2)
#      file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/bcl_fitted_models.RData")

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/bcl_fitted_models.RData")

```

```{r}

fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/figures/"
draft_fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/draft_figures/"

```

```{r}

data(BCL)
# 4 layers, 1031 total spots.

bcl_pos <- BCL$pos[,1:2]
bcl_slice <- BCL$pos[,3]
names(bcl_slice) <- rownames(bcl_pos)
length(bcl_slice)

# filter spots in bcl_slice based on those kept in the corpus
bcl_slice_filt <- bcl_slice[names(bcl_slice) %in% rownames(bclCorpus$pos)]
length(bcl_slice_filt)

bclCorpus$slice <- bcl_slice_filt

# clean
# bcl_countsClean <- MERINGUE::cleanCounts(counts = BCL$counts, # genes x spots mtx
#                                         min.reads = 10,
#                                         min.lib.size = 10,
#                                         verbose=TRUE)
# 
# bcl_CPM <- MERINGUE::normalizeCounts(counts = bcl_countsClean,
#                                           verbose=TRUE, log=FALSE)

```

The shared OD genes across the 4 layers:

```{r}

# list of either the mob data sets or paths to the data for inputs into `preprocess`

bcl_paths <- list()
bcl_paths[[1]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 1])]))
bcl_paths[[2]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 2])]))
bcl_paths[[3]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 3])]))
bcl_paths[[4]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 4])]))

```

```{r}

# collect OD genes for each slice
bcl_ODgenes <- lapply(bcl_paths, function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = FALSE,
                   selected.genes = NA,
                   nTopGenes = NA, # top expressed genes to remove
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 10,
                   min.lib.size = 10,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.2, # more flexible because taking shared ODs will reduce drastically
                   gam.k = 5,
                   nTopOD = NA) # option to keep just the top n OD genes
  colnames(dat$corpus)
})

# get intersection of the OD genes
sharedBCLGenes <- Reduce(intersect, bcl_ODgenes)
length(sharedBCLGenes)

```

## Txn clustering

In the original paper, 3 clusters ID:
- ductal carcinoma in situ
- invasive ductal carcinoma
- non-malignant

```{r}

set.seed(888)

# use the CPM adjusted counts

pcs.info <- prcomp(t(log10(as.matrix(bcl_CPM[sharedBCLGenes,rownames(bclCorpus$pos)])+1)), center=TRUE)
plot(pcs.info$sdev[1:30])
nPcs <- 5
pcs <- pcs.info$x[,1:nPcs]
# 2D embedding by tSNE
emb <- Rtsne::Rtsne(pcs,
                    is_distance=FALSE,
                    perplexity=30,
                    num_threads=1,
                    verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)
# Graph-based cluster detection
k <- 350
bcl_com <- MERINGUE::getClusters(pcs, k, method=igraph::cluster_louvain)


pdf(file = paste0(draft_fig_path, "Fig_3_txn-clustering-shared-ODs.pdf"),   # The directory you want to save the file in
  width = 6, # The width of the plot in inches
  height = 5) # The height of the plot in inches
par(mfrow=c(2,2), mar=rep(1,4))
# top row
# left: all slice spots tSNE embedding and labeled by cluster assignment
MUDAN::plotEmbedding(emb, groups=bcl_com,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: all slice spots tSNE embedding and labeled by tissuse slice assignment
MUDAN::plotEmbedding(emb, groups=bclCorpus$slice,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)
# bottom row
# left: spots labeld by cluster assignment and overlayed on each slice.
# Same clusters seem to be at similar spot locations on slices. Nice to see
MUDAN::plotEmbedding(bclCorpus$pos, groups=bcl_com,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: spots colored by slice and slices overlayed
MUDAN::plotEmbedding(bclCorpus$pos, groups=bclCorpus$slice,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)
dev.off()

# capture the txn cluster assignment of the spots
bclCorpus$txn <- bcl_com

```

# Union of OD genes

152 genes useful but maybe capture more variation if keep OD genes regardless of the slice (take union)

```{r}

# lets also make sure we are using genes that are present across all slices
# because the final corpus will be all the spots across all the slices
# and each one will also need to contain the genes in the union
all_genes <- lapply(bcl_paths, function(p){
  print(dim(p))
  genes <- colnames(p)
  print(length(genes))
  genes
})
all_genes <- Reduce(intersect, all_genes)
length(all_genes)

```
seems like each slice has the same genes anyways

```{r}

# find shared set of OD genes across sections to try and identify common transcriptional patterns

bcl_ODgenes <- lapply(bcl_paths, function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = FALSE,
                   selected.genes = all_genes, # use the set of shared genes across all slices
                   nTopGenes = 5,
                   genes.to.remove = NA,
                   perc.spots = 0.95,
                   min.reads = 10,
                   min.lib.size = 10,
                   min.detected = 1,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.05, # use a smaller alpha to use the union of the top OD genes in each section
                   gam.k = 5,
                   nTopOD = 100) # it turns out the final list is too large for the topic modeling. So select just the top OD genes in each slice
  colnames(dat$corpus)
})

# because very few genes are OD across all sections, instead take the union and consider genes
# that are OD in any slice
unionBCLGenes <- Reduce(union, bcl_ODgenes)
length(unionBCLGenes)

```

Build the corpus with the union set of OD genes. Here its 372. 

```{r}

bclCorpusUnion <- preprocess(t(as.matrix(BCL$counts)),
                       alignFile = NA,
                       extractPos = FALSE,
                       selected.genes = unionBCLGenes,
                       nTopGenes = NA,
                       genes.to.remove = NA,
                       perc.spots = NA,
                       min.reads = 0, 
                       min.lib.size = 0, # because using specific set of genes, remove spots with 0 counts but keep others
                       ODgenes = FALSE,
                       od.genes.alpha = 0.05, # ODgenes ignored; so is this
                       gam.k = 5) # ODgenes ignored; so is this

# positions already included in `mOB$pos` but make sure only use the filtered positions in the corpus
bclCorpusUnion$pos <- bcl_pos[rownames(bclCorpusUnion$corpus), ]

# add in slice info for the spots that were kept after filtering with the new gene set.
# With the new genes, some different spots may not have any gene counts and will be empty and should be removed
bcl_slice_filt <- bcl_slice[names(bcl_slice) %in% rownames(bclCorpusUnion$pos)]
length(bcl_slice_filt)

bclCorpusUnion$slice <- bcl_slice_filt

```

## Txn clustering

txn clustering of the spots using the union set of OD genes

```{r}

set.seed(888)

# use the CPM adjusted counts

pcs.info <- prcomp(t(log10(as.matrix(bcl_CPM[unionBCLGenes,rownames(bclCorpusUnion$pos)])+1)), center=TRUE)
plot(pcs.info$sdev[1:30])
nPcs <- 5
pcs <- pcs.info$x[,1:nPcs]
# 2D embedding by tSNE
emb <- Rtsne::Rtsne(pcs,
                    is_distance=FALSE,
                    perplexity=30,
                    num_threads=1,
                    verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)
# Graph-based cluster detection
k <- 350
bcl_com <- MERINGUE::getClusters(pcs, k, method=igraph::cluster_louvain)


pdf(file = paste0(draft_fig_path, "Fig_3_txn-clustering-union-ODs.pdf"),   # The directory you want to save the file in
  width = 6, # The width of the plot in inches
  height = 5) # The height of the plot in inches
par(mfrow=c(2,2), mar=rep(1,4))
# top row
# left: all slice spots tSNE embedding and labeled by cluster assignment
MUDAN::plotEmbedding(emb, groups=bcl_com,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: all slice spots tSNE embedding and labeled by tissuse slice assignment
MUDAN::plotEmbedding(emb, groups=bclCorpusUnion$slice,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)
# bottom row
# left: spots labeld by cluster assignment and overlayed on each slice.
# Same clusters seem to be at similar spot locations on slices. Nice to see
MUDAN::plotEmbedding(bclCorpusUnion$pos, groups=bcl_com,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: spots colored by slice and slices overlayed
MUDAN::plotEmbedding(bclCorpusUnion$pos, groups=bclCorpusUnion$slice,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)
dev.off()

# capture the txn cluster assignment of the spots
bclCorpusUnion$txn <- bcl_com

```

# LDA training

```{r}

# fit models to a range of K's that include 5 (5 original txn clusters) and
# 37 and 38 (for the cts in the scRNAseq refs; 38 originally but SL doesn't find and Meis2 so dropped)
ks <- seq(from = 2, to = 10, by = 1)

```

## Shared ODs

```{r}

pdf(file = paste0(draft_fig_path, "Fig_3_bcl-1-4-shared-od-training.pdf"))
bcl_LDAs <- fitLDA(counts = bclCorpus$slm, # 152 genes, 1029 spots
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

### k=5

```{r}

bcl_k5 <- buildLDAobject(LDAmodel = optimalModel(bcl_LDAs, opt = "kneed"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

### k=10

```{r}

bcl_k10 <- buildLDAobject(LDAmodel = optimalModel(bcl_LDAs, opt = "min"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```
## Union ODs

```{r}

pdf(file = paste0(draft_fig_path, "Fig_3_bcl-1-4-union-od-training.pdf"))
bcl_LDAs_unionODs <- fitLDA(counts = bclCorpusUnion$slm, # 372 genes 1029 spots
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

### k=5

```{r}

bcl_union_k5 <- buildLDAobject(LDAmodel = optimalModel(bcl_LDAs_unionODs, opt = "kneed"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

### k=8

```{r}

bcl_union_k8 <- buildLDAobject(LDAmodel = optimalModel(bcl_LDAs_unionODs, opt = "min"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

# ---------------------------------

# Viz topics

# adjusted positions

## he1

```{r}

he1 <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer1_BC.jpg')

# alignment matrices came with these images
he_align1 <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer1_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale1 <- bclCorpus$pos[bclCorpus$slice==1,]

# use the alignment file to adjust
posScale1[,"x"] <- posScale1[,"x"] * he_align1[1,1]
posScale1[,"y"] <- posScale1[,"y"] * he_align1[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale1[,"x"] <- posScale1[,"x"] - min(posScale1[,"x"])
posScale1[,"y"] <- posScale1[,"y"] - min(posScale1[,"y"])

# posScale1 <- MERINGUE::rotatePos(posScale1, theta = pi/(180/32))

# Flip the spots horizontally
posScale1[,"y"] <- posScale1[,"y"] + 2*((dim(he1)[1]/2) - posScale1[,"y"])
# posScale1[,"x"] <- posScale1[,"x"] + 2*((dim(he1)[2]/2) - posScale1[,"x"])

# posScale1 <- MERINGUE::rotatePos(posScale1, theta = pi/(180/30))

# set the x and y to start at 0 again, after flipping
posScale1[,"x"] <- posScale1[,"x"] - min(posScale1[,"x"])
posScale1[,"y"] <- posScale1[,"y"] - min(posScale1[,"y"])

posScale1 <- MERINGUE::rotatePos(posScale1, theta = pi/(180/91))

posScale1[,"x"] <- posScale1[,"x"] - min(posScale1[,"x"])
posScale1[,"y"] <- posScale1[,"y"] - min(posScale1[,"y"])

# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale1[,"x"] <- posScale1[,"x"] + 1500
posScale1[,"y"] <- posScale1[,"y"] + 1400

```

## he2

```{r}

he2 <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer2_BC.jpg')

# alignment matrices came with these images
he_align2 <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer2_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale2 <- bclCorpus$pos[bclCorpus$slice==2,]

# use the alignment file to adjust
posScale2[,"x"] <- posScale2[,"x"] * he_align2[1,1]
posScale2[,"y"] <- posScale2[,"y"] * he_align2[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale2[,"x"] <- posScale2[,"x"] - min(posScale2[,"x"])
posScale2[,"y"] <- posScale2[,"y"] - min(posScale2[,"y"])

# posScale1 <- MERINGUE::rotatePos(posScale1, theta = pi/(180/32))

# Flip the spots horizontally
posScale2[,"y"] <- posScale2[,"y"] + 2*((dim(he2)[1]/2) - posScale2[,"y"])
# posScale2[,"x"] <- posScale2[,"x"] + 2*((dim(he2)[2]/2) - posScale2[,"x"])

# set the x and y to start at 0 again, after flipping
posScale2[,"x"] <- posScale2[,"x"] - min(posScale2[,"x"])
posScale2[,"y"] <- posScale2[,"y"] - min(posScale2[,"y"])

posScale2 <- MERINGUE::rotatePos(posScale2, theta = pi/(180/78))

posScale2[,"x"] <- posScale2[,"x"] - min(posScale2[,"x"])
posScale2[,"y"] <- posScale2[,"y"] - min(posScale2[,"y"])

# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale2[,"x"] <- posScale2[,"x"] + 1200
posScale2[,"y"] <- posScale2[,"y"] + 2050

```

## he3

```{r}

he3 <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer3_BC.jpg')

# alignment matrices came with these images
he_align3 <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer3_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale3 <- bclCorpus$pos[bclCorpus$slice==3,]
# use the alignment file to adjust
posScale3[,"x"] <- posScale3[,"x"] * he_align3[1,1]
posScale3[,"y"] <- posScale3[,"y"] * he_align3[2,2]
# bring coordinates to positive values
posScale3[,"x"] <- posScale3[,"x"] - min(posScale3[,"x"])
posScale3[,"y"] <- posScale3[,"y"] - min(posScale3[,"y"])
# final adjustments

posScale3 <- MERINGUE::rotatePos(posScale3, theta = -pi/(180/32))
# for image 3, need to flip the spots across a vertical axis
# flip spots
posScale3[,"y"] <- posScale3[,"y"] + 2*((dim(he3)[1]/2) - posScale3[,"y"])
# posScale3[,"x"] <- posScale3[,"x"] + 2*((dim(he3)[2]/2) - posScale3[,"x"])
# then rotate the spots in radians
# posScale3 <- MERINGUE::rotatePos(posScale3, theta = -pi/(180/32))
# now reset the x and y to start at 0
posScale3[,"x"] <- posScale3[,"x"] - min(posScale3[,"x"])
posScale3[,"y"] <- posScale3[,"y"] - min(posScale3[,"y"])
# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale3[,"x"] <- posScale3[,"x"] + 2300
posScale3[,"y"] <- posScale3[,"y"] + 2350

```

## he4

```{r}

he4 <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer4_BC.jpg')

# alignment matrices came with these images
he_align4 <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer4_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale4 <- bclCorpus$pos[bclCorpus$slice==4,]

# use the alignment file to adjust
posScale4[,"x"] <- posScale4[,"x"] * he_align4[1,1]
posScale4[,"y"] <- posScale4[,"y"] * he_align4[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale4[,"x"] <- posScale4[,"x"] - min(posScale4[,"x"])
posScale4[,"y"] <- posScale4[,"y"] - min(posScale4[,"y"])

# posScale1 <- MERINGUE::rotatePos(posScale1, theta = pi/(180/32))

# Flip the spots horizontally
posScale4[,"y"] <- posScale4[,"y"] + 2*((dim(he4)[1]/2) - posScale4[,"y"])
# posScale4[,"x"] <- posScale4[,"x"] + 2*((dim(he4)[2]/2) - posScale4[,"x"])

# set the x and y to start at 0 again, after flipping
posScale4[,"x"] <- posScale4[,"x"] - min(posScale4[,"x"])
posScale4[,"y"] <- posScale4[,"y"] - min(posScale4[,"y"])

posScale4 <- MERINGUE::rotatePos(posScale4, theta = pi/(180/5))

posScale4[,"x"] <- posScale4[,"x"] - min(posScale4[,"x"])
posScale4[,"y"] <- posScale4[,"y"] - min(posScale4[,"y"])

# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale4[,"x"] <- posScale4[,"x"] + 900
posScale4[,"y"] <- posScale4[,"y"] + 2300

```

combined adjusted positions

```{r}

posScaleAll <- rbind(posScale1,
      posScale2,
      posScale3,
      posScale4)

```


# Shared ODs

## k=5

```{r}

for (i in seq(5)){

  m <- bcl_k5$theta[,i]
  p <- bclCorpus$pos
  sliceTxnClusters <- bclCorpus$txn

  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")

  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))

  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))

  p <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  ggsave(filename = paste0("bcl_k5-layers-topic-", i, ".pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)

  print(p)

}

for (s in unique(bclCorpus$slice)){
  slice <- bclCorpus$slice == s
  m <- bcl_k5$theta[slice,]
  p <- bclCorpus$pos[slice,]
  sliceTxnClusters <- bclCorpus$txn[slice]
  
  p <- vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=gg_color_hue(ncol(m)),
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 0.4, # different size piecharts for mOB data sets
               lwd = 0.1,
               showLegend = TRUE,
               plotTitle = NA)
  ggsave(filename = paste0("bcl_k5-layer-", s, "-all-topics.pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  print(p)
}

```

```{r}

# slice <- bclCorpus$slice == 1

for (s in unique(bclCorpus$slice)){
  slice <- bclCorpus$slice == s
  for (i in seq(5)){
  
    m <- bcl_k5$theta[slice,i]
    p <- bclCorpus$pos[slice,]
    sliceTxnClusters <- bclCorpus$txn[slice]
  
    other <- 1 - m
    m <- cbind(m, other)
    colnames(m) <- c(as.character(i), "other")
  
    cc <- c(
      transparentCol("black", percent = 0),
      # transparentCol("blue", percent = 50),
      transparentCol("white", percent = 100))
  
    group_cc <- c("1" = transparentCol("red", percent = 0),
                  "2" = transparentCol("green", percent = 0),
                  "3" = transparentCol("blue", percent = 0))
  
    p <- vizAllTopics(theta = m,
                   pos = p,
                   topicOrder=seq(ncol(m)),
                   topicCols=cc,
                   groups = sliceTxnClusters,
                   group_cols = group_cc,
                   r = 0.4,
                   lwd = 0.2,
                   showLegend = TRUE,
                   plotTitle = paste("Slice", s))
    ggsave(filename = paste0("bcl_k5-layer-", s, "-topic-", i, ".pdf"),
           device = "pdf",
           path = draft_fig_path,
           scale = 1.5,
           width = 5,
           height = 4,
           units = c("in"),
           dpi = 600)
  
    print(p)
  
  }
}

```

## k=10

```{r}

corpus <- bclCorpus
ldamodel <- bcl_k10

for (i in seq(10)){
  
  m <- ldamodel$theta[,i]
  p <- corpus$pos
  sliceTxnClusters <- corpus$txn
  
  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")
  
  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))
  
  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))
  
  plt <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  ggsave(filename = paste0("bcl_k10-all-layers-topic-", i, ".pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  print(plt)
  
}

```

```{r}

corpus <- bclCorpus
ldamodel <- bcl_k10
nT <- 10

for (s in unique(corpus$slice)){
  slice <- corpus$slice == s
  if (s == 1){
    he <- he1
    p <- posScale1
  }
  if (s == 2){
    he <- he2
    p <- posScale2
  }
  if (s == 3){
    he <- he3
    p <- posScale3
  }
  if (s == 4){
    he <- he4
    p <- posScale4
  }
  
  # all topics
  slice <- corpus$slice == s
  m <- ldamodel$theta[slice,]
  # p <- corpus$pos[slice,]
  sliceTxnClusters <- corpus$txn[slice]
  tcols <- gg_color_hue(ncol(m))
  
  plt <- vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=tcols,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.1,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he)
  ggsave(filename = paste0("bcl_k10-layer-", s, "-all-topics.png"),
         device = "png",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  print(plt)
  
  for (i in seq(nT)){
  
    m <- ldamodel$theta[slice,i]
    # p <- bclCorpus$pos[slice,]
    sliceTxnClusters <- corpus$txn[slice]
  
    other <- 1 - m
    m <- cbind(m, other)
    colnames(m) <- c(as.character(i), "other")
  
    cc <- c(
      transparentCol(tcols[i], percent = 0),
      # transparentCol("blue", percent = 50),
      transparentCol("white", percent = 100))
  
    group_cc <- c("1" = transparentCol("red", percent = 0),
                  "2" = transparentCol("green", percent = 0),
                  "3" = transparentCol("blue", percent = 0))
  
    plt <- vizAllTopics(theta = m,
                   pos = p,
                   topicOrder=seq(ncol(m)),
                   topicCols=cc,
                   groups = sliceTxnClusters,
                   group_cols = rep("black", 3),
                   r = 100, #0.4
                   lwd = 0.3,
                   showLegend = TRUE,
                   plotTitle = paste("Slice", s),
                   overlay = he)
    ggsave(filename = paste0("bcl_k10-layer-", s, "-topic-", i, ".png"),
           device = "png",
           path = draft_fig_path,
           scale = 1.5,
           width = 5,
           height = 4,
           units = c("in"),
           dpi = 300)
  
    print(plt)
  
  }
}

```

# Union ODs

## k=5

```{r}

for (i in seq(5)){

  m <- bcl_union_k5$theta[,i]
  p <- bclCorpusUnion$pos
  sliceTxnClusters <- bclCorpusUnion$txn

  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")

  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))

  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))

  p <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  ggsave(filename = paste0("bcl_union_k5-layers-topic-", i, ".pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)

  print(p)

}

for (s in unique(bclCorpusUnion$slice)){
  slice <- bclCorpusUnion$slice == s
  m <- bcl_union_k5$theta[slice,]
  p <- bclCorpusUnion$pos[slice,]
  sliceTxnClusters <- bclCorpusUnion$txn[slice]
  
  p <- vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=gg_color_hue(ncol(m)),
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 0.4, # different size piecharts for mOB data sets
               lwd = 0.1,
               showLegend = TRUE,
               plotTitle = NA)
  ggsave(filename = paste0("bcl_union_k5-layer-", s, "-all-topics.pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  print(p)
}

```

```{r}

# slice <- bclCorpusUnion$slice == 1

for (s in unique(bclCorpusUnion$slice)){
  slice <- bclCorpusUnion$slice == s
  for (i in seq(5)){
  
    m <- bcl_union_k5$theta[slice,i]
    p <- bclCorpusUnion$pos[slice,]
    sliceTxnClusters <- bclCorpusUnion$txn[slice]
  
    other <- 1 - m
    m <- cbind(m, other)
    colnames(m) <- c(as.character(i), "other")
  
    cc <- c(
      transparentCol("black", percent = 0),
      # transparentCol("blue", percent = 50),
      transparentCol("white", percent = 100))
  
    group_cc <- c("1" = transparentCol("red", percent = 0),
                  "2" = transparentCol("green", percent = 0),
                  "3" = transparentCol("blue", percent = 0))
  
    p <- vizAllTopics(theta = m,
                   pos = p,
                   topicOrder=seq(ncol(m)),
                   topicCols=cc,
                   groups = sliceTxnClusters,
                   group_cols = group_cc,
                   r = 0.4,
                   lwd = 0.2,
                   showLegend = TRUE,
                   plotTitle = paste("Slice", s))
    ggsave(filename = paste0("bcl_union_k5-layer-", s, "-topic-", i, ".pdf"),
           device = "pdf",
           path = draft_fig_path,
           scale = 1.5,
           width = 5,
           height = 4,
           units = c("in"),
           dpi = 600)
  
    print(p)
  
  }
}

```

```{r}

# slice <- bclCorpusUnion$slice == 1

for (s in unique(bclCorpusUnion$slice)){
  slice <- bclCorpusUnion$slice == s
  for (i in seq(5)){
  
    m <- bcl_union_k5$theta[slice,i]
    p <- bclCorpusUnion$pos[slice,]
    sliceTxnClusters <- bclCorpusUnion$txn[slice]
  
    other <- 1 - m
    m <- cbind(m, other)
    colnames(m) <- c(as.character(i), "other")
  
    cc <- c(
      transparentCol("black", percent = 0),
      # transparentCol("blue", percent = 50),
      transparentCol("white", percent = 100))
  
    group_cc <- c("1" = transparentCol("red", percent = 0),
                  "2" = transparentCol("green", percent = 0),
                  "3" = transparentCol("blue", percent = 0))
  
    p <- vizAllTopics(theta = m,
                   pos = p,
                   topicOrder=seq(ncol(m)),
                   topicCols=cc,
                   groups = sliceTxnClusters,
                   group_cols = group_cc,
                   r = 0.4,
                   lwd = 0.2,
                   showLegend = TRUE,
                   plotTitle = paste("Slice", s))
    ggsave(filename = paste0("bcl_union_k5-layer-", s, "-topic-", i, ".pdf"),
           device = "pdf",
           path = draft_fig_path,
           scale = 1.5,
           width = 5,
           height = 4,
           units = c("in"),
           dpi = 600)
  
    print(p)
  
  }
}

```

## k=8

```{r}

for (i in seq(8)){
  
  m <- bcl_union_k8$theta[,i]
  p <- bclCorpusUnion$pos
  sliceTxnClusters <- bclCorpusUnion$txn
  
  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")
  
  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))
  
  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))
  
  p <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  ggsave(filename = paste0("bcl_union_k8-layers-topic-", i, ".pdf"),
         device = "pdf",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  print(p)
  
}

```

try making heatmap?

```{r}

# Sequence of X-coord positions for left edge of each patch:
    x_edges <- seq(min(selected_bregma$Centroid_X), max(selected_bregma$Centroid_X), patch_size)
    # drop first and last to avoid any issues with the edges of the whole region
    inner_x_edges <- x_edges[2:(length(x_edges)-1)]
    # Sequence of Y-coord positions for bottom edge of each patch:
    y_edges <- seq(min(selected_bregma$Centroid_Y), max(selected_bregma$Centroid_Y), patch_size)
    inner_y_edges <- y_edges[2:(length(y_edges)-1)]
    
    selected_bregma$patch_id <- character(length(rownames(selected_bregma)))
    
    # 2. add patch IDs to bregma cells, for the patch they belong to:
    
    for (x in inner_x_edges) {
      for (y in inner_y_edges) {
        patch_id <- paste0(as.character(x), "_", as.character(y))
        patch <- selected_bregma[which( (selected_bregma$Centroid_X > x) &
                                          (selected_bregma$Centroid_X < x+patch_size) &
                                          (selected_bregma$Centroid_Y > y) &
                                          (selected_bregma$Centroid_Y < y+patch_size) ),]
        
        if (length(rownames(patch)) > 0) {
          selected_bregma[rownames(patch),]$patch_id <- patch_id
        }
      }
    }

```

```{r}

pos <- bclCorpusUnion$pos
x_edges <- seq(min(pos$x), max(pos$x), 1)
y_edges <- seq(min(pos$y), max(pos$y), 1)

pos$patch_id <- character(length(rownames(pos)))
for (x in x_edges) {
  for (y in y_edges) {
    patch_id <- paste0(as.character(x), "_", as.character(y))
    patch <- pos[which( (pos$x > x) &
                        (pos$x < x+1) &
                        (pos$y > y) &
                        (pos$y < y+1) ),]
    
    if (length(rownames(patch)) > 0) {
      pos[rownames(patch),]$patch_id <- patch_id
    }
  }
}

```


# ---------------------------------

# Correlation with Txn

# theta

```{r}

# proxy theta for the txn clusters
bclProxyTheta <- model.matrix(~ 0 + bclCorpus$txn)
rownames(bclProxyTheta) <- names(bclCorpus$txn)
# fix names
colnames(bclProxyTheta) <- c("1", "2", "3")
bclProxyTheta <- as.data.frame.matrix(bclProxyTheta)
dim(bclProxyTheta)

```

## Shared

### k=5

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyTheta),
                     m2 = bcl_k5$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

### k=10

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyTheta),
                     m2 = bcl_k10$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k10 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k10 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

## Union

### k=5

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyTheta),
                     m2 = bcl_union_k5$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

### k=8

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyTheta),
                     m2 = bcl_union_k8$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k8 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k8 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

# beta

```{r}

bclProxyBeta <- t(as.matrix(bcl_countsClean) %*% as.matrix(bclProxyTheta))
bclProxyBeta <- bclProxyBeta/rowSums(bclProxyBeta)
dim(bclProxyBeta)

```

## Shared

### k=5

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyBeta),
                     m2 = bcl_k5$beta,
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

### k=10

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyBeta),
                     m2 = bcl_k10$beta,
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k10 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_k10 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

## Union

### k=5

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyBeta),
                     m2 = bcl_union_k5$beta,
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k5 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

### k=8

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(bclProxyBeta),
                     m2 = bcl_union_k8$beta,
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k8 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "bcl_union_k8 Topics",
                  ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
# dev.off()

# # correlations along diagonal (after assigning best matches)
# diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])
# 
# # hist(lda_vs_sl_theta, breaks = 10)
# mean(diag_corrs)
# sd(diag_corrs)

```

# ---------------------------------

# Co-localization

## Shared

### k=5

```{r}

slice <- which(bclCorpus$slice %in% c(1))

corMtxT <- getCorrMtx(m1 = bcl_k5$theta[slice,],
                     m2 = bcl_k5$theta[slice,],
                     type = "t")
diag(corMtxT) <- NA
heatmap(corMtxT, col=correlation_palette, scale = "none")
print(corMtxT)

corMtxB <- getCorrMtx(m1 = bcl_k5$beta,
                     m2 = bcl_k5$beta,
                     type = "b")
diag(corMtxB) <- NA
heatmap(corMtxB, col=correlation_palette, scale = "none")
print(corMtxB)

foo <- scale0_1(corMtxT) - scale0_1(corMtxB)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none')
print(foo)

```

Positional correlations

```{r}

# top pcors:
sort(corMtxT, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxT >= sort(corMtxT, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxT == max(corMtxT, na.rm=TRUE), arr.ind=TRUE)

```

Txn correlation

```{r}

# top tcor:
sort(corMtxB, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxB >= sort(corMtxB, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxB == max(corMtxB, na.rm=TRUE), arr.ind=TRUE)

```

pos - txn

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor
# largest = positionally similar but txn different

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### vis high pos - txn

```{r, fig.height=10, fig.width=11}

slice <- bclCorpus$slice == 1
m <- bcl_k5$theta[slice,c("1","3")]
p <- bclCorpus$pos[slice,]
sliceTxnClusters <- bclCorpus$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale1,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he1)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpus$slice == 2
m <- bcl_k5$theta[slice,c("1","3")]
p <- bclCorpus$pos[slice,]
sliceTxnClusters <- bclCorpus$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale2,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he2)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpus$slice == 3
m <- bcl_k5$theta[slice,c("1","3")]
p <- bclCorpus$pos[slice,]
sliceTxnClusters <- bclCorpus$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale3,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he3)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpus$slice == 4
m <- bcl_k5$theta[slice,c("1","3")]
p <- bclCorpus$pos[slice,]
sliceTxnClusters <- bclCorpus$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale4,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he4)

```

```{r}

# lowest vals = positionally different but txn similar

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### viz low pos - txn

### k=10

```{r}

slice <- which(bclCorpus$slice %in% c(1,2,3,4))
m <- bcl_k10

corMtxT <- getCorrMtx(m1 = m$theta[slice,],
                     m2 = m$theta[slice,],
                     type = "t")
diag(corMtxT) <- NA
heatmap(corMtxT, col=correlation_palette, scale = "none")
gplots::heatmap.2(x = corMtxT,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "bcl_k5 Topics",
                  # ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
corMtxT

corMtxB <- getCorrMtx(m1 = m$beta,
                     m2 = m$beta,
                     type = "b")
diag(corMtxB) <- NA
heatmap(corMtxB, col=correlation_palette, scale = "none")
gplots::heatmap.2(x = corMtxB,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "bcl_k5 Topics",
                  # ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
corMtxB

foo <- scale0_1(corMtxT) - scale0_1(corMtxB)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none')
gplots::heatmap.2(x = foo,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "bcl_k5 Topics",
                  # ylab = "Txn Clusters",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,4))
foo

```

Positional correlations

```{r}

# top pcors:
sort(corMtxT, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxT >= sort(corMtxT, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxT == max(corMtxT, na.rm=TRUE), arr.ind=TRUE)

```

Txn correlation

```{r}

# top tcor:
sort(corMtxB, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxB >= sort(corMtxB, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxB == max(corMtxB, na.rm=TRUE), arr.ind=TRUE)

```

pos - txn

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor
# largest = positionally similar but txn different

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### vis high pos - txn

```{r}

corpus <- bclCorpus
ldamodel <- bcl_k10
topics <- c("6", "9")

for (s in unique(corpus$slice)){
  slice <- corpus$slice == s
  if (s == 1){
    he <- he1
    p <- posScale1
  }
  if (s == 2){
    he <- he2
    p <- posScale2
  }
  if (s == 3){
    he <- he3
    p <- posScale3
  }
  if (s == 4){
    he <- he4
    p <- posScale4
  }
  
  # all topics
  slice <- corpus$slice == s
  m <- ldamodel$theta[slice, topics]
  # p <- corpus$pos[slice,]
  sliceTxnClusters <- corpus$txn[slice]
  
  other <- 1 - rowSums(m)
  m <- cbind(m, other)
  
  cc <- c(
    transparentCol("darkorange", percent = 30),
    transparentCol("cyan2", percent = 30),
    transparentCol("white", percent = 100))
  
  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))
  
  plt <- vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = rep(transparentCol("white", percent = 100), 3),
               r = 100,
               lwd = 0.1,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he)
  ggsave(filename = paste0("bcl_k10-layer-", s, "-co-local-6-9.png"),
         device = "png",
         path = draft_fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  print(plt)
}

```

```{r}

slice <- which(bclCorpus$slice %in% c(1,2,3,4))
m <- bcl_k10$theta[slice,c("9","6")]
p <- bclCorpus$pos[slice,]
sliceTxnClusters <- bclCorpus$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("darkorange", percent = 30),
  transparentCol("cyan2", percent = 30),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = rep(transparentCol("white", percent = 100), 3),
               r = 0.4,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = NA)

```

```{r}

# lowest vals = positionally different but txn similar

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### viz low pos - txn

## Union

### k=5

Counts of spots where topics above certain proportions

```{r}

bcl_union_k5_02 <- do.call(cbind, lapply(seq(5), function(i){
  bcl_union_k5$theta[,i] > 0.2
}))
colnames(bcl_union_k5_02) <- paste(seq(5))

```

Correlations

```{r}

slice <- which(bclCorpusUnion$slice %in% c(1,2,3,4))

corMtxT <- getCorrMtx(m1 = bcl_union_k5$theta[slice,],
                     m2 = bcl_union_k5$theta[slice,],
                     type = "t")
diag(corMtxT) <- NA
heatmap(corMtxT, col=correlation_palette, scale = "none")
print(corMtxT)

corMtxB <- getCorrMtx(m1 = bcl_union_k5$beta,
                     m2 = bcl_union_k5$beta,
                     type = "b")
diag(corMtxB) <- NA
heatmap(corMtxB, col=correlation_palette, scale = "none")
print(corMtxB)

foo <- scale0_1(corMtxT) - scale0_1(corMtxB)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none')
print(foo)

```

Positional correlations

```{r}

# top pcors:
sort(corMtxT, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxT >= sort(corMtxT, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxT == max(corMtxT, na.rm=TRUE), arr.ind=TRUE)

```

Txn correlation

```{r}

# top tcor:
sort(corMtxB, decreasing = TRUE)[1:10]
# the pairs:
which(corMtxB >= sort(corMtxB, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(corMtxB == max(corMtxB, na.rm=TRUE), arr.ind=TRUE)

```

pos - txn

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor
# largest = positionally similar but txn different

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### vis high pos - txn

```{r, fig.height=10, fig.width=11}

topics <- c("3", "4")
slice <- bclCorpusUnion$slice == 1

m <- bcl_union_k5$theta[slice, topics]
p <- bclCorpusUnion$pos[slice,]
sliceTxnClusters <- bclCorpusUnion$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

# for the txn spot clusters `sliceTxnClusters`
# group_cc <- c("1" = transparentCol("red", percent = 30),
#               "2" = transparentCol("green", percent = 30),
#               "3" = transparentCol("blue", percent = 30))


# boolean matrix where TRUE is topic above certain percent in spot
# use to get spots where both topics are above certain percent
topic_perc <- bcl_union_k5_01[, topics]
group_labs <- cbind(topic_perc, apply(topic_perc, 1, function(x){
  if (x[1] & x[2]){
    # return(transparentCol("red", percent = 20))
    return("1")
  }
  if (x[1] & ! x[2]){
    # return(transparentCol("blue", percent = 70))
    return("0")
  }
  if (! x[1] & x[2]){
    # return(transparentCol("purple", percent = 70))
    return("0")
  }
  if (! x[1] & ! x[2]){
    # return(transparentCol("white", percent = 60))
    return("0")
  }
}))
colnames(group_labs) <- c(topics, "cols")


vizAllTopics(theta = m,
               pos = posScale1,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = group_labs[slice, "cols"], # sliceTxnClusters
               group_cols = c("0" = transparentCol("white", percent = 100), "1" = "white"), # group_cc
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he1)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpusUnion$slice == 2
m <- bcl_union_k5$theta[slice,c("2","3")]
p <- bclCorpusUnion$pos[slice,]
sliceTxnClusters <- bclCorpusUnion$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale2,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he2)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpusUnion$slice == 3
m <- bcl_union_k5$theta[slice,c("2","3")]
p <- bclCorpusUnion$pos[slice,]
sliceTxnClusters <- bclCorpusUnion$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale3,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he3)

```

```{r, fig.height=10, fig.width=11}

slice <- bclCorpusUnion$slice == 4
m <- bcl_union_k5$theta[slice,c("2","3")]
p <- bclCorpusUnion$pos[slice,]
sliceTxnClusters <- bclCorpusUnion$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale4,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he4)

```

```{r}

# lowest vals = positionally different but txn similar

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

#### viz low pos - txn

```{r, fig.height=10, fig.width=11}

slice <- bclCorpusUnion$slice == 1
m <- bcl_union_k5$theta[slice,c("4","5")]
p <- bclCorpusUnion$pos[slice,]
sliceTxnClusters <- bclCorpusUnion$txn[slice]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("magenta", percent = 20),
  transparentCol("cyan", percent = 20),
  transparentCol("white", percent = 100))

group_cc <- c("1" = transparentCol("red", percent = 30),
              "2" = transparentCol("green", percent = 30),
              "3" = transparentCol("blue", percent = 30))

vizAllTopics(theta = m,
               pos = posScale1,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("black", "black", "black"),
               r = 100,
               lwd = 0.3,
               showLegend = TRUE,
               plotTitle = NA,
               overlay = he1)
```

# ---------------------------------

# topic intersections

instead of co-localization via correlation, look to see which topics are in same spots in general.

So count a topic as being in a spot if it is > %. Then compute overlap of spots with different topics. To start lets say >10%. figure out way to maybe get quantitative?

```{r}

bcl_union_k5_02 <- do.call(cbind, lapply(seq(5), function(i){
  bcl_union_k5$theta[,i] > 0.2
}))
colnames(bcl_union_k5_02) <- paste(seq(5))

```

```{r}

m <- bcl_union_k5_02

# listInput <- list("3 and 4" = rownames(m[which(m[,"3"] & m[,"4"]),]),
#                   "3" = rownames(m[which(m[,"3"]),]),
#                   "4" = rownames(m[which(m[,"4"]),]),
#                   "3 and 2" = rownames(m[which(m[,"3"] & m[,"2"]),]),
#                   # "3" = rownames(m[which(m[,"3"]),]),
#                   "2" = rownames(m[which(m[,"2"]),]))

listInput <- list("1" = rownames(m[which(m[,"1"]),]),
                  "2" = rownames(m[which(m[,"2"]),]),
                  "3" = rownames(m[which(m[,"3"]),]),
                  "4" = rownames(m[which(m[,"4"]),]),
                  "5" = rownames(m[which(m[,"5"]),]))

pdf(file = paste0(draft_fig_path, "Fig_3_bcl_union_k5-UpSetR-20perc.pdf"),
    width = 5,
    height = 3)
upset(fromList(listInput), order.by = "freq")
dev.off()

# library(venn)
pdf(file = paste0(draft_fig_path, "Fig_3_bcl_union_k5-venn-20perc.pdf"),
    width = 4,
    height = 4)
venn(
  listInput,
  ilabels = TRUE,zcolor = "style", size = 25, cexil = 1.2, cexsn = 1.5)
dev.off()

```

# ---------------------------------


# GSEA

```{r}

gsea_bcl_draft_figs <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/draft_figures/gsea_bcl/"

```

# - GO

```{r}

library(liger)
data(org.Hs.GO2Symbol.list) ## load built in GO gene sets

# list of GO terms and associated genes
go.env <- org.Hs.GO2Symbol.list

library(GO.db)
library(AnnotationDbi)

# annotate the GO terms
# dataframe of GO ID and the associated term annotation
desc <- AnnotationDbi::select(
  GO.db,
  keys = names(go.env),
  columns = c("TERM"),
  multiVals = 'CharacterList'
)

# append GO term list names with their annotations
names(go.env) <- paste(names(go.env), desc$TERM)

```

## Shared

### k=5

```{r}

gset <- go.env
for (i in seq(5)){
  
  vals <- sort(bcl_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-GO-bcl_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=10

```{r}

gset <- go.env
for (i in seq(10)){
  
  vals <- sort(bcl_k10$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  # for (j in seq(5)){
  #   pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-GO-bcl_k10-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
  #     width = 6, height = 5)
  #   gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  #   dev.off()
  # }
}

```

## Union

### k=5

```{r}

gset <- go.env
for (i in seq(5)){
  
  vals <- sort(bcl_union_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  # for (j in seq(5)){
  #   pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-GO-bcl_union_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
  #     width = 6, height = 5)
  #   gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  #   dev.off()
  # }
}

```

### k=8

```{r}

gset <- go.env
for (i in seq(8)){
  
  vals <- sort(bcl_union_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-GO-bcl_union_k8-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

# - C8 cts

```{r}

library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C8") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C8_gsea_ct_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C8_gsea_ct_gene_list) <- unique(gene_set$gs_name)

```

## Shared

### k=5

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C8-bcl_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=10

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(10)){
  
  vals <- sort(bcl_k10$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C8-bcl_k10-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

## Union

### k=5

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_union_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C8-bcl_union_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=8

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(8)){
  
  vals <- sort(bcl_union_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C8-bcl_union_k8-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

# - C7 immuno

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C7") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C7_gsea_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C7_gsea_gene_list) <- unique(gene_set$gs_name)

```

## Shared

### k=5

```{r}

gset <- C7_gsea_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C7-bcl_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=10

```{r}

gset <- C7_gsea_gene_list
for (i in seq(10)){
  
  vals <- sort(bcl_k10$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C7-bcl_k10-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

## Union

### k=5

```{r}

gset <- C7_gsea_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_union_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C7-bcl_union_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=8

```{r}

gset <- C7_gsea_gene_list
for (i in seq(8)){
  
  vals <- sort(bcl_union_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-C7-bcl_union_k8-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

# - C2 KEGG

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C2") %>%
                dplyr::filter(gs_subcat == "CP:KEGG") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C2_gsea_kegg_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C2_gsea_kegg_gene_list) <- unique(gene_set$gs_name)

```

## Shared

### k=5

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-kegg-bcl_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=10

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(10)){
  
  vals <- sort(bcl_k10$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-kegg-bcl_k10-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

## Union

### k=5

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(5)){
  
  vals <- sort(bcl_union_k5$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-kegg-bcl_union_k5-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

### k=8

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(8)){
  
  vals <- sort(bcl_union_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    pdf(file = paste0(gsea_bcl_draft_figs, "Fig_3_gsea-kegg-bcl_union_k8-topic-", i, "-", rownames(gsea.sig)[j], ".pdf"),
      width = 6, height = 5)
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
    dev.off()
  }
}

```

# -------------------------------------

# Overlay spots 

overlay the txn cluster labeled spots on top of the H&E images

```{r}

# 12 custom colors that look decent on top of the purple H&E
topic_colors <- c("red", "yellow", "green", "magenta", "black", "cyan", "tan2", "orange", "blue", "sienna", "seagreen", "turquoise1")

```

## BCL1

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer1_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer1_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bclCorpus$slice==1,]
sliceTxnClusters <- bcl_com[bclCorpus$slice==1]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# Flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# posScale[,"x"] <- posScale[,"x"]

# set the x and y to start at 0 again, after flipping
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale[,"x"] <- posScale[,"x"] + 1380
posScale[,"y"] <- posScale[,"y"] + 2669


# plotting:
# ==============================================

pdf(file = paste0(fig_path, "Fig_3_bcl-txn-slice-1.pdf"),   # The directory you want to save the file in
  width = 2, # The width of the plot in inches
  height = 2.5) # The height of the plot in inches
# par(mfrow=c(1,1), mar=rep(5,4))
# plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=scales::alpha(MERINGUE:::fac2col(sliceTxnClusters), alpha = 0.4), pch=16, cex = 0.2)
dev.off()

# m <- bcl_k12$theta[names(sliceTxnClusters),]
# p <- posScale # bclCorpus$pos[names(sliceTxnClusters),]
# 
# # vizAllTopics(theta = m,
# #              pos = p,
# #              topicOrder=seq(ncol(m)),
# #              topicCols=topo.colors(ncol(m)),
# #              groups = NA,
# #              group_cols = NA,
# #              r = 100,
# #              lwd = 0.01,
# #              showLegend = TRUE,
# #              plotTitle = NA,
# #              overlay = he)
# 
# # clustCols <- RColorBrewer::brewer.pal(12, name = "Set1")
# # clustCols <- topo.colors(5)
# clustCols <- topic_colors
# names(clustCols) <- colnames(bcl_k12$theta)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = as.factor(clustCols),
#                  sharedCol = TRUE,
#                  groups = NA,
#                  group_cols = NA,
#                  r = 100,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(1)),
#                  overlay = he)

```

## BCL2 

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer2_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer2_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bclCorpus$slice==2,]
sliceTxnClusters <- bcl_com[bclCorpus$slice==2]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# final adjustments

# for image 2, the spots actually need to be rotated slightly to align properly with the tissue image
# based on the Stahl data spot coordinates, plot the base image and the spots rotated along the horizontal
# axis (similar strategy done above for he1). This is the alignment we want.
# Then, can take the range of the x and y coordinates for the Stahl plots.
# The difference between the min and max are how we can check that the rotation
# done below for this plot has the spots placed in the correct orientation (make sure the x and y range difs here match)
# it turns out that a rotation of 12 degrees looks pretty good

# so, first flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] # + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots by 12 degrees in radians
posScale <- MERINGUE::rotatePos(posScale, theta = -pi/(180/12))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 2010
posScale[,"y"] <- posScale[,"y"] + 2641


# plotting:
# ==============================================

pdf(file = paste0(fig_path, "Fig_3_bcl-txn-slice-2.pdf"),   # The directory you want to save the file in
  width = 2, # The width of the plot in inches
  height = 2.5) # The height of the plot in inches
# par(mfrow=c(1,1), mar=rep(5,4))
# plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=scales::alpha(MERINGUE:::fac2col(sliceTxnClusters), alpha = 0.4), pch=16, cex = 0.2)
dev.off()


# m <- bcl_k12$theta[names(sliceTxnClusters),]
# p <- posScale # bclCorpus$pos[names(sliceTxnClusters),]
# 
# # vizAllTopics(theta = m,
# #              pos = p,
# #              topicOrder=seq(ncol(m)),
# #              topicCols=topo.colors(ncol(m)),
# #              groups = NA,
# #              group_cols = NA,
# #              r = 100,
# #              lwd = 0.01,
# #              showLegend = TRUE,
# #              plotTitle = NA,
# #              overlay = he)
# 
# # clustCols <- RColorBrewer::brewer.pal(12, name = "Set1")
# # clustCols <- topo.colors(5)
# clustCols <- topic_colors
# names(clustCols) <- colnames(bcl_k12$theta)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = as.factor(clustCols),
#                  sharedCol = TRUE,
#                  groups = NA,
#                  group_cols = NA,
#                  r = 100,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(2)),
#                  overlay = he)

```

## BCL 3

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer3_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer3_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bclCorpus$slice==3,]
sliceTxnClusters <- bcl_com[bclCorpus$slice==3]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustments

# for image 3, need to flip the spots across a vertical axis

# flip spots
posScale[,"y"] <- posScale[,"y"] #+ 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots in radians
posScale <- MERINGUE::rotatePos(posScale, theta = pi/(180/32))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 1425
posScale[,"y"] <- posScale[,"y"] + 2902



# plotting:
# ==============================================

# pdf(file = paste0(fig_path, "Fig_3_bcl-txn-slice-3.pdf"),   # The directory you want to save the file in
#   width = 2, # The width of the plot in inches
#   height = 2.5) # The height of the plot in inches
# par(mfrow=c(1,1), mar=rep(5,4))
# plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=scales::alpha(MERINGUE:::fac2col(sliceTxnClusters), alpha = 0.4), pch=16, cex = 0.2)
# dev.off()


# m <- bcl_k12$theta[names(sliceTxnClusters),]
# p <- posScale # bclCorpus$pos[names(sliceTxnClusters),]
# 
# # vizAllTopics(theta = m,
# #              pos = p,
# #              topicOrder=seq(ncol(m)),
# #              topicCols=topo.colors(ncol(m)),
# #              groups = NA,
# #              group_cols = NA,
# #              r = 100,
# #              lwd = 0.01,
# #              showLegend = TRUE,
# #              plotTitle = NA,
# #              overlay = he)
# 
# # clustCols <- RColorBrewer::brewer.pal(12, name = "Set1")
# # clustCols <- topo.colors(5)
# clustCols <- topic_colors
# names(clustCols) <- colnames(bcl_k12$theta)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = as.factor(clustCols),
#                  sharedCol = TRUE,
#                  groups = NA,
#                  group_cols = NA,
#                  r = 100,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(3)),
#                  overlay = he)

```

## BCL 4

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer4_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer4_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bclCorpus$slice==4,]
sliceTxnClusters <- bcl_com[bclCorpus$slice==4]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustments

# for image 4, flip x-coords across vertical axis

# flip spots
# posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots in radians
posScale <- MERINGUE::rotatePos(posScale, theta = pi/(180/5))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 2824
posScale[,"y"] <- posScale[,"y"] + 2033



# plotting:
# ==============================================

pdf(file = paste0(fig_path, "Fig_3_bcl-txn-slice-4.pdf"),   # The directory you want to save the file in
  width = 2, # The width of the plot in inches
  height = 2.5) # The height of the plot in inches
# par(mfrow=c(1,1), mar=rep(5,4))
# plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=scales::alpha(MERINGUE:::fac2col(sliceTxnClusters), alpha = 0.4), pch=16, cex = 0.2)
dev.off()


# m <- bcl_k12$theta[names(sliceTxnClusters),]
# p <- posScale # bclCorpus$pos[names(sliceTxnClusters),]
# 
# # vizAllTopics(theta = m,
# #              pos = p,
# #              topicOrder=seq(ncol(m)),
# #              topicCols=topo.colors(ncol(m)),
# #              groups = NA,
# #              group_cols = NA,
# #              r = 100,
# #              lwd = 0.01,
# #              showLegend = TRUE,
# #              plotTitle = NA,
# #              overlay = he)
# 
# # clustCols <- RColorBrewer::brewer.pal(12, name = "Set1")
# # clustCols <- topo.colors(5)
# clustCols <- topic_colors
# names(clustCols) <- colnames(bcl_k12$theta)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = as.factor(clustCols),
#                  sharedCol = TRUE,
#                  groups = NA,
#                  group_cols = NA,
#                  r = 100,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(3)),
#                  overlay = he)

```

# Co-localization

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(12)

```

```{r}

m <- bcl_k12$theta[bclCorpus$slice == 1,]
p <- bclCorpus$pos[bclCorpus$slice == 1,]
sliceTxnClusters <- bcl_com[bclCorpus$slice==1]
txnCols <- unique(MERINGUE:::fac2col(sliceTxnClusters))

# cc <- as.factor(rainbow(ncol(m)))
# cc <- as.factor(rep("black", 12))
# names(cc) <- colnames(m)

for (i in colnames(m)){
  cc <- as.factor(rep("black", 1))
  names(cc) <- i
  vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = sliceTxnClusters,
                 group_cols = txnCols,
                 r = 0.4,
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = paste("Slice", as.character(1)))
}

# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = sliceTxnClusters,
#                  group_cols = txnCols,
#                  r = 0.4,
#                  lwd = 0.3,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(1)))

```

```{r}


# correlation wrt theta positional proportions
pcor <- do.call(rbind, lapply(1:12, function(i) {
  p1 <- bcl_k12$theta[,i]
  unlist(lapply(1:12, function(j) {
    p2 <- bcl_k12$theta[,j]
    cor(p1, p2)
  }))
}))
diag(pcor) <- NA
heatmap(pcor, col=correlation_palette)
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)


# correlation wrt beta values
tcor <- do.call(rbind, lapply(1:12, function(i) {
  p1 <- bcl_k12$beta[i,]
  unlist(lapply(1:12, function(j) {
    p2 <- bcl_k12$beta[j,]
    cor(p1, p2)
  }))
}))
diag(tcor) <- NA
heatmap(tcor, col=correlation_palette, scale='none')
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)


# difference between topic theta and beta correlations.
# More positive = co-localized but transcriptionally different
# More negative = transcriptionally similar but different spatial locations

# note: the two different correlations are in different scales, so normalize the scales
range(pcor, na.rm = TRUE)
max(range(pcor, na.rm = TRUE)) - min(range(pcor, na.rm = TRUE))

range(tcor, na.rm = TRUE)
max(range(tcor, na.rm = TRUE)) - min(range(tcor, na.rm = TRUE))

foo <- scale0_1(pcor) - scale0_1(tcor)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none', )
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

```{r}

# top pcors:
sort(pcor, decreasing = TRUE)[1:10]
# the pairs:
which(pcor >= sort(pcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)

```

Topics 7 and 11 spatially co-localized. 3 and 1 runner up.

```{r}

# top tcor:
sort(tcor, decreasing = TRUE)[1:10]
# the pairs:
which(tcor >= sort(tcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)

```

Topics 11 and 1 most positively correlated transcriptionally, but 5 and 11 a very close second; same with 7 and 1.
5 and 7 a close runner up, too.

So 7, 11, 1, and 5 txn similar.

7 and 11 also spatially similar,

**But 3 and spatially similar (to 1) but txn different from 1,11,7,5: interacting cell types?**

Spatially and txn 7 and 11 similar

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

In terms of the most positive difference
(More positive = co-localized but transcriptionally different)
foo = scale0_1(pcor) - scale0_1(tcor)


we have 9 and 6, perhaps another set of txn different but spatially close cell types?


```{r}

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

In terms of the most negative difference
(More negative = transcriptionally similar but different spatial locations)
foo = scale0_1(pcor) - scale0_1(tcor)

we have 7, 1, 11 popping up again.

Recall that 7 and 11 were spatially and txn similar.
7 and 1 were txn similar, but did not correlate strongly wrt to space.

So same cell type in different locations?


# Viz hits

for each topic combo check out for all slices

and then the genes from the betas


3 and 1 spatially similar but txn different

```{r}

m <- bcl_k12$theta[,c("1","3")]
p <- bclCorpus$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("white", "white", "white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bcl_k12$beta[1,], decreasing = TRUE)[1:5]
sort(bcl_k12$beta[3,], decreasing = TRUE)[1:5]

```


7 and 1 txn similar but spatially different

```{r}

m <- bcl_k12$theta[,c("1","7")]
p <- bclCorpus$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("white", "white", "white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bcl_k12$beta[1,], decreasing = TRUE)[1:5]
sort(bcl_k12$beta[7,], decreasing = TRUE)[1:5]

```

Spatially and txn 7 and 11 similar

```{r}

m <- bcl_k12$theta[,c("7","11")]
p <- bclCorpus$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("white", "white", "white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bcl_k12$beta[7,], decreasing = TRUE)[1:5]
sort(bcl_k12$beta[11,], decreasing = TRUE)[1:5]

```

9 and 6, perhaps another set of txn different but spatially close cell types?

```{r}

m <- bcl_k12$theta[,c("6","9")]
p <- bclCorpus$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = sliceTxnClusters,
               group_cols = c("white", "white", "white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bcl_k12$beta[6,], decreasing = TRUE)[1:5]
sort(bcl_k12$beta[9,], decreasing = TRUE)[1:5]

```

GSEA may help

and other BCL datasets. Clearer pathology perhaps


# GSEA for betas:

```{r}

for (i in seq(12)){
  
  m <- bcl_k12$theta[,i]
  p <- bclCorpus$pos[,]
  sliceTxnClusters <- bcl_com[]
  
  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")
  
  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))
  
  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))
  
  p <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  # ggsave(filename = paste0("bcl-layers-topic-", i, ".pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
  print(p)
  
}

```

```{r}

for (i in seq(4)){
  
  m <- bcl_k4$theta[,i]
  p <- bclCorpus$pos[,]
  sliceTxnClusters <- bcl_com[]
  
  other <- 1 - m
  m <- cbind(m, other)
  colnames(m) <- c(as.character(i), "other")
  
  cc <- c(
    transparentCol("black", percent = 30),
    # transparentCol("blue", percent = 50),
    transparentCol("white", percent = 100))
  
  group_cc <- c("1" = transparentCol("red", percent = 30),
                "2" = transparentCol("green", percent = 30),
                "3" = transparentCol("blue", percent = 30))
  
  p <- vizAllTopics(theta = m,
                 pos = p,
                 topicOrder=seq(ncol(m)),
                 topicCols=cc,
                 groups = sliceTxnClusters,
                 group_cols = group_cc,
                 r = 0.4,
                 lwd = 0.1,
                 showLegend = TRUE,
                 plotTitle = NA)
  # ggsave(filename = paste0("bcl-layers-topic-", i, ".pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
  print(p)
  
}

```

## GO terms

```{r}

library(liger)
data(org.Hs.GO2Symbol.list) ## load built in GO gene sets

# list of GO terms and associated genes
go.env <- org.Hs.GO2Symbol.list

library(GO.db)
library(AnnotationDbi)

# annotate the GO terms
# dataframe of GO ID and the associated term annotation
desc <- AnnotationDbi::select(
  GO.db,
  keys = names(go.env),
  columns = c("TERM"),
  multiVals = 'CharacterList'
)

# append GO term list names with their annotations
names(go.env) <- paste(names(go.env), desc$TERM)

```

```{r}

gset <- go.env
for (i in seq(12)){
  
  vals <- sort(bcl_k12$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # GO annotations
# gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=go.env, rank=TRUE)
# head(gsea.results.go[order(gsea.results.go$p.val),], n = 30)
# 
# # filter for significant results
# gsea.sig.up.go <- gsea.results.go[gsea.results.go$q.val < 0.1 & gsea.results.go$sscore > 0 & gsea.results.go$edge > 0,]
# head(gsea.sig.up.go[order(gsea.sig.up.go$p.val),], n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.go)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

gset <- go.env
for (i in seq(4)){
  
  vals <- sort(bcl_k4$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # GO annotations
# gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=go.env, rank=TRUE)
# head(gsea.results.go[order(gsea.results.go$p.val),], n = 30)
# 
# # filter for significant results
# gsea.sig.up.go <- gsea.results.go[gsea.results.go$q.val < 0.1 & gsea.results.go$sscore > 0 & gsea.results.go$edge > 0,]
# head(gsea.sig.up.go[order(gsea.sig.up.go$p.val),], n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.go)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# get he GO ID and index of a GO ID term of interest
desc[grepl('GO:0006955', desc$GOID),]

```

```{r}

# use the index of the GO ID/term to pull out the genes and then plot the combined gene counts
# for the given GO ID term ossociated genes
i <- 2896
# fibrinogen complex

# get genes in gene count mat corresponding to the GO term
mat <- bcl_countsClean[intersect(go.env[[i]], rownames(bcl_countsClean)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

plotEmbedding(emb, col=gexp, main=names(go.env)[i])
plotEmbedding(bclCorpus$pos, col=gexp)

```

## C8 cts

```{r}

library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C8") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C8_gsea_ct_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C8_gsea_ct_gene_list) <- unique(gene_set$gs_name)

```

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(30)){
  
  vals <- sort(bcl_k30$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C8 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C8, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C8)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

gset <- C8_gsea_ct_gene_list
for (i in seq(4)){
  
  vals <- sort(bcl_k4$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C8 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C8, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C8)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "LAKE_ADULT_KIDNEY_C6_PROXIMAL_TUBULE_EPITHELIAL_CELLS_FIBRINOGEN_POS_S3"

# get genes in gene count mat corresponding to the GO term
mat <- bcl_countsClean[intersect(C8_gsea_ct_gene_list[[i]], rownames(bcl_countsClean)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclCorpus$pos, col=gexp)

```

## C6 oncogenic signatures

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C6") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C6_gsea_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C6_gsea_gene_list) <- unique(gene_set$gs_name)

```

```{r}

gset <- C6_gsea_gene_list
for (i in seq(12)){
  
  vals <- sort(bcl_k12$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[6,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C6_gsea_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C6 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C6, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C6)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "WNT_UP.V1_DN"

# get genes in gene count mat corresponding to the GO term
mat <- bcl_countsClean[intersect(C6_gsea_gene_list[[i]], rownames(bcl_countsClean)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclCorpus$pos, col=gexp)

```

## C7 immuno

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C7") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C7_gsea_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C7_gsea_gene_list) <- unique(gene_set$gs_name)

```

```{r}

gset <- C7_gsea_gene_list
for (i in seq(12)){
  
  vals <- sort(bcl_k12$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[6,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C7_gsea_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C7 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C7, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C6)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "WNT_UP.V1_DN"

# get genes in gene count mat corresponding to the GO term
mat <- bcl_countsClean[intersect(C7_gsea_gene_list[[i]], rownames(bcl_countsClean)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclCorpus$pos, col=gexp)

```

## C2 KEGG

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C2") %>%
                dplyr::filter(gs_subcat == "CP:KEGG") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C2_gsea_kegg_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C2_gsea_kegg_gene_list) <- unique(gene_set$gs_name)

```

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(4)){
  
  vals <- sort(bcl_k4$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C8 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C8, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C8)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

gset <- C2_gsea_kegg_gene_list
for (i in seq(12)){
  
  vals <- sort(bcl_k12$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bcl_k12$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C8 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C8, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C8)[top]]], plot=TRUE, rank=TRUE)

```

# -----------------------------------
# HER2 ST data

https://github.com/almaan/her2st

Pathologist labels

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/her2st-master/data/ST-pat/lbl/"

# files are A1, B1, ... , G2, H1, J1
section_id <- c(paste0(LETTERS[1:6], 1), "G2", "H1", "J1")
pat_labels <- unlist(lapply(section_id, function(i){
  d <- read.table(paste0(path, i, "_labeled_coordinates.tsv"), header = TRUE, sep = "\t")
  x <- round(d$x)
  y <- round(d$y)
  rows <- paste0(x, "x", y, "_", i)
  
  vals <- d$label
  names(vals) <- rows
  vals
}))

```

# A

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/her2st-master/data/ST-cnts/"

bcl_A_paths <- list()
bcl_A_paths[["A1"]] <- paste0(path, "A1.tsv.gz")
bcl_A_paths[["A2"]] <- paste0(path, "A2.tsv.gz")
bcl_A_paths[["A3"]] <- paste0(path, "A3.tsv.gz")
bcl_A_paths[["A4"]] <- paste0(path, "A4.tsv.gz")
bcl_A_paths[["A5"]] <- paste0(path, "A5.tsv.gz")
bcl_A_paths[["A6"]] <- paste0(path, "A6.tsv.gz")

```

It turns out that using the intersection of OD genes across all 6 sections results in a small number of genes. Being very lenient with the alpha, such as using alpha = 0.5, only returns about 80 OD genes. SO maybe this is finding a conserved gene signature and not necessarily signatures that are capturing more nuanced transcriptional variation. Doing this, it really results in 3 categories the topics fall into:
Immune signature
Invasive carcinoma
In situ carcinoma

Increasing topics just keeps grouping them into in situ carcinoma and captures more variation in this group. Then only one topic really captures the "immune infiltrate" and one other captures the "invasive" based on the pathologist labels. Finer scale immune cells aren't really being seen at least for patient A.

So instead make the corpus inclusive of all OD genes from each section for a given patient. It will include the common conservative set of OD genes and other ones more specific to each section.

```{r}

# find shared set of OD genes across sections to try and identify common transcriptional patterns

# lets also make sure we are using genes that are present across all slices
all_genes <- lapply(bcl_A_paths, function(p){
  counts <- read.table(p)
  genes <- colnames(counts)
  genes
})
all_genes <- Reduce(intersect, all_genes)
length(all_genes)

bclA_genes <- lapply(bcl_A_paths, function(p) {
  print(p)
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = TRUE,
                   selected.genes = all_genes,
                   nTopGenes = 5,
                   genes.to.remove = NA,
                   perc.spots = 0.95,
                   min.reads = 10,
                   min.lib.size = 10,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.01, # use a smaller alpha to use the union of the top OD genes in each section
                   gam.k = 5)
  colnames(dat$corpus)
})

# because very few genes are OD across all sections, instead take the union and consider genes
# that are OD in any slice
common_bclA_genes <- Reduce(union, bclA_genes)
length(common_bclA_genes)

```

```{r}

bclAcorpus <- lapply(bcl_A_paths, function(p) {
  print(p)
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = TRUE,
                   selected.genes = common_bclA_genes,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = -1, # -1 b/c if 0 then still only keep genes > 0 reads (at least 1)
                   min.lib.size = 10,
                   min.detected = -1, # -1 b/c if 0 then still only keep genes present in > 0 spots (at least 1)
                   ODgenes = FALSE,
                   od.genes.alpha = 0.05, # ODgenes ignored; so is this
                   gam.k = 5) # ODgenes ignored; so is this
  dat
})

names(bclAcorpus) <- paste0("A", seq(6))

# note that some sections after `cleanCounts` still don't have a gene present in any spots that may have been
# present and counted as an OD gene in another section. So set `min.reads` and `min.detected` to 0 here to keep
# all genes in the set of OD genes but still remove bad spots.

```

combine into single corpus

```{r}

bclA_full_mat <- do.call(rbind, lapply(paste0("A", seq(6)), function(i){
  m <- bclAcorpus[[i]]$corpus
  # there are duplicate row names between the sections so make unique
  rownames(m) <- paste0(rownames(m), "_", i)
  m
}))

bclA_full_pos <- do.call(rbind, lapply(paste0("A", seq(6)), function(i){
  m <- bclAcorpus[[i]]$pos
  # there are duplicate row names between the sections so make unique
  rownames(m) <- paste0(rownames(m), "_", i)
  m
}))

# index of which slice a spot belongs to
bclA_slices <- unlist(lapply(paste0("A", seq(6)), function(i){
  n <- paste0(rownames(bclAcorpus[[i]]$corpus), "_", i)
  vals <- rep(i, length(n))
  names(vals) <- n
  vals
}))

bclA <- list()
bclA$corpus <- bclA_full_mat
bclA$pos <- bclA_full_pos
bclA$slm <- slam::as.simple_triplet_matrix(bclA_full_mat)
bclA$slice <- bclA_slices

print(bclA$slm)

```

# gexp

```{r}

bclA_counts <- do.call(rbind, lapply(names(bcl_A_paths), function(i){
  counts <- read.table(bcl_A_paths[[i]])
  counts <- counts[, all_genes]
  rownames(counts) <- paste0(rownames(counts), "_", i)
  counts
}))
dim(bclA_counts)

# clean
bclA_countsClean <- MERINGUE::cleanCounts(counts = t(bclA_counts), # genes x spots mtx
                                        min.reads = 10,
                                        min.lib.size = 10,
                                        verbose=TRUE)

# keep same spots that are in `bclA$pos`
bclA_countsClean <- bclA_countsClean[, rownames(bclA$pos)]

bclA_CPM <- MERINGUE::normalizeCounts(counts = bclA_countsClean,
                                          verbose=TRUE, log=FALSE)

```

From paper but made using stereoscope

# major class proportions

8

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/her2st-master/res/ST-deconv/props/major/"

bclA_gtTheta <- do.call(rbind, lapply(paste0("A", seq(6)), function(i){
  gt <- read.table(paste0(path, i, "-proportion.tsv"), header = TRUE, sep = "\t", row.names = 1)
  rows <- rownames(bclAcorpus[[i]]$pos)
  gt <- gt[rows,]
  rownames(gt) <- paste0(rows, "_", i)
  gt
}))

bclA$gtThetaMjr <- bclA_gtTheta

```

# minor class proportions

22

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/her2st-master/res/ST-deconv/props/minor/"

bclA_gtTheta <- do.call(rbind, lapply(paste0("A", seq(6)), function(i){
  gt <- read.table(paste0(path, i, "-proportion.tsv"), header = TRUE, sep = "\t", row.names = 1)
  rows <- rownames(bclAcorpus[[i]]$pos)
  gt <- gt[rows,]
  rownames(gt) <- paste0(rows, "_", i)
  gt
}))

bclA$gtThetaMinor <- bclA_gtTheta

```

# LDA

```{r}

# note that there are 8 major cell classes used from the paper.
# 6 distinct pathological annotated categories

ks <- seq(from = 2, to = 22, by = 2)

bclA_LDAs <- fitLDA(counts = bclA$slm,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)

```

# k=8

```{r}

bclA_k8 <- buildLDAobject(LDAmodel = optimalModel(bclA_LDAs, opt = 8),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

```{r}

m <- bclA_k8$theta
p <- bclA$pos

cc <- as.factor(rainbow(ncol(m)))
# cc <- as.factor(rep("black", 12))
names(cc) <- colnames(m)

# for (i in colnames(m)){
#   cc <- as.factor(rep("black", 1))
#   names(cc) <- i
#   vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = sliceTxnClusters,
#                  group_cols = txnCols,
#                  r = 0.4,
#                  lwd = 0.3,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(1)))
# }

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = bclA$slice,
                 group_cols = rep("white", 6),
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## vs pathology

Section A1 topics with pathology labels

```{r}

slice <- bclA$slice[bclA$slice == "A1"]
pathology <- pat_labels[names(slice)]

m <- bclA_k8$theta[names(slice), ]
p <- bclA$pos[names(slice), ]

# cc <- as.factor(rainbow(ncol(m)))
# cc <- as.factor(rep("black", 8))
# names(cc) <- colnames(m)

for (i in colnames(m)){
  cc <- as.factor(rep("black", 1))
  names(cc) <- i
  vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = pathology,
                 group_cols = rainbow(6),
                 r = 0.4,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = "Slice A1")
}

# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = pathology,
#                  group_cols = rainbow(6),
#                  r = 0.4,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = NA)

```

```{r}

for (i in seq(8)){
  print(sort(bclA_k8$beta[i,], decreasing = TRUE)[1:5])
}

```

Correlation with pathology labels

```{r}

pathology_A1_gt <- model.matrix(~ 0 + as.factor(pathology))
colnames(pathology_A1_gt) <- levels(as.factor(pathology))
rownames(pathology_A1_gt) <- names(pathology)

```

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(pathology_A1_gt),
                     m2 = bclA_k8$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,6))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,6))
# dev.off()

# correlations along diagonal (after assigning best matches)
diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])

# hist(lda_vs_sl_theta, breaks = 10)
mean(diag_corrs)
sd(diag_corrs)

```

## vs major cell class

```{r}

corMtx <- getCorrMtx(m1 = bclA_k8$theta,
                     m2 = as.matrix(bclA$gtThetaMjr),
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])

# hist(lda_vs_sl_theta, breaks = 10)
mean(diag_corrs)
sd(diag_corrs)

```

## topic co-localization

```{r}


# correlation wrt theta positional proportions
pcor <- do.call(rbind, lapply(1:8, function(i) {
  p1 <- bclA_k8$theta[,i]
  unlist(lapply(1:8, function(j) {
    p2 <- bclA_k8$theta[,j]
    cor(p1, p2)
  }))
}))
diag(pcor) <- NA
heatmap(pcor, col=correlation_palette)
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)


# correlation wrt beta values
tcor <- do.call(rbind, lapply(1:8, function(i) {
  p1 <- bclA_k8$beta[i,]
  unlist(lapply(1:8, function(j) {
    p2 <- bclA_k8$beta[j,]
    cor(p1, p2)
  }))
}))
diag(tcor) <- NA
heatmap(tcor, col=correlation_palette, scale='none')
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)


# difference between topic theta and beta correlations.
# More positive = co-localized but transcriptionally different
# More negative = transcriptionally similar but different spatial locations

# note: the two different correlations are in different scales, so normalize the scales
range(pcor, na.rm = TRUE)
max(range(pcor, na.rm = TRUE)) - min(range(pcor, na.rm = TRUE))

range(tcor, na.rm = TRUE)
max(range(tcor, na.rm = TRUE)) - min(range(tcor, na.rm = TRUE))

foo <- scale0_1(pcor) - scale0_1(tcor)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none', )
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

```{r}

# top pcors:
sort(pcor, decreasing = TRUE)[1:10]
# the pairs:
which(pcor >= sort(pcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)

```

Topics 4, 6, 2 co-localized. 8 also colocalized, closest to 6

7 and 1 close in space.
5 and 1 close in space.

```{r}

# top tcor:
sort(tcor, decreasing = TRUE)[1:10]
# the pairs:
which(tcor >= sort(tcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)

```

Topics 6, 2, 8 transcriptionally similar

5 and 3 txn close

5 and 1 txn distant
7 and 1 and 3 txn distant
7 and 5 slightly txn close

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

In terms of the most positive difference
(More positive = co-localized but transcriptionally different)
foo = scale0_1(pcor) - scale0_1(tcor)

5 and 1
3 and 1 both potential candidates that are in same space but txn different. Interacting cell types?

```{r}

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

5 and 3 txn similar but more distant in space
5 and 7 txn similar but more distant in space. potentially similar cell type but in different locations?

## viz hits

5 and 1 spatially similar but txn different

```{r}

m <- bclA_k8$theta[,c("1","5")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k8$beta[1,], decreasing = TRUE)[1:5]
sort(bclA_k8$beta[5,], decreasing = TRUE)[1:5]

```

3 and 1 spatially similar but txn different

```{r}

m <- bclA_k8$theta[,c("1","3")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k8$beta[1,], decreasing = TRUE)[1:5]
sort(bclA_k8$beta[3,], decreasing = TRUE)[1:5]

```

5 and 3 txn similar but spacially different

```{r}

m <- bclA_k8$theta[,c("3","5")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k8$beta[3,], decreasing = TRUE)[1:5]
sort(bclA_k8$beta[5,], decreasing = TRUE)[1:5]

```

5 and 7 txn similar but spacially different

```{r}

m <- bclA_k8$theta[,c("7","5")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k8$beta[5,], decreasing = TRUE)[1:5]
sort(bclA_k8$beta[7,], decreasing = TRUE)[1:5]

```

## GSEA

## GO terms

```{r}

library(liger)
data(org.Hs.GO2Symbol.list) ## load built in GO gene sets

# list of GO terms and associated genes
go.env <- org.Hs.GO2Symbol.list

library(GO.db)
library(AnnotationDbi)

# annotate the GO terms
# dataframe of GO ID and the associated term annotation
desc <- AnnotationDbi::select(
  GO.db,
  keys = names(go.env),
  columns = c("TERM"),
  multiVals = 'CharacterList'
)

# append GO term list names with their annotations
names(go.env) <- paste(names(go.env), desc$TERM)

```

```{r}

# note that each topic beta is 564 genes

gset <- go.env
for (i in seq(8)){
  
  vals <- sort(bclA_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results <- iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  print(head(gsea.results[order(gsea.results$p.val),], n = 30))
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.05,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  print(dim(gsea.sig))
  print(head(gsea.sig, n = 10))
  
  # visualize the top 5
  for (j in seq(5)){
    gsea(values=vals, geneset=gset[[rownames(gsea.sig)[j]]], plot=TRUE, rank=TRUE, main = paste("topic", i, rownames(gsea.sig)[j]))
  }
}

# # genes and beta values for a topic
# vals <- sort(bclA_k8$beta[5,], decreasing=TRUE)
# head(vals)
# 
# # GO annotations
# gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=go.env, rank=TRUE)
# head(gsea.results.go[order(gsea.results.go$p.val),], n = 30)
# 
# # filter for significant results
# gsea.sig.up.go <- gsea.results.go[gsea.results.go$q.val < 0.1 & gsea.results.go$sscore > 0 & gsea.results.go$edge > 0,]
# head(gsea.sig.up.go[order(gsea.sig.up.go$p.val),], n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.go)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# get he GO ID and index of a GO ID term of interest
desc[grepl('angiogenesis', desc$TERM),]

```

```{r}

# use the index of the GO ID/term to pull out the genes and then plot the combined gene counts
# for the given GO ID term ossociated genes
i <- 380

# get genes in gene count mat corresponding to the GO term
mat <- bclA_CPM[intersect(go.env[[i]], rownames(bclA_CPM)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]



# plotEmbedding(emb, col=gexp, main=names(go.env)[i])
plotEmbedding(bclA$pos, col=gexp, cex = 1.5)

```

## C8 cts

```{r}

library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C8") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C8_gsea_ct_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C8_gsea_ct_gene_list) <- unique(gene_set$gs_name)

```

```{r}

for (i in seq(8)){
  
  vals <- sort(bclA_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
  print(head(gsea.results.go[order(gsea.results.go$p.val),], n = 30))
  
}

# # genes and beta values for a topic
# vals <- sort(bclA_k8$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C8_gsea_ct_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C8 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C8, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C8)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "AIZARANI_LIVER_C24_EPCAM_POS_BILE_DUCT_CELLS_3"

# get genes in gene count mat corresponding to the GO term
mat <- bclA_CPM[intersect(C8_gsea_ct_gene_list[[i]], rownames(bclA_CPM)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

# plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclA$pos, col=gexp, cex = 1.5)

```

## C6 oncogenic

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C6") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C6_gsea_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C6_gsea_gene_list) <- unique(gene_set$gs_name)

```

```{r}

for (i in seq(8)){
  
  vals <- sort(bclA_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=C6_gsea_gene_list, rank=TRUE)
  print(head(gsea.results.go[order(gsea.results.go$p.val),], n = 30))
  
}

# # genes and beta values for a topic
# vals <- sort(bclA_k8$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C6_gsea_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C6 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C6, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C6)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "KRAS.600.LUNG.BREAST_UP.V1_DN"

# get genes in gene count mat corresponding to the GO term
mat <- bclA_CPM[intersect(C6_gsea_gene_list[[i]], rownames(bclA_CPM)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

# plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclA$pos, col=gexp, cex = 1.5)

```

```{r}

# genes and beta values for a topic
vals <- sort(bclA_k8$beta[8,], decreasing=TRUE)
head(vals)

# C8 Cell type signature annotations
gsea.results <- iterative.bulk.gsea(values=vals, set.list=C6_gsea_gene_list, rank=TRUE)
head(gsea.results[order(gsea.results$p.val),], n = 30)

# significant cell type signatures
gsea.sig.up.C6 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
head(gsea.sig.up.C6, n = 30)

# viz significant hits
# top <- 1
# gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C6)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "STK33_NOMO_UP"

# get genes in gene count mat corresponding to the GO term
mat <- bclA_CPM[intersect(C6_gsea_gene_list[[i]], rownames(bclA_CPM)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

# plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclA$pos, col=gexp, cex = 1.5)

```

## C7 immuno

```{r}

# library(msigdbr)

# create the term - gene list for GSEA C8 Cell type signature gene sets

# all_gene_sets <- msigdbr(species = "Homo sapiens")

gene_set <- all_gene_sets %>%
                dplyr::filter(gs_cat == "C7") %>%
                as.data.frame()

# `gs_name` are the cell type labels and the associated genes are the `gene_symbol`
C7_gsea_gene_list <- lapply(unique(gene_set$gs_name), function(ct){
  genes <- gene_set[gene_set$gs_name == ct,]$gene_symbol
  genes
})
names(C7_gsea_gene_list) <- unique(gene_set$gs_name)

```

```{r}

for (i in seq(8)){
  
  vals <- sort(bclA_k8$beta[i,], decreasing=TRUE)
  print(head(vals))
  gsea.results.go <- iterative.bulk.gsea(values=vals, set.list=C7_gsea_gene_list, rank=TRUE)
  print(head(gsea.results.go[order(gsea.results.go$p.val),], n = 30))
  
}

# # genes and beta values for a topic
# vals <- sort(bclA_k8$beta[1,], decreasing=TRUE)
# head(vals)
# 
# # C8 Cell type signature annotations
# gsea.results <- iterative.bulk.gsea(values=vals, set.list=C7_gsea_gene_list, rank=TRUE)
# head(gsea.results[order(gsea.results$p.val),], n = 30)
# 
# # significant cell type signatures
# gsea.sig.up.C7 <- gsea.results[gsea.results$q.val < 0.1 & gsea.results$sscore > 0 & gsea.results$edge > 0,]
# head(gsea.sig.up.C7, n = 30)
# 
# # viz significant hits
# # top <- 1
# # gsea(values=vals, geneset=go.env[[rownames(gsea.sig.up.C6)[top]]], plot=TRUE, rank=TRUE)

```

```{r}

# use the index of the C8 ct ID/term to pull out the genes and then plot the combined gene counts
# for the given C8 ct ID term ossociated genes
i <- "GSE22886_IGG_IGA_MEMORY_BCELL_VS_BM_PLASMA_CELL_DN"

# get genes in gene count mat corresponding to the GO term
mat <- bclA_CPM[intersect(C7_gsea_gene_list[[i]], rownames(bclA_CPM)),]

# add up counts of all the associated genes for each spot. Scale values
gexp <- scale(colSums(mat))[,1]

# plotEmbedding(emb, col=gexp, main=i)
plotEmbedding(bclA$pos, col=gexp, cex = 1.5)

```

# k=22

```{r}

bclA_k22 <- buildLDAobject(LDAmodel = optimalModel(bclA_LDAs, opt = 22),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

```{r}

m <- bclA_k22$theta
p <- bclA$pos

cc <- as.factor(rainbow(ncol(m)))
# cc <- as.factor(rep("black", 12))
names(cc) <- colnames(m)

# for (i in colnames(m)){
#   cc <- as.factor(rep("black", 1))
#   names(cc) <- i
#   vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = sliceTxnClusters,
#                  group_cols = txnCols,
#                  r = 0.4,
#                  lwd = 0.3,
#                  showLegend = TRUE,
#                  plotTitle = paste("Slice", as.character(1)))
# }

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = bclA$slice,
                 group_cols = rep("white", 6),
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## vs pathology

Section A1 topics with pathology labels

```{r}

slice <- bclA$slice[bclA$slice == "A1"]
pathology <- pat_labels[names(slice)]

m <- bclA_k22$theta[names(slice), ]
p <- bclA$pos[names(slice), ]

# cc <- as.factor(rainbow(ncol(m)))
# cc <- as.factor(rep("black", 8))
# names(cc) <- colnames(m)

for (i in colnames(m)){
  cc <- as.factor(rep("black", 1))
  names(cc) <- i
  vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = pathology,
                 group_cols = rainbow(6),
                 r = 0.4,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = "Slice A1")
}

# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = pathology,
#                  group_cols = rainbow(6),
#                  r = 0.4,
#                  lwd = 0.01,
#                  showLegend = TRUE,
#                  plotTitle = NA)

```

Correlation with pathology labels

```{r}

pathology_A1_gt <- model.matrix(~ 0 + as.factor(pathology))
colnames(pathology_A1_gt) <- levels(as.factor(pathology))
rownames(pathology_A1_gt) <- names(pathology)

```

```{r}

corMtx <- getCorrMtx(m1 = as.matrix(pathology_A1_gt),
                     m2 = bclA_k22$theta,
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,6))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,6))
# dev.off()

# correlations along diagonal (after assigning best matches)
diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])

# hist(lda_vs_sl_theta, breaks = 10)
mean(diag_corrs)
sd(diag_corrs)

```

## vs minor cell class

```{r}

corMtx <- getCorrMtx(m1 = bclA_k22$theta,
                     m2 = as.matrix(bclA$gtThetaMinor),
                     type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(6,6))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.6,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(6,6))
# dev.off()

# correlations along diagonal (after assigning best matches)
diag_corrs <- diag(corMtx[pairs$rowix, pairs$colsix])

# hist(lda_vs_sl_theta, breaks = 10)
mean(diag_corrs)
sd(diag_corrs)

```

## topic co-localization

```{r}


# correlation wrt theta positional proportions
pcor <- do.call(rbind, lapply(1:22, function(i) {
  p1 <- bclA_k22$theta[,i]
  unlist(lapply(1:22, function(j) {
    p2 <- bclA_k22$theta[,j]
    cor(p1, p2)
  }))
}))
diag(pcor) <- NA
heatmap(pcor, col=correlation_palette)
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)


# correlation wrt beta values
tcor <- do.call(rbind, lapply(1:22, function(i) {
  p1 <- bclA_k22$beta[i,]
  unlist(lapply(1:22, function(j) {
    p2 <- bclA_k22$beta[j,]
    cor(p1, p2)
  }))
}))
diag(tcor) <- NA
heatmap(tcor, col=correlation_palette, scale='none')
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)


# difference between topic theta and beta correlations.
# More positive = co-localized but transcriptionally different
# More negative = transcriptionally similar but different spatial locations

# note: the two different correlations are in different scales, so normalize the scales
range(pcor, na.rm = TRUE)
max(range(pcor, na.rm = TRUE)) - min(range(pcor, na.rm = TRUE))

range(tcor, na.rm = TRUE)
max(range(tcor, na.rm = TRUE)) - min(range(tcor, na.rm = TRUE))

foo <- scale0_1(pcor) - scale0_1(tcor)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none', )
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

```{r}

# top pcors:
sort(pcor, decreasing = TRUE)[1:10]
# the pairs:
which(pcor >= sort(pcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(pcor == max(pcor, na.rm=TRUE), arr.ind=TRUE)

```

18 and 7
20 and 7

14 and 21


```{r}

# top tcor:
sort(tcor, decreasing = TRUE)[1:10]
# the pairs:
which(tcor >= sort(tcor, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(tcor == max(tcor, na.rm=TRUE), arr.ind=TRUE)

```

10 and 8
7 and 16

```{r}

# note that foo was difference between 0-1 scaled pcor and tcor

# top foo:
sort(foo, decreasing = TRUE)[1:10]
# the pairs:
which(foo >= sort(foo, decreasing = TRUE)[8], arr.ind = T)
# top pair:
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```

In terms of the most positive difference
(More positive = co-localized but transcriptionally different)
foo = scale0_1(pcor) - scale0_1(tcor)

7 and 6
8 and 6 spatially similar, txn different

```{r}

# min foo:
sort(foo, decreasing = FALSE)[1:10]
# the pairs:
which(foo <= sort(foo, decreasing = FALSE)[8], arr.ind = T)
# top pair:
which(foo == min(foo, na.rm=TRUE), arr.ind=TRUE)

```

10 and 8 txn similar but diff locations

## viz hits

```{r}

m <- bclA_k22$theta[,c("7","6")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k22$beta[7,], decreasing = TRUE)[1:5]
sort(bclA_k22$beta[6,], decreasing = TRUE)[1:5]

```

```{r}

m <- bclA_k22$theta[,c("8","6")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k22$beta[8,], decreasing = TRUE)[1:5]
sort(bclA_k22$beta[6,], decreasing = TRUE)[1:5]

```

```{r}

m <- bclA_k22$theta[,c("10","8")]
p <- bclA$pos[,]
sliceTxnClusters <- bcl_com[]

other <- 1 - rowSums(m)
m <- cbind(m, other)

cc <- c(
  transparentCol("red", percent = 50),
  transparentCol("blue", percent = 50),
  transparentCol("white", percent = 100))

vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=cc,
               groups = rep(1, nrow(m)),
               group_cols = c("white"),
               r = 0.4,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)

```

```{r}

sort(bclA_k22$beta[10,], decreasing = TRUE)[1:5]
sort(bclA_k22$beta[8,], decreasing = TRUE)[1:5]

```




