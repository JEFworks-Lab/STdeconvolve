---
title: "Untitled"
author: "Brendan F. Miller"
date: "3/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

# all of the trained models for merfish:
# save(bregmaCellsGexpFN7, # 59651 cells in FN7 bregmas x 125 gene counts (blanks removed and ambiguous cells removed)
#       bregmaCellsGexpFN7_filt, # above but only cells kept in simulated patches (49142)
#       gtCtGenesFN7, # reference for 8 major cell types and 125 genes. relative average expression. Used all 59651 cells
#       gtCtNeuronalGenesFN7, # same as above but expanded into neuronal cts so 75 types
#       FN7, # hash table storing each simulated bregma in FN7. Built such that cellTypeTable is for 8 major cts
#       FN7_neuro, # same as above but with all cts
#       bregmaFN7FullSeur, # seurat object of the 49142 cells in patches. Meta data has all major and neuronal cts
#       bregmaFN7FullSeur_noNeuro, # 21652 non-neuronal cells also in patches
#       simBregmasFN7, # list of bregma corpuses and gt for each bregma in FN7
#       simBregmasFN7_neuro, # list of bregma corpuses and gt for each bregma in FN7_neuro
#       simFN7, # same as `simBregmasFN7` but all combined into single "bregma" corpus
#       simFN7_neuro, # same as `simBregmasFN7_neuro` but all combined into single "bregma" corpus. sim in both simFN7 and simFN7_neuro the same
#       FN7_K8, # LDA model K=8 and trained on simFN7 (entire FN7 animal)
#       FN7_K75, # LDA model K=75 and trained on simFN7 (entire FN7 animal)
#       bregmaFN7FullSeur_markers8cts, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur
#       bregmaFN7FullSeur_markers75neurocts, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur using all classes
#       bregmaFN7FullSeur_noNeuro_markers, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur_noNeuro 6 major cts
#       SL_bregmaFN7FullSeur8cts_fit, # SL deconvolve model using full `FN7`, `bregmaCellsGexpFN7`, and 8 major ct markers
#       SL_bregmaFN7FullSeur75neurocts_fit, # SL deconvolve model using full `simFN7_neuro`, `bregmaCellsGexpFN7`, and 75 major ct markers
#       RCTD_FN7_results_norm, # 3070 spots and 8 cts deconvolved with RCTD using bregmaCellsGexpFN7 ref with major classes
#       RCTD_FN7_neuro_results_norm, # 3070 spots and 73 cts deconvolved with RCTD using bregmaCellsGexpFN7 ref with All classes
#       SL_bregmaFN7FullSeur_noNeuro_fit, # SL deconvolve using `bregmaFN7FullSeur_noNeuro` (21652 cells) and noNeuro markers for 6 cts
#       RCTD_FN7_noNeuro_results_norm, # 3070 spots and 6 cts deconvovled with RCTD using `bregmaFN7FullSeur_noNeuro` 
#       file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/merfish_fitted_models.RData")

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/merfish_fitted_models.RData")

```

```{r}

fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/figures/merfish/"
draft_fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_figures/"

```

# Data and gexp references

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mpoa_merfish_clean2.RData") # note that clean2 newest and 135 genes
# has `annot.table`, `counts`, and `features` objects

# annot.table: table of the individual cells and data like coordinates, cell types, bregma, animal
# features: has cells and additional features. Also dataset they belong to
# counts: gene counts of cell in annot.table for 130 merfish genes profiled

# unique(features$dataset_name)
#  [1] "170908_FN3_2_M22_M26"    "170917_MN1_1pp_M22_M26" 
#  [3] "170919_FN4_1_M22_M26"    "170921_FN4_2_M22_M26"   
#  [5] "170923_FN4_1pp_M22_M26"  "170925_MN2_1p_M22_M26"  
#  [7] "171021_FN7_2_M22_M26"    "171023_FN7_1_M22_M26"   
#  [9] "171024_MN5_2p_M22_M26"   "171027_MN5_1p_M22_M26"  
# [11] "171104_MN6_2_M22_M26"    "171112_MN8_2pppp"       
# [13] "171114_MN8_M22_M26_2pp"  "171208_MN9_2ppp_M22_M26"
# [15] "171118_BD3_1pp"          "171119_BD5_1pp"         
# [17] "171121_BD5_1"            "171123_BD5_2p"          
# [19] "171124_BD6_2ppp"         "171126_BD6_1pppp"       
# [21] "171128_BD7_1ppp"         "171129_BD7_1ppp_actual" 
# [23] "171201_BD_2ppp"          "171203_BD8_1pp"         
# [25] "171210_BD9_1pp"          "171211_BD9_2ppp_M22_M26"
# [27] "171214_BD10_2_M22_M26"   "171216_BD11_1_M22_M26"  
# [29] "171217_BD11_2_M22_M26"   "171219_BD12_1p_M22_M26" 
# [31] "171221_BD12_2p_M22_M26"  "171223_BD13_2p_M22_M26" 

```

```{r}
dim(counts)
dim(counts[,!grepl("Blank", colnames(counts))])
```


171021_FN7_2_M22_M26 (anterior) and 171023_FN7_1_M22_M26 (posterior)

generate `spatial_position_and_class_FN7` and `bregmaCellsGexpFN7`

```{r}

# select cells that are part of given data set:
selected_cells_FN7 <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26', "171023_FN7_1_M22_M26")]

spatial_position_and_class_FN7 <- annot.table[selected_cells_FN7,
                                          c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]

# remove rows with NA
spatial_position_and_class_FN7 <- na.omit(spatial_position_and_class_FN7) 

```

```{r}

# reduce set of major cell class labels. Convert OD types to "OD Mature" and "OD Immature" so will be 9 cts total
# "Endothelial types to "Endothelial"

# spatial_position_and_class_FN7[grep(pattern = "OD",
#                                 x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD"

spatial_position_and_class_FN7[grep(pattern = "OD Mature",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD Mature"

spatial_position_and_class_FN7[grep(pattern = "OD Immature",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD Immature"

spatial_position_and_class_FN7[grep(pattern = "Endothelial",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "Endothelial"

# Remove Ambiguous cell type:
spatial_position_and_class_FN7 <- spatial_position_and_class_FN7[which(!spatial_position_and_class_FN7$Cell_class == "Ambiguous"),]

dim(spatial_position_and_class_FN7)
# [1] 59651     5

# gene counts for individual cells
bregmaCellsGexpFN7 <- counts[rownames(spatial_position_and_class_FN7),]

# remove "Blanks" from data
bregmaCellsGexpFN7 <- bregmaCellsGexpFN7[,!grepl("Blank", colnames(bregmaCellsGexpFN7))]

```

```{r}

# to expand to neuronal subtypes, make a secondary vector of "Cell_class" where
# "Excititory and "Inhibitory" are replaces with the respective "Neuron_cluster_ID"

Cell_class_major_FN7 <- spatial_position_and_class_FN7$Cell_class

Cell_class_with_neuronal_FN7 <- unlist(lapply(rownames(spatial_position_and_class_FN7), function(cell){
  class <- spatial_position_and_class_FN7[cell,]$Cell_class
  neuron <- spatial_position_and_class_FN7[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

length(Cell_class_with_neuronal_FN7)

```

Gexp ground truths:

Let's make a gexp reference using all the cells across the bregmas.

cell types
```{r}

cellTypes <- spatial_position_and_class_FN7$Cell_class
cells <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtGenes <- gtCtGenes[,!grepl("Blank", colnames(gtCtGenes))]
gtCtGenesFN7 <- gtCtGenesFN7/rowSums(gtCtGenesFN7)

dim(gtCtGenesFN7)

```

cell neuronal subtypes
```{r}

cellTypes <- Cell_class_with_neuronal_FN7
cells <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtNeuronalGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtNeuronalGenes <- gtCtNeuronalGenes[,!grepl("Blank", colnames(gtCtNeuronalGenes))]
gtCtNeuronalGenesFN7 <- gtCtNeuronalGenesFN7/rowSums(gtCtNeuronalGenesFN7)

dim(gtCtNeuronalGenesFN7)

```

Next generate the simulated ST spots at different resolutions. Each simulation also record the ground truth pixel proprotions as well.

# Simulations

## 100um Sim

this generates the hash tables of simulated spots for each bregma separately
```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                counts = bregmaCellsGexpFN7,
                                patch_size = 100)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 100)

```

Tables of counts of cell-types in each spot for entire FN7 animal (100um2)

```{r}

# table of number of cell types in each spot for entire FN7

# spot IDs for all spots in FN7
FN7_spotIDs <- unlist(lapply(hash::keys(FN7_hash), function(ix){
  # table to df
  rownames(FN7_hash[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_cellTypeTable <- lapply(hash::keys(FN7_hash), function(ix){
  # table to df
  as.data.frame.matrix(FN7_hash[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_cellTypeTable <- data.table::rbindlist(FN7_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_cellTypeTable[is.na(FN7_cellTypeTable)] <- 0

# spot IDs as row names
FN7_cellTypeTable <- as.matrix(FN7_cellTypeTable)
rownames(FN7_cellTypeTable) <- FN7_spotIDs

```

Tables of counts of cell-types and neuronal cell-types in each spot for entire FN7 animal (100um2)

```{r}

# spot IDs
FN7_neuro_spotIDs <- unlist(lapply(hash::keys(FN7_neuro_hash), function(ix){
  # table to df
  rownames(FN7_neuro_hash[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_neuro_cellTypeTable <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  # table to df
  as.data.frame.matrix(FN7_neuro_hash[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_neuro_cellTypeTable <- data.table::rbindlist(FN7_neuro_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_neuro_cellTypeTable[is.na(FN7_neuro_cellTypeTable)] <- 0

# spot IDs as row names
FN7_neuro_cellTypeTable <- as.matrix(FN7_neuro_cellTypeTable)
rownames(FN7_neuro_cellTypeTable) <- FN7_neuro_spotIDs

```

Generation of each simulated corpus for each bregma:

```{r}

simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)

```

Recall that the `$gtSpotTopics` of each simulated corpus are of primary interest to compare the fitted models to for each bregma.

The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches and so should be ignored if looking at the entire animal.

Combine the simulated bregmas in the `simBregma` lists to make a single corpus for all bregmas to train a single model.
The `gtSpotTopics` can be combined as well for a ground truth reference, but each `gtCtGenes` is built using just the cells in each given bregma. So instead use the `gtCtGenesFN7` or `gtCtNeuronalGenesFN7`, which were average gexp for cell types across all cells.


Combine the simulated matrices for each bregma into one corpus:

Major cell types

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7 <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)

```

Neuronal subtypes

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```

### ---------------
### save simulations

Simulations generated for the following combos:
 clean_counts or clean_counts2: one ends up with 125 genes, and the other 135, which is actually more correct of the dataset
 and combining oligodendrocytes into single cell-type for 8 cell types and 75 subtypes
 or splitting into OD Mature and Immature for 9 cell types and 76 subtypes

```{r}

# simFN7_9ct_135genes <- simFN7
# simFN7_9ct_125genes <- simFN7
# simFN7_8ct_135genes <- simFN7
# simFN7_8ct_125genes <- simFN7
# simFN7_neuro_9ct_135genes <- simFN7_neuro
# simFN7_neuro_9ct_125genes <- simFN7_neuro
# simFN7_neuro_8ct_135genes <- simFN7_neuro
# simFN7_neuro_8ct_125genes <- simFN7_neuro

```

```{r}

print("135 genes and 9 cell-types")
simFN7_9ct_135genes$sim
dim(simFN7_9ct_135genes$gtSpotTopics)
dim(simFN7_9ct_135genes$gtCtGenes)
print(" ")
print("135 genes and 8 cell-types")
simFN7_8ct_135genes$sim
dim(simFN7_8ct_135genes$gtSpotTopics)
dim(simFN7_8ct_135genes$gtCtGenes)
print(" ")
print("125 genes and 9 cell-types")
simFN7_9ct_125genes$sim
dim(simFN7_9ct_125genes$gtSpotTopics)
dim(simFN7_9ct_125genes$gtCtGenes)
print(" ")
print("125 genes and 8 cell-types")
simFN7_8ct_125genes$sim
dim(simFN7_8ct_125genes$gtSpotTopics)
dim(simFN7_8ct_125genes$gtCtGenes)
print(" ")
print("Neuronal subtypes")
print(" ")
print("135 genes and 9 cell-types")
simFN7_neuro_9ct_135genes$sim
dim(simFN7_neuro_9ct_135genes$gtSpotTopics)
dim(simFN7_neuro_9ct_135genes$gtCtGenes)
print(" ")
print("135 genes and 8 cell-types")
simFN7_neuro_8ct_135genes$sim
dim(simFN7_neuro_8ct_135genes$gtSpotTopics)
dim(simFN7_neuro_8ct_135genes$gtCtGenes)
print(" ")
print("125 genes and 9 cell-types")
simFN7_neuro_9ct_125genes$sim
dim(simFN7_neuro_9ct_125genes$gtSpotTopics)
dim(simFN7_neuro_9ct_125genes$gtCtGenes)
print(" ")
print("125 genes and 8 cell-types")
simFN7_neuro_8ct_125genes$sim
dim(simFN7_neuro_8ct_125genes$gtSpotTopics)
dim(simFN7_neuro_8ct_125genes$gtCtGenes)
```

### seurat inputs

```{r}

## use filtered counts from `clean_counts`, which has the 135 genes and 59651 cells in the 12 bregmas after removing ambiguous cells
dim(bregmaCellsGexpFN7)

```

8 cell-ypes and 125 genes:
```{r}

simulation <- simFN7_8ct_125genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_8ct_125genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 8ct 125 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_8ct_125genes[["Major_class"]] <- simulation$annotDf$Cell_class
bregmaFN7FullSeur_8ct_125genes[["All_classes"]] <- simulation$annotDf$Cell_class

```

8 cell-ypes and 135 genes:
```{r}

simulation <- simFN7_8ct_135genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_8ct_135genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 8ct 135 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_8ct_135genes[["Major_class"]] <- simulation$annotDf$Cell_class
bregmaFN7FullSeur_8ct_135genes[["All_classes"]] <- simulation$annotDf$Cell_class

```

9 cell-ypes and 125 genes:
```{r}

simulation <- simFN7_9ct_125genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_9ct_125genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 9ct 125 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_9ct_125genes[["Major_class"]] <- simulation$annotDf$Cell_class
bregmaFN7FullSeur_9ct_125genes[["All_classes"]] <- simulation$annotDf$Cell_class

```

9 cell-ypes and 135 genes:
```{r}

simulation <- simFN7_9ct_135genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_9ct_135genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 9ct 135 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_9ct_135genes[["Major_class"]] <- simulation$annotDf$Cell_class
bregmaFN7FullSeur_9ct_135genes[["All_classes"]] <- simulation$annotDf$Cell_class

```

### save

```{r}

save(simFN7_8ct_125genes, simFN7_8ct_135genes, simFN7_9ct_125genes, simFN7_9ct_135genes,
     simFN7_neuro_8ct_125genes, simFN7_neuro_8ct_135genes, simFN7_neuro_9ct_125genes, simFN7_neuro_9ct_135genes,
      bregmaFN7FullSeur_8ct_125genes, bregmaFN7FullSeur_8ct_135genes, bregmaFN7FullSeur_9ct_125genes, bregmaFN7FullSeur_9ct_135genes,
      file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_v2-simFN7_8-9cts_125-135gene_combos.RData")

```

### ---------------

### pixel overdispersed genes

```{r}

simulation <- simFN7_8ct_135genes

counts <- t(as.matrix(simulation$sim)) # genes x pixels matrix
odGenes <- getOverdispersedGenes(counts,
                                 alpha = 0.05,
                                 plot = TRUE,
                                 details = TRUE,
                                 verbose = TRUE)
countsFilt <- counts[odGenes$ods,]

```

MERINGUE comparison




## -----------------
## 10um Sim

this generates the hash tables of simulates spots for each bregma separately

```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 10)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 10)

```

Generate each simulated corpus for each simulated bregma:

Major cell types

```{r}

simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)

```

Recall that the `$gtSpotTopics` of each simulated corpus are of primary interest to compare the fitted models to for each bregma.

The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches and so should be ignored if looking at the entire animal.

Combine the simulated bregmas in the `simBregma` lists to make a single corpus for all bregmas to train a single model.
The `gtSpotTopics` can be combined as well for a ground truth reference, but each `gtCtGenes` is built using just the cells in each given bregma. So instead use the `gtCtGenesFN7` or `gtCtNeuronalGenesFN7`, which were average gexp for cell types across all cells.


Combine the simulated matrices for each bregma into one corpus:

Major cell types

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_10um <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)

```

Neuronal subtypes:

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro_10um <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```

at 10um, most simulated pixels are actual single cells with a few doublets. very rare triplets

```{r}

# hist(rowSums(simFN7_10um$gtSpotTopics > 0))

table(rowSums(simFN7_10um$gtSpotTopics > 0))

```

## 20um Sim

this generates the hash tables of simulates spots for each bregma separately
```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 20)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 20)


simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)



# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_20um <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)



# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro_20um <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```


```{r}

# hist(rowSums(simFN7_10um$gtSpotTopics > 0))

table(rowSums(simFN7_20um$gtSpotTopics > 0))

sum(table(rowSums(simFN7_20um$gtSpotTopics > 0)))


```

## seurat input

```{r}

dim(bregmaCellsGexpFN7)

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simFN7$annotDf),]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 in pixels scRNAseq")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur[["Major_class"]] <- simFN7$annotDf$Cell_class
bregmaFN7FullSeur[["All_classes"]] <- simFN7_neuro$annotDf$Cell_class

```

# ----------------------------------
## 10 um 8 major

57397x125.

```{r}

# fit models to a range of K's that include 9 (for 8-9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
# ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

same corpus for `simFN7` and `simFN7_neuro` so can use either for model fitting

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs_10um <- fitLDA(counts = simFN7_10um$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
# dev.off()

```

```{r}

FN7_LDAs_10um_k8 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_10um, opt = 8),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

### viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(8)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7)[1], function(ix){
  
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  
  m <- FN7_LDAs_10um_k8$theta[spots,]
  p <- simFN7_10um$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 5,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
  
  # set.seed(8)
  # 
  # m <- simFN7$gtSpotTopics[spots,] # The ground truth proportions for 9 major cts
  # p <- simFN7$cellCounts[spots, c("x", "y")] # the positions of sim spots for the bregma -0.04
  # 
  # vizAllTopics(theta = m,
  #              pos = p,
  #              topicOrder=seq(ncol(m)),
  #              topicCols=randomcoloR::distinctColorPalette(ncol(m)),
  #              groups = NA,
  #              group_cols = NA,
  #              r = 40,
  #              lwd = 0.5,
  #              showLegend = TRUE,
  #              plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-3_FN7_gt_8_mjrcts_", ix, ".pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
})

```

### theta correlation

FN7 fitted with k=8 major cell types (ambiguous removed)

```{r}

corMtx <- getCorrMtx(m1 = FN7_LDAs_10um_k8$theta,
                           m2 = as.matrix(simFN7_10um$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

```

### beta correlation

```{r}

corMtx <- getCorrMtx(m1 = FN7_LDAs_10um_k8$beta,
                     m2 = as.matrix(simFN7_10um$gtCtGenes), # gt made from cells in bregma
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

```

```{r}

mat <- FN7_LDAs_10um_k8$theta
mat[mat < 0.3] <- 0

a <- rowSums(mat > 0)
b <- rowSums(simFN7_10um$gtSpotTopics > 0)

table(a)
table(b)

```

### singles, doublets

```{r}

print("percentages")
print("doublets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)

print("predicted doublets that were actually doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2))))*100, 2)
print("predicted doublets that were actually singlets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(a == 2))))*100, 2)

```

```{r}

print("percentages")
print("singlets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)

print("predicted singlets that were actually singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1))))*100, 2)
print("predicted singlets that were actually doublets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(a == 1))))*100, 2)

```

Seems to do really well detecting singlets, but most predicted doublets are actually singlets. Does poor job detecting doublets.
# ----------------------------------
## 20 um 8 major

45978x125 corpus

```{r}

# fit models to a range of K's that include 9 (for 8-9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
# ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

same corpus for `simFN7` and `simFN7_neuro` so can use either for model fitting

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs_20um <- fitLDA(counts = simFN7_20um$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
# dev.off()

```

```{r}

FN7_LDAs_20um_k8 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_20um, opt = 8),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

### Summary stats

```{r}

# summary(FN7_cellTypeTable)
# 
# # total cells in pixels
# print("total cells in pixels")
# summary(rowSums(FN7_cellTypeTable))
# # pdf(file = paste0(fig_path, "Fig_S1_cells-in-pixels.pdf"),   # The directory you want to save the file in
# #     width = 5, # The width of the plot in inches
# #     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_cellTypeTable), breaks = 20,
#      col = "white",
#      main = "",
#      xlab = "Number of cells",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# dev.off()

# -------------------------------------------------------------
# total cell types in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_cellTypeTable > 0), breaks = 8,
#      col = "white",
#      main = "",
#      xlab = "Number of cell-types",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# # dev.off()
# 
# print("cell types in pixels:")
# summary(rowSums(FN7_cellTypeTable > 0))
# 
# print("cell subtypes in pixels:")
# summary(rowSums(FN7_neuro_cellTypeTable > 0))

# -------------------------------------------------------------
# total cell subtypes in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_neuro_cellTypeTable > 0), breaks = 20,
#      col = "white",
#      main = "",
#      xlab = "Number of cell-subtypes",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# dev.off()

# -------------------------------------------------------------
# cell-type proportions across spots (non-zero)
# pdf(file = paste0(fig_path, "Fig_S1_all-cell-types-proportions.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
hist(as.vector(simFN7_20um$gtSpotTopics[simFN7_20um$gtSpotTopics > 0]),
     breaks = 101,
     col = "white",
     main = "non-zero cell-type proportions in pixels",
     xlab = "Proportion",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
# dev.off()

print("cell types proportions in each pixel:")
summary(as.vector(simFN7_20um$gtSpotTopics[simFN7_20um$gtSpotTopics > 0]))
summary(simFN7_20um$gtSpotTopics)
print("cell subtypes proportions in each pixel:")
summary(as.vector(simFN7_neuro_20um$gtSpotTopics[simFN7_neuro_20um$gtSpotTopics > 0]))

```

```{r}

ggplot(data = reshape2::melt(simFN7_neuro_20um$gtSpotTopics)) +
  # geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  geom_jitter(aes(x = reorder(Var2, -value), y = value), position=position_jitter(0.1), cex=0.1) +
  scale_y_continuous(breaks = seq(0,1,0.05)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        )

```

### Correlations 

```{r}

gt <- simFN7_20um
decon <- FN7_LDAs_20um_k8
filt_theta <- FN7_LDAs_20um_k8$theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type transcriptional profile correlation\n(20 micron pixels, 8 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=8),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=8),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_20um_8cts_txn_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(20 micron pixels, 8 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=8),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=8),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_20um_8cts_prop_corr_heatmap_txn_ordered_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------

# corMtx_prop_2 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                           m2 = decon$theta[,pairs$colsix],
#                           type = "t")
# colnames(corMtx_prop_2) <- paste0("Cell-type ", colnames(corMtx_prop_2))
# 
# # plot the proportion correlations, cell-types ordered based on transcriptional pairing
# dat <- reshape2::melt(corMtx_prop_2)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(20 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_20um_8cts_prop_corr_heatmap_txn_ordered_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (txn order, before filtering) across diag:", mean(diag(corMtx_prop_2)), "\n")
# cat("median proportional corr (txn order, before filtering) across diag:", median(diag(corMtx_prop_2)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
# corMtx_prop_3 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                          m2 = decon$theta,
#                          type = "t")
# pairs <- lsatPairs(corMtx_prop_3)
# ## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
# ## the properly ordered proportional correlation matrix
# corMtx_prop_3 <- corMtx_prop_3[pairs$rowix, pairs$colsix]
# colnames(corMtx_prop_3) <- paste0("Cell-type ", colnames(corMtx_prop_3))
# 
# # plot the proportion correlations
# dat <- reshape2::melt(corMtx_prop_3)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(20 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_20um_8cts_prop_corr_heatmap_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (prop order, before filtering) across diag:", mean(diag(corMtx_prop_3)), "\n")
# cat("median proportional corr (prop order, before filtering) across diag:", median(diag(corMtx_prop_3)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(20 micron pixels, 8 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=8),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=8),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_20um_8cts_prop_corr_heatmap_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  proportional = diag(corMtx_prop_1)
                                  # proportional_prop = diag(corMtx_prop_4)
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1) +
  ggplot2::ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth cell-type correlations\n(20 micron pixels, 8 cell-types)",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_20um_8cts_heatmap_daig_corrs_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```

### Gene ranks

MERIGNUE differential genes for each cluster:

```{r}

# cells and their associated clusters
neuroClusters <- bregmaFN7FullSeur@meta.data$All_classes
names(neuroClusters) <- rownames(bregmaFN7FullSeur@meta.data)
# I-39 only has one cell so drop 
neuroClusters <- neuroClusters[which(!neuroClusters %in% c("I-39"))]
difGenesNeuro <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = neuroClusters)

# cells and their associated clusters
majorClusters <- bregmaFN7FullSeur@meta.data$Major_class
names(majorClusters) <- rownames(bregmaFN7FullSeur@meta.data)
difGenesMajor <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = majorClusters)
                                            
```

```{r}

m1 <- FN7_LDAs_20um_k8$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m1, # rows
                     m2 = m2, # cols
                     type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct
        ct <- rownames(m2)[pairs$colsix[i]]
        topic <- i
        
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot2::ggplot(data = ct_df) +
                ggplot2::geom_point(aes(x = gexp_rank, y = beta_rank)) +
                ggplot2::labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Deconvolved vs ground truth transcriptional profile gene rank",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_20um_8cts_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

### singlets, doublets

```{r}

dat <- do.call(rbind, lapply(seq(0.01, 1, 0.01), function(i){
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < i] <- 0
  a <- rowSums(mat > 0)
  b <- rowSums(simFN7_20um$gtSpotTopics > 0)
  
  # "true doublets assigned as doublets"
  d_tp <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2)))), 2)
  # "true singlets assigned as singlets"
  s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  # "predicted doublets that were true doublets"
  d_tpr <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2)))), 2)
  # "predicted singlets that were true singlets"
  s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  
  row <- c(s_tpr, d_tpr, s_tp, d_tp)
  row
  
}))

rownames(dat) <- seq(0.01, 1, 0.01)
colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")

```

```{r}

ggplot(data = reshape2::melt(dat)) +
  geom_line(aes(x = Var1, y = value, color = Var2)) +
  xlab("proportion cutoff") +
  ylab("")
  

```

```{r}

# corMtx <- getCorrMtx(m1 = FN7_LDAs_20um_k8$theta,
#                      m2 = as.matrix(simFN7_20um$gtSpotTopics),
#                      type = "t")
# pairs <- lsatPairs(corMtx)
# topics <- rownames(corMtx[pairs$rowix, pairs$colsix])
# cts <- colnames(corMtx[pairs$rowix, pairs$colsix])

for(ct in seq(8)){
  
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < 0.2] <- 0
  mat[mat >= 0.2] <- 1
  mat <- mat/rowSums(mat)
  a <- mat[,pairs$rowix[ct]]
  b <- simFN7_20um$gtSpotTopics[,pairs$colsix[ct]]
  dat <- cbind(a, b)
  
  plt <- ggplot(data = data.frame(dat)) +
    geom_hex(aes(x = a, y = b)) +
    xlab("predicted proportion") +
    ylab("gt proportion") +
    ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  print(plt)
  
  # lapply(seq(0.01, 1, 0.01), function(i){
  #   mat <- FN7_LDAs_20um_k8$theta
  #   mat[mat < i] <- 0
  #   mat[mat >= i] <- 1
  #   mat <- mat/rowSums(mat)
  #   a <- mat[,pairs$rowix[ct]]
  #   b <- simFN7_20um$gtSpotTopics[,pairs$colsix[ct]]
  #   dat <- cbind(a, b)
  #   plt <- ggplot(data = reshape2::melt(dat)) +
  #     geom_point(aes(x = Var1, y = value, color = Var2)) +
  #     xlab("proportion cutoff") +
  #     ylab("") +
  #     ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  #   print(plt)
  #   
  #   # "true singlets assigned as singlets"
  #   s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  #   # "predicted singlets that were true singlets"
  #   s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  #   
  #   # "true singlets assigned as singlets"
  #   d_tp <- round((length(intersect(names(which(a == 0.5)), names(which(b == 0.5)))) / length(names(which(b == 0.5)))), 2)
  #   # "predicted singlets that were true singlets"
  #   d_tpr <- round((length(intersect(names(which(a == 0.5)), names(which(b == 0.5)))) / length(names(which(a == 0.5)))), 2)
  #   
  #   row <- c(s_tpr, d_tpr, s_tp, d_tp)
  #   row
  #   
  # })
  # 
  # rownames(dat) <- seq(0.01, 1, 0.01)
  # colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")
  # 
  # plt <- ggplot(data = reshape2::melt(dat)) +
  #   geom_line(aes(x = Var1, y = value, color = Var2)) +
  #   xlab("proportion cutoff") +
  #   ylab("") +
  #   ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  # print(plt)
  
}


```

```{r}

dat <- do.call(rbind, lapply(seq(0.01, 1, 0.01), function(i){
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < i] <- 0
  mat[mat >= i] <- 1
  mat <- mat/rowSums(mat)
  a <- rowSums(mat > 0)
  b <- rowSums(simFN7_20um$gtSpotTopics > 0)
  
  # "true doublets assigned as doublets"
  d_tp <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2)))), 2)
  # "true singlets assigned as singlets"
  s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  # "predicted doublets that were true doublets"
  d_tpr <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2)))), 2)
  # "predicted singlets that were true singlets"
  s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  
  row <- c(s_tpr, d_tpr, s_tp, d_tp)
  row
  
}))

rownames(dat) <- seq(0.01, 1, 0.01)
colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")

```


```{r}

mat <- FN7_LDAs_20um_k8$theta
mat[mat < 0.23] <- 0

a <- rowSums(mat > 0)
b <- rowSums(simFN7_20um$gtSpotTopics > 0)

table(a)
table(b)

```

what is the overlap between the singles, doublets, triples of the actual vs predictions? 

```{r}

print("percentages")
print("doublets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)

print("predicted doublets that were actually doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2))))*100, 2)
print("predicted doublets that were actually singlets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(a == 2))))*100, 2)

```

```{r}

print("percentages")
print("singlets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)

print("predicted singlets that were actually singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1))))*100, 2)
print("predicted singlets that were actually doublets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(a == 1))))*100, 2)

```
# ----------------------------------
## 100 um

### Viz bregmas

```{r}

classCols <- c("Astrocyte" = "#F8766D",
               "Endothelial" = "#CD9600",
               "Ependymal" = "#7CAE00",
               "Excitatory" = "#00BE67",
               "Inhibitory" = "#00BFC4",
               "Microglia" = "#00A9FF",
               "OD" = "#C77CFF",
               "Pericytes" = "#FF61CC")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

for(ix in names(simBregmasFN7)[1]){
# do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  # -------------------------------------------------------------
  # each cell type separately
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p1)
  ggsave(filename = paste0("0_8cts_separate_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  # all cells with grid showing
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p2)
  ggsave(filename = paste0("0_8cts_grid_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  # ground truth proportions
  m <- as.matrix(simFN7$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = ix)
  print(p3)
  ggsave(filename = paste0("0_8cts_simST_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  # c(p1, p2, p3)
  
}
  

# }

```

### Summary stats

```{r}

summary(FN7_cellTypeTable)

# total cells in pixels
print("total cells in pixels")
summary(rowSums(FN7_cellTypeTable))
# pdf(file = paste0(fig_path, "Fig_S1_cells-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_cellTypeTable), breaks = 20,
     col = "white",
     main = "",
     xlab = "Number of cells",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
# dev.off()

# -------------------------------------------------------------
# total cell types in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_cellTypeTable > 0), breaks = 8,
     col = "white",
     main = "",
     xlab = "Number of cell-types",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
# dev.off()

print("cell types in pixels:")
summary(rowSums(FN7_cellTypeTable > 0))

print("cell subtypes in pixels:")
summary(rowSums(FN7_neuro_cellTypeTable > 0))

# -------------------------------------------------------------
# total cell subtypes in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_neuro_cellTypeTable > 0), breaks = 20,
     col = "white",
     main = "",
     xlab = "Number of cell-subtypes",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
# dev.off()

# -------------------------------------------------------------
# cell-type proportions across spots (non-zero)
# pdf(file = paste0(fig_path, "Fig_S1_all-cell-types-proportions.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
hist(as.vector(simFN7$gtSpotTopics[simFN7$gtSpotTopics > 0]),
     breaks = 101,
     col = "white",
     main = "non-zero cell-type proportions in pixels",
     xlab = "Proportion",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
# dev.off()

print("cell types proportions in each pixel:")
summary(as.vector(simFN7$gtSpotTopics[simFN7$gtSpotTopics > 0]))
summary(simFN7$gtSpotTopics)
print("cell subtypes proportions in each pixel:")
summary(as.vector(simFN7_neuro$gtSpotTopics[simFN7_neuro$gtSpotTopics > 0]))

```

```{r}

ggplot(data = reshape2::melt(simFN7_neuro$gtSpotTopics)) +
  # geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  geom_jitter(aes(x = reorder(Var2, -value), y = value), position=position_jitter(0.1), cex=0.1) +
  scale_y_continuous(breaks = seq(0,1,0.05)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        )

```

### Train LDA

```{r}

ks <- seq(from = 2, to = 20, by = 1)
ks <- c(ks, seq(from = 30, to = 70, by = 20))
ks <- c(ks, 76)
ks

```

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs <- fitLDA(counts = as.matrix(simFN7$sim),
                   Ks = ks,
                   testSize = NULL,
                   seed = 0,
                   ncores = 7,
                   plot = TRUE)
# dev.off()

```

### k = 8

viz the perplexity and rare cts just for viz purposes here

```{r}

ks <- seq(from = 2, to = 20, by = 1)

```

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs_2to20_135genes <- fitLDA(counts = as.matrix(simFN7$sim),
                   Ks = ks,
                   testSize = NULL,
                   perc.rare.thresh = 0.025,
                   seed = 0,
                   ncores = 7,
                   plot = TRUE)
# dev.off()

```

### extract betas thetas

```{r}

FN7_K9_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_2to20_135genes, opt = 9),
                         corpus = as.matrix(simFN7$sim),
                         deepSplit = 4,
                         colorScheme = "rainbow")

```

```{r}
FN7_K8 ## 125 genes and 8 cts
FN7_K8_135genes ## 135 genes and 8 cts
FN7_K9_135genes ## 135 genes and 9 cts
```


In the actual corpus, the lowest non-zero proportion is 2.5%, so remove all proportions less than that

```{r}

lda_k8_theta <- FN7_K8_135genes$theta
lda_k8_theta[lda_k8_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
# ambig <- 1 - rowSums(lda_k8_theta)
# lda_k8_theta2 <- cbind(lda_k8_theta, ambig)

# readjust proportions
lda_k8_theta <- lda_k8_theta/rowSums(lda_k8_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k8_theta[is.na(lda_k8_theta)] <- 0

summary(lda_k8_theta)

ggplot(data = reshape2::melt(lda_k8_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k8_theta <- lda_k8_theta[,which(colSums(lda_k8_theta) > 0)]
# lda_k8_theta2 <- lda_k8_theta2[,which(colSums(lda_k8_theta2) > 0)]

```

#### Viz predictions

```{r}

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = lda_k8_theta, # rows
                     m2 = as.matrix(simFN7$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

# plot each bregma separately
for(ix in names(simBregmasFN7)[1]){
  
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- simFN7$gtSpotTopics[spots,]
  
  m <- lda_k8_theta[spots,]
  p <- cellCounts[, c("x", "y")]
  
  p1 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = TRUE,
                     plotTitle = ix)
  print(p1)
  ggplot2::ggsave(filename = paste0("0_8cts_135genes_STdev_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

}

```

```{r, fig.height=48, fig.width=5}

classCols <- c("Astrocyte" = "#F8766D",
               "Endothelial" = "#CD9600",
               "Ependymal" = "#7CAE00",
               "Excitatory" = "#00BE67",
               "Inhibitory" = "#00BFC4",
               "Microglia" = "#00A9FF",
               "OD" = "#C77CFF",
               "Pericytes" = "#FF61CC")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = lda_k8_theta, # rows
                     m2 = as.matrix(simFN7$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows


## -------------------------------------------------------------
## each cell type separately
plts1 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.3) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})

layout <- matrix(seq(12))
plts1_grid <- gridExtra::grid.arrange(
                  grobs = plts1,
                  layout_matrix = layout
)
plts1_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_separateCts_AllBregmas.png"),
                plot = plts1_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

## -------------------------------------------------------------
## all cells with grid showing
plts2 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.4) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") #+
    #ggtitle(ix)
  ggplotGrob(p2)
})

layout <- matrix(seq(12))
plts2_grid <- gridExtra::grid.arrange(
                  grobs = plts2,
                  layout_matrix = layout
)
plts2_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_grid_AllBregmas.png"),
                plot = plts2_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## ground truth proportions
plts3 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]

  m <- as.matrix(simFN7$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = NA)
  ggplotGrob(p3)
})

layout <- matrix(seq(12))
plts3_grid <- gridExtra::grid.arrange(
                  grobs = plts3,
                  layout_matrix = layout
)
plts3_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_simST_AllBregmas.png"),
                plot = plts3_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## STdeconvolve proportions
plts4 <- lapply(names(simBregmasFN7), function(ix){

  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- simFN7$gtSpotTopics[spots,]

  m <- lda_k8_theta[spots,]
  p <- cellCounts[, c("x", "y")]

  p4 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = FALSE,
                     plotTitle = NA)
  ggplotGrob(p4)
})

layout <- matrix(seq(12))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = plts4,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_STdeconvolve_AllBregmas.png"),
                plot = plts4_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

# layout <- t(matrix(seq(length((simBregmasFN7))*4), nrow=4))

```

#### Correlations 

```{r}

gt <- simFN7

clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D", ## ward.D
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  # ggplot2::xlab("Ground truth cell-types") +
  # ggplot2::ylab("Deconvolved cell-types") +
  # ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_8cts_135genes_gt_txn_profile_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```


```{r}

gt <- simFN7
decon <- FN7_K8_135genes
filt_theta <- lda_k8_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_txn_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_prop_corr_heatmap_txn_ordered_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------

# corMtx_prop_2 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                           m2 = decon$theta[,pairs$colsix],
#                           type = "t")
# colnames(corMtx_prop_2) <- paste0("Cell-type ", colnames(corMtx_prop_2))
# 
# # plot the proportion correlations, cell-types ordered based on transcriptional pairing
# dat <- reshape2::melt(corMtx_prop_2)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_8cts_prop_corr_heatmap_txn_ordered_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (txn order, before filtering) across diag:", mean(diag(corMtx_prop_2)), "\n")
# cat("median proportional corr (txn order, before filtering) across diag:", median(diag(corMtx_prop_2)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
# corMtx_prop_3 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                          m2 = decon$theta,
#                          type = "t")
# pairs <- lsatPairs(corMtx_prop_3)
# ## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
# ## the properly ordered proportional correlation matrix
# corMtx_prop_3 <- corMtx_prop_3[pairs$rowix, pairs$colsix]
# colnames(corMtx_prop_3) <- paste0("Cell-type ", colnames(corMtx_prop_3))
# 
# # plot the proportion correlations
# dat <- reshape2::melt(corMtx_prop_3)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_8cts_prop_corr_heatmap_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (prop order, before filtering) across diag:", mean(diag(corMtx_prop_3)), "\n")
# cat("median proportional corr (prop order, before filtering) across diag:", median(diag(corMtx_prop_3)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_prop_corr_heatmap_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = diag(corMtx_prop_4)
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1) +
  ggplot2::ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_heatmap_daig_corrs_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 3,
         height = 4,
         units = c("in"),
         dpi = 300)

```

#### Gene ranks

MERIGNUE differential genes for each cluster:
```{r}

# cells and their associated clusters
neuroClusters <- bregmaFN7FullSeur@meta.data$All_classes
names(neuroClusters) <- rownames(bregmaFN7FullSeur@meta.data)
# I-39 only has one cell so drop 
neuroClusters <- neuroClusters[which(!neuroClusters %in% c("I-39"))]
difGenesNeuro <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = neuroClusters)

# cells and their associated clusters
majorClusters <- bregmaFN7FullSeur@meta.data$Major_class
names(majorClusters) <- rownames(bregmaFN7FullSeur@meta.data)
difGenesMajor <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = majorClusters)
                                            
```

```{r}

m1 <- FN7_K8_135genes$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m1, # rows
                     m2 = m2, # cols
                     type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct
        ct <- rownames(m2)[pairs$colsix[i]]
        topic <- i
        
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank)) +
                labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Cell-type transcriptional profiles",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic() +
        ggplot2::theme(axis.text.x=element_text(size=15),
                       axis.text.y=element_text(size=15),
                       axis.title.y=element_text(size=15),
                       axis.title.x=element_text(size=15),
                       plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 4,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

### k = 75

```{r}

FN7_K75 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs, opt = "75"),
                          corpus = as.matrix(simFN7$sim),
                          deepSplit = 2, # collapsed more to reduce number of clusters to 15
                          colorScheme = "rainbow")

```

In the actual corpus, the lowest non-zero proportion is 2.5%, so remove all proportions less than that

```{r}

lda_k75_theta <- FN7_K75$theta
lda_k75_theta[lda_k75_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
# ambig <- 1 - rowSums(lda_k75_theta)
# lda_k75_theta2 <- cbind(lda_k75_theta, ambig)

# readjust proportions
lda_k75_theta <- lda_k75_theta/rowSums(lda_k75_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k75_theta[is.na(lda_k75_theta)] <- 0

summary(lda_k75_theta)

ggplot(data = reshape2::melt(lda_k75_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
lda_k75_theta <- lda_k75_theta[,which(colSums(lda_k75_theta) > 0)]
# lda_k75_theta2 <- lda_k75_theta2[,which(colSums(lda_k75_theta2) > 0)]

```

#### Correlations 

```{r}

gt <- simFN7_neuro
decon <- FN7_K75
filt_theta <- lda_k75_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type transcriptional profile correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_txn_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_txn_ordered_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------

# corMtx_prop_2 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                           m2 = decon$theta[,pairs$colsix],
#                           type = "t")
# colnames(corMtx_prop_2) <- paste0("Cell-type ", colnames(corMtx_prop_2))
# 
# # plot the proportion correlations, cell-types ordered based on transcriptional pairing
# dat <- reshape2::melt(corMtx_prop_2)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_txn_ordered_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (txn order, before filtering) across diag:", mean(diag(corMtx_prop_2)), "\n")
# cat("median proportional corr (txn order, before filtering) across diag:", median(diag(corMtx_prop_2)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
# corMtx_prop_3 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                          m2 = decon$theta,
#                          type = "t")
# pairs <- lsatPairs(corMtx_prop_3)
# ## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
# ## the properly ordered proportional correlation matrix
# corMtx_prop_3 <- corMtx_prop_3[pairs$rowix, pairs$colsix]
# colnames(corMtx_prop_3) <- paste0("Cell-type ", colnames(corMtx_prop_3))
# 
# # plot the proportion correlations
# dat <- reshape2::melt(corMtx_prop_3)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (prop order, before filtering) across diag:", mean(diag(corMtx_prop_3)), "\n")
# cat("median proportional corr (prop order, before filtering) across diag:", median(diag(corMtx_prop_3)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  proportional_txn = diag(corMtx_prop_1),
                                  proportional_prop = diag(corMtx_prop_4)))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1) +
  ggplot2::ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth cell-type correlations, between pairs\n(100 micron pixels, 75 cell-types)",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_100um_75cts_heatmap_daig_corrs_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```

Transcriptional correlation still high but pixel proportions lower, but this is likely due to the fact that it is more difficult to deconvovle rare cell-types. (note that this positional correlation is when pairing cells based on highest pixel proportional correlation. If I pair based on transcriptional correlation, then compute pixel proportional correlation, then its a lot lower. So this probably speaks to the fact that a lot of the rare cell types are also very transcriptionally similar, making it even harder to assign the right one. But if more distinct, cell-types instead of subtypes, it becomes a lot easier. The pairing based on transcriptional and proportional correlation is the same)

#### Gene ranks

```{r}

m1 <- FN7_K75$beta
m2 <- as.matrix(gtCtNeuronalGenesFN7) # drop I-39
m2 <- m2[rownames(m2) != "I-39",]

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m2,
                      m2 = m1,
                      type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct and topic
        ct <- rownames(m2)[i]
        topic <- pairs$colsix[i]
        
        # the corresponding diff genes table
        ct_df <- difGenesNeuro[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank)) +
                labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[ct,topic], 2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        # print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Deconvolved vs ground truth transcriptional profile gene rank",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_100um_75cts_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

# ----------------------------------

# Number of pixels benchmark

```{r}
numPixelsBenchmark <- readRDS("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/numPixelsBenchmark.Rds")
```

```{r}

corpus <- as.matrix(simFN7$sim)
Ks <- seq(3,10)
numDocs <- c(3,5,10,50,100,150)
# numDocs <- c(3,10,50,100)
numReps <- seq(10)
# numDocs <- c(3,5)
# numReps <- seq(3)

# Ks <- seq(2,3)
# numDocs <- c(3,10)
# numReps <- seq(1)

numPixelsBenchmark <- do.call(rbind, lapply(numDocs, function(d){
# for(d in numDocs){
  combined_df <- data.frame(numDocs=character(),
                            replicate=character(),
                            K=character(),
                            RMSE=double())
  for(r in numReps){
    set.seed(r)
    ## for each replicate, get a sample of pixel of size d
    s <- sample(nrow(corpus), d)
    sampleCorpus <- corpus[s,]
    gtCorpus <- simFN7$gtSpotTopics[s,]
    ## drop cell-types that are 0 for all samples pixels
    gtCorpus <- gtCorpus[,which(colSums(gtCorpus) > 0)]
    
    ## fit LDA models for each K in Ks on the sampled corpus
    ldas <- fitLDA(counts = sampleCorpus,
                   Ks = Ks,
                   testSize = NULL,
                   seed = seed,
                   ncores = 7,
                   plot = FALSE)
    # get beta and theta of sampled pixels for each fitted LDA model
    for(k in Ks){
      res <- getBetaTheta(lda = optimalModel(models = ldas, opt = k),
                          corpus = sampleCorpus)
      ## compute rmse
      ## get pairs of topics and ground truth cell types that correlate best
      ## cannot have more rows than columns when pairing
      if (ncol(res$theta) <= ncol(as.matrix(gtCorpus))){
        theta_pairs <- lsatPairs(getCorrMtx(m1 = as.matrix(res$theta),
                                            m2 = as.matrix(gtCorpus),
                                            type = "t"))
        predict_theta <- res$theta[,theta_pairs$rowix]
        truth_theta <- gtCorpus[,theta_pairs$colsix]
      } else {
        theta_pairs <- lsatPairs(getCorrMtx(m1 = as.matrix(gtCorpus),
                                            m2 = as.matrix(res$theta),
                                            type = "t"))
        predict_theta <- res$theta[,theta_pairs$colsix]
        truth_theta <- gtCorpus[,theta_pairs$rowix]
      }
      ## the rmse for the pixels, for a given K and numDocs; and for each replicate of that combo
      rmses <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
        # for each spot, compute RMSE based on proportions across cts
        # so a RMSE for each spots based on all the cts
        actual <- as.vector(truth_theta[i,])
        predict <- as.vector(predict_theta[i,])
        mltools::rmse(preds = predict, actuals = actual)
      }))
      m <- data.frame(numDocs = rep(d, length(rmses)),
                      replicate = rep(r, length(rmses)),
                      K = rep(k, length(rmses)),
                      RMSE = rmses)
      combined_df <- rbind(combined_df, m)
    }
  }
  combined_df
}))

numPixelsBenchmark

```

```{r}

tmp_df <- numPixelsBenchmark[numPixelsBenchmark$K %in% c(8),]
tmp_df <- tmp_df[tmp_df$numDocs %in% c(5,10,50,100,150),]

## mean rmse for each replicate
summary_df <- tmp_df %>%
  group_by(numDocs, replicate) %>%
  dplyr::summarize(MeanRMSE = mean(RMSE, na.rm=TRUE),
                   n = n(),
                   sd = sd(RMSE, na.rm=TRUE),
                   se = sd/sqrt(n))

## mean rmse for the means of all replicates for a given numDoc
summary_df2 <- summary_df %>%
  group_by(numDocs) %>%
  dplyr::summarize(MeanRMSEreps = mean(MeanRMSE, na.rm=TRUE),
                   n = n(),
                   sd = sd(MeanRMSE, na.rm=TRUE),
                   se = sd/sqrt(n))

ggplot() +
  geom_point(data = summary_df, aes(x = numDocs, y = MeanRMSE)) +
  geom_line(data = summary_df2, aes(x = numDocs, y = MeanRMSEreps), lwd = 2) +
  # geom_ribbon(aes(ymax = `Mean RMSE` + sd, ymin = `Mean RMSE` - sd, x = numDocs, fill = as.character(K)), alpha = 0.2, lwd = 0)
  # guides(color=guide_legend(title="K (number of cell-types")) +
  scale_x_continuous(breaks = c(5,10,50,100,150), labels = c(5,10,50,100,150)) +
  labs(title = "STdeconvolve accuracy on MERFISH ST dataset",
       x = "number of pixels", y = "mean RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size=15),
        axis.title.y = element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        panel.grid.minor = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_line(color = "black", size = 0.1)
        )
ggplot2::ggsave(filename = paste0("2_100um_8cts_numPixels_benchmark.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 3,
         units = c("in"),
         dpi = 300)

```

# ----------------------------------

Use the RMSE for each pixel Because each method would be compared to the same cell-type for each pixel, ok to use RMSE, as the units would technically be equivalent for all methods.

But when comparing each cell-type individually, should normalize.

Double check the the normalization is doing what you think it is.


# RMSE

## SL 8 Cts

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
# Seurat::Idents(object = bregmaFN7FullSeur) <- bregmaFN7FullSeur@meta.data$Major_class
# 
# levels(bregmaFN7FullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

# FindAllMarkers will find markers differentially expressed in each identity group by comparing
# it to all of the others - you don't have to manually define anything.
# Note that markers may bleed over between closely-related groups - they are not forced to be specific to only one group

# bregmaFN7FullSeur_markers8cts <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur,
#                                               assay = "RNA",
#                                               slot = "data", # counts or data are identical in this case
#                                               verbose = TRUE,
#                                               only.pos = TRUE)

```

Finally, lets train the model 

```{r}

set.seed(888)

SL_bregmaFN7FullSeur8cts_fit <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur,
  counts_spatial = t(as.matrix(simFN7$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFN7FullSeur_markers8cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

### 8 cts

```{r}

sl_FN7 <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur8cts_fit[[1]], stCounts = t(as.matrix(simFN7$sim)))

```

similar to LDA, remove cells less than 2.5%

```{r}

sl_k8_theta <- sl_FN7$thetaCt
sl_k8_theta[sl_k8_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
# ambig <- 1 - rowSums(sl_k8_theta)
# sl_k8_theta2 <- cbind(sl_k8_theta, ambig)

# readjust proportions
sl_k8_theta <- sl_k8_theta/rowSums(sl_k8_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_k8_theta[is.na(sl_k8_theta)] <- 0

summary(sl_k8_theta)

ggplot(data = reshape2::melt(sl_k8_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_k8_theta <- sl_k8_theta[,which(colSums(sl_k8_theta) > 0)]
# sl_k8_theta2 <- sl_k8_theta2[,which(colSums(sl_k8_theta2) > 0)]

```

```{r}

# breg_theta <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
breg_theta <- sl_k8_theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# # because RMSE is scale-dependent, transform proportions of each cell-type to the same scale
# # this way, each prediction to truth comparison will contribute equally to the RMSE.
# # so rare cell-types with inherently low proportions will not contribute small values but instead
# # contribute same values as what would be returned by the same relative difference between
# # prediction and truth of cell-types with high proportions.
# truth_theta <- apply(truth_theta, 2, scale0_1)
# predict_theta <- apply(predict_theta, 2, scale0_1)

# # BUT! If a truth has proportions that are already 0-1, and the predictions are small, lets say
# # 0 to 0.1, then this scale gets inflated to 0-1, and then the large differences between truth and prediction are no longer captured.
# # So the reported RMSE will be lower than what the actual error is. For this to work, the truth and predictions will 
# # have to initially be in the same range. 

# ---------------------------------------------
# # There is the possibility of computing RMSE for each cell type separately. Each RMSE will be wrt the units, or range or proportions
# # for that cell-type. Then to compare the RMSE for each cell-type, you can normalize the RMSEs. Divide by the sd or min-max for example.

# # Could then get the normalized RMSE for each cell-type across pixels, then plot the distribution of normalized RMSE for each method and compare side by side. Would also see cell-types that each method predicts well and Cts that are predicted poorly, compared across methods. And I think this would make more sense for the scatter plot of RMSE vs ct proportion.

# RMSE for each ct. Unadjusted proportions. But not normalize the RMSEs to be able to compare them
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_8cts_cosine) <- colnames(truth_theta)


# -----------------------------------------
# ggplot(data = reshape2::melt(truth_theta)) +
#   geom_jitter(aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   scale_y_continuous(breaks = seq(0,max(truth_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   ggtitle("Truth Scaled")

# t_scaled <- data.frame(truth_theta, group = "T")
# p_scaled <- data.frame(predict_theta, group = "P")
# dat <- rbind(t_scaled, p_scaled)
# 
# ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   ggtitle("Scaled 0-1")
# # -----------------------------------------
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_8cts) <- colnames(truth_theta)

```

### 75 cts

```{r}

# Set the known clusters as the "active.indent"
# Seurat::Idents(object = bregmaFN7FullSeur) <- bregmaFN7FullSeur@meta.data$All_classes
# 
# levels(bregmaFN7FullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

# bregmaFN7FullSeur_markers75neurocts <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur,
#                                               assay = "RNA",
#                                               slot = "data", # counts or data are identical in this case
#                                               verbose = TRUE,
#                                               only.pos = TRUE)

```

```{r}

sl_FN7_neuro <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur75neurocts_fit[[1]], stCounts = t(as.matrix(simFN7_neuro$sim)))

```

similar to LDA, remove cells less than 2.5%

```{r}

sl_k75_theta <- sl_FN7_neuro$thetaCt
sl_k75_theta[sl_k75_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
ambig <- 1 - rowSums(sl_k75_theta)
sl_k75_theta2 <- cbind(sl_k75_theta, ambig)

# readjust proportions
sl_k75_theta <- sl_k75_theta/rowSums(sl_k75_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_k75_theta[is.na(sl_k75_theta)] <- 0

summary(sl_k75_theta)

ggplot(data = reshape2::melt(sl_k75_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_k75_theta <- sl_k75_theta[,which(colSums(sl_k75_theta) > 0)]
sl_k75_theta2 <- sl_k75_theta2[,which(colSums(sl_k75_theta2) > 0)]

```

```{r}
m2 <- m2[rownames(m2) != "I-39",]
```


```{r}

# breg_theta <- SL_bregmaFN7FullSeur75neurocts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur75neurocts_fit[[2]])-1]
breg_theta <- sl_k75_theta
# fix column names so they match the gt
colnames(breg_theta) <- sub("\\.", "-", colnames(breg_theta))
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_sl_75cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_75cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_75cts_cosine) <- colnames(truth_theta)

# # -----------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_75cts) <- colnames(truth_theta)

```

## RCTD

reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_ref/"

ref <- bregmaFN7FullSeur

meta_ref <- ref@meta.data[,c("Major_class", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

data sets

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7/"
d <- simFN7

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

```

fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

FN7

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7 <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_fit <- RCTD::run.RCTD(RCTD_FN7, doublet_mode = TRUE)

RCTD_FN7_results <- RCTD_FN7_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_results_norm <-  sweep(RCTD_FN7_results$weights, 1, rowSums(RCTD_FN7_results$weights), '/')

```

reference neuro subtypes

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_neuro_ref/"

ref <- bregmaFN7FullSeur

meta_ref <- ref@meta.data[,c("All_classes", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$All_classes),
                         Name = unique(ref@meta.data$All_classes)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

data sets

same as 8cts

fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_neuro_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

FN7

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7_neuro <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_neuro_fit <- RCTD::run.RCTD(RCTD_FN7_neuro, doublet_mode = TRUE)

RCTD_FN7_neuro_results <- RCTD_FN7_neuro_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_neuro_results_norm <-  sweep(RCTD_FN7_neuro_results$weights, 1, rowSums(RCTD_FN7_neuro_results$weights), '/')

```

### 8 cts

similar to LDA, remove cells less than 2.5%

```{r}

rctd_k8_theta <- as.matrix(RCTD_FN7_results_norm)
rctd_k8_theta[rctd_k8_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
ambig <- 1 - rowSums(rctd_k8_theta)
rctd_k8_theta2 <- cbind(rctd_k8_theta, ambig)

# readjust proportions
rctd_k8_theta <- rctd_k8_theta/rowSums(rctd_k8_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_k8_theta[is.na(rctd_k8_theta)] <- 0

summary(rctd_k8_theta)

ggplot(data = reshape2::melt(rctd_k8_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_k8_theta <- rctd_k8_theta[,which(colSums(rctd_k8_theta) > 0)]
rctd_k8_theta2 <- rctd_k8_theta2[,which(colSums(rctd_k8_theta2) > 0)]

```

```{r}

# breg_theta <- RCTD_FN7_results_norm
breg_theta <- rctd_k8_theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots)
  raw_RMSE_rctd_8cts_spots <- c(raw_RMSE_rctd_8cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots_adj)
  raw_RMSE_rctd_8cts_spots_adj <- c(raw_RMSE_rctd_8cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots_cosine)
  raw_RMSE_rctd_8cts_spots_cosine <- c(raw_RMSE_rctd_8cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_8cts_cosine) <- colnames(truth_theta)

# # ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_8cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_8cts_spots)
#   scaled_RMSE_rctd_8cts_spots <- c(scaled_RMSE_rctd_8cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_8cts) <- colnames(truth_theta)

```

### 75 cts

similar to LDA, remove cells less than 2.5%

```{r}

rctd_k75_theta <- as.matrix(RCTD_FN7_neuro_results_norm)
rctd_k75_theta[rctd_k75_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
ambig <- 1 - rowSums(rctd_k75_theta)
rctd_k75_theta2 <- cbind(rctd_k75_theta, ambig)

# readjust proportions
rctd_k75_theta <- rctd_k75_theta/rowSums(rctd_k75_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_k75_theta[is.na(rctd_k75_theta)] <- 0

summary(rctd_k75_theta)

ggplot(data = reshape2::melt(rctd_k75_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_k75_theta <- rctd_k75_theta[,which(colSums(rctd_k75_theta) > 0)]
rctd_k75_theta2 <- rctd_k75_theta2[,which(colSums(rctd_k75_theta2) > 0)]

```

```{r}

# breg_theta <- RCTD_FN7_neuro_results_norm # 3070 and 73 cts
breg_theta <- rctd_k75_theta
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots)
  raw_RMSE_rctd_75cts_spots <- c(raw_RMSE_rctd_75cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_75cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots_adj)
  raw_RMSE_rctd_75cts_spots_adj <- c(raw_RMSE_rctd_75cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots_cosine)
  raw_RMSE_rctd_75cts_spots_cosine <- c(raw_RMSE_rctd_75cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_75cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_75cts_cosine) <- colnames(truth_theta)

# # ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_75cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_75cts_spots)
#   scaled_RMSE_rctd_75cts_spots <- c(scaled_RMSE_rctd_75cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_75cts) <- colnames(truth_theta)

```

## LDA

### 8 cts

```{r}

# breg_theta <- FN7_K8$theta
breg_theta <- lda_k8_theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                    m2 = breg_gt_theta,
                                    type = "t"))

# reorder the predicted topics to match their paired cell type
# rows are spots and columns are topics
# `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
predict_theta <- breg_theta[,theta_pairs$rowix]
# the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
truth_theta <- breg_gt_theta[,theta_pairs$colsix]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
colnames(p_raw) <- colnames(t_raw)
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_lda_8cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_lda_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_lda_8cts_nrmse <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_lda_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_lda_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_lda_8cts_cosine <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_lda_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_lda_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_lda_8cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_lda_8cts) <- colnames(truth_theta)

```

### 75 cts

```{r}

# breg_theta <- FN7_K75$theta
breg_theta <- lda_k75_theta
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                    m2 = breg_gt_theta,
                                    type = "t"))
# reorder the predicted topics to match their paired cell type
# rows are spots and columns are topics
# `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
predict_theta <- breg_theta[,theta_pairs$rowix]
# the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
truth_theta <- breg_gt_theta[,theta_pairs$colsix]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
colnames(p_raw) <- colnames(t_raw)
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_lda_75cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_lda_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_lda_75cts_nrmse <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_lda_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_lda_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_lda_75cts_cosine <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_lda_75cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_lda_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_lda_75cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_lda_75cts) <- colnames(truth_theta)

```

## SL no neuronal

### Remove Excitatory and Inhibitory

```{r}

# # dim(bregmaCellsGexpFN7)
# # 
# # # for equal comparison, use the same cells that were kept in the simulated spots
# # bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simFN7$annotDf),]
# dim(bregmaCellsGexpFN7_filt)
# 
# # remove neuronal cells
# simFN7_nonNeuroCells <- simFN7$annotDf[which(!simFN7$annotDf$Cell_class %in% c("Excitatory", "Inhibitory")),]
# bregmaCellsGexpFN7_noNeuro <- bregmaCellsGexpFN7_filt[rownames(simFN7_nonNeuroCells),]
# dim(bregmaCellsGexpFN7_noNeuro)
# 
# # "scRNAseq" reference using all the cells:
# bregmaFN7FullSeur_noNeuro <- CreateSeuratObject(counts = t(bregmaCellsGexpFN7_noNeuro), project = "bregmaFull scRNAseq no neuro Ref")
# 
# # add cell class labels to the meta.data for assigning clusters later
# bregmaFN7FullSeur_noNeuro[["Major_class"]] <- simFN7_nonNeuroCells$Cell_class

```

### SL 

```{r}

# Set the known clusters as the "active.indent"
# Seurat::Idents(object = bregmaFN7FullSeur_noNeuro) <- bregmaFN7FullSeur_noNeuro@meta.data$Major_class
# 
# levels(bregmaFN7FullSeur_noNeuro@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

# bregmaFN7FullSeur_noNeuro_markers <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur_noNeuro,
#                                               assay = "RNA",
#                                               slot = "data", # counts or data are identical in this case
#                                               verbose = TRUE,
#                                               only.pos = TRUE)

```

```{r}

# set.seed(888)
# 
# SL_bregmaFN7FullSeur_noNeuro_fit <- spotlight_deconvolution(
#   se_sc = bregmaFN7FullSeur_noNeuro,
#   counts_spatial = t(as.matrix(simFN7$sim)),
#   clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
#   cluster_markers = bregmaFN7FullSeur_noNeuro_markers, # Dataframe with the marker genes
#   cl_n = 100, # number of cells per cell type to use
#   hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
#   ntop = NULL, # How many of the marker genes to use (by default all)
#   transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
#   method = "nsNMF", # Factorization method
#   min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
#   )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

Because no neuronal cell, only 6 major cell types to consider. But set predictions of the "Excitatory" and "Inhibitory" to 0 and compare to the ground truth ref that has them. The idea is that they are there but the model didn't detect them.

```{r}

sl_FN7_noNeuro <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur_noNeuro_fit[[1]], stCounts = t(as.matrix(simFN7$sim)))

```

similar to LDA, remove cells less than 2.5%

```{r}

sl_noNeuro_theta <- sl_FN7_noNeuro$thetaCt
sl_noNeuro_theta[sl_noNeuro_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
ambig <- 1 - rowSums(sl_noNeuro_theta)
sl_noNeuro_theta2 <- cbind(sl_noNeuro_theta, ambig)

# readjust proportions
sl_noNeuro_theta <- sl_noNeuro_theta/rowSums(sl_noNeuro_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_noNeuro_theta[is.na(sl_noNeuro_theta)] <- 0

summary(sl_noNeuro_theta)

ggplot(data = reshape2::melt(sl_noNeuro_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_noNeuro_theta <- sl_noNeuro_theta[,which(colSums(sl_noNeuro_theta) > 0)]
sl_noNeuro_theta2 <- sl_noNeuro_theta2[,which(colSums(sl_noNeuro_theta2) > 0)]

```

### rmse

```{r}

# breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_theta <- sl_noNeuro_theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# add in neuronal cts to predicted theta matrix
breg_theta <- cbind(breg_theta, rep(0,nrow(breg_theta)), rep(0,nrow(breg_theta)))
colnames(breg_theta)[7:8] <- c("Excitatory", "Inhibitory")

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_noNeur_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_sl_noNeur_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_noNeur_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_noNeur_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_noNeur_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_noNeur_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_noNeur_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # because all 0's for neuronal, returns NAs. Convert to 0
# predict_theta[is.na(predict_theta)] <- 0
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_noNeur_8cts) <- colnames(truth_theta)

```

## RCTD no neuronal

reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_noNeuro_ref/"

ref <- bregmaFN7FullSeur_noNeuro

meta_ref <- ref@meta.data[,c("Major_class", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

data sets

same full simFN7$sim as before

fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_noNeuro_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

### RCTD

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7_noNeuro <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_noNeuro_fit <- RCTD::run.RCTD(RCTD_FN7_noNeuro, doublet_mode = TRUE)

RCTD_FN7_noNeuro_results <- RCTD_FN7_noNeuro_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_noNeuro_results_norm <-  sweep(RCTD_FN7_noNeuro_results$weights, 1, rowSums(RCTD_FN7_noNeuro_results$weights), '/')

```

similar to LDA, remove cells less than 2.5%

```{r}

rctd_noNeuro_theta <- as.matrix(RCTD_FN7_noNeuro_results_norm)
rctd_noNeuro_theta[rctd_noNeuro_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
ambig <- 1 - rowSums(rctd_noNeuro_theta)
rctd_noNeuro_theta2 <- cbind(rctd_noNeuro_theta, ambig)

# readjust proportions
rctd_noNeuro_theta <- rctd_noNeuro_theta/rowSums(rctd_noNeuro_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_noNeuro_theta[is.na(rctd_noNeuro_theta)] <- 0

summary(rctd_noNeuro_theta)

ggplot(data = reshape2::melt(rctd_noNeuro_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_noNeuro_theta <- rctd_noNeuro_theta[,which(colSums(rctd_noNeuro_theta) > 0)]
rctd_noNeuro_theta2 <- rctd_noNeuro_theta2[,which(colSums(rctd_noNeuro_theta2) > 0)]

```

### rmse

```{r}

# breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_theta <- rctd_noNeuro_theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# add in neuronal cts to predicted theta matrix
breg_theta <- cbind(breg_theta, rep(0,nrow(breg_theta)), rep(0,nrow(breg_theta)))
colnames(breg_theta)[7:8] <- c("Excitatory", "Inhibitory")

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots)
  raw_RMSE_rctd_noNeur_8cts_spots <- c(raw_RMSE_rctd_noNeur_8cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_noNeur_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_noNeur_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_noNeur_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_noNeur_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots_adj)
  raw_RMSE_rctd_noNeur_8cts_spots_adj <- c(raw_RMSE_rctd_noNeur_8cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_noNeur_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots_cosine)
  raw_RMSE_rctd_noNeur_8cts_spots_cosine <- c(raw_RMSE_rctd_noNeur_8cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_noNeur_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_noNeur_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # because all 0's for neuronal, returns NAs. Convert to 0
# predict_theta[is.na(predict_theta)] <- 0
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_noNeur_8cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_noNeur_8cts_spots)
#   scaled_RMSE_rctd_noNeur_8cts_spots <- c(scaled_RMSE_rctd_noNeur_8cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_noNeur_8cts) <- colnames(truth_theta)

```

## ----------------------------------
## Compare across spots

Spots:
raw_RMSE_sl_8cts_spots
raw_RMSE_rctd_8cts_spots
raw_RMSE_lda_8cts_spots
raw_RMSE_sl_noNeur_8cts_spots
raw_RMSE_rctd_noNeur_8cts_spots

raw_RMSE_sl_75cts_spots
raw_RMSE_rctd_75cts_spots
raw_RMSE_lda_75cts_spots
raw_RMSE_sl_noNeur_8cts_spots
raw_RMSE_rctd_noNeur_8cts_spots

scaled_RMSE_sl_8cts_spots
scaled_RMSE_rctd_8cts_spots
scaled_RMSE_lda_8cts_spots
scaled_RMSE_sl_noNeur_8cts_spots
scaled_RMSE_rctd_noNeur_8cts_spots

scaled_RMSE_sl_75cts_spots
scaled_RMSE_rctd_75cts_spots
scaled_RMSE_lda_75cts_spots
scaled_RMSE_sl_noNeur_8cts_spots
scaled_RMSE_rctd_noNeur_8cts_spots

### 8

```{r}

raw_8cts <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots),
                        "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
summary(raw_8cts)
write.csv(summary(raw_8cts), paste0(fig_path, "rmse_raw_8cts.csv"))

raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots)
                        )

ggplot(data = reshape2::melt(raw_8cts),
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none") +
ggplot2::ggsave(filename = paste0("1_100um_8cts_RMSE_lda_sl_rctd.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight\nmissing neuronals" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD\nmissing neuronals" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))

dat <- reshape2::melt(raw_8cts)

dat$variable <- factor(dat$variable)
levels(dat$variable) <- c('STdeconvolve', 'SPOTlight\nmissing neuronals', 'RCTD\nmissing neuronals')

ggplot(data = dat,
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none") +
ggplot2::ggsave(filename = paste0("1_100um_8cts_RMSE_lda_sl_rctd_noNeuros.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)


raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                       "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots),
                        "SPOTlight\nmissing neuronals" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD\nmissing neuronals" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))

dat <- reshape2::melt(raw_8cts)

dat$variable <- factor(dat$variable)
levels(dat$variable) <- c('STdeconvolve', 'SPOTlight', 'RCTD', 'SPOTlight\nmissing neuronals', 'RCTD\nmissing neuronals')

ggplot(data = dat,
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none") +
ggplot2::ggsave(filename = paste0("1_100um_8cts_RMSE_lda_sl_rctd_noNeuros_all.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 8,
         height = 4,
         units = c("in"),
         dpi = 300)

# -----------------------------------------------------------------------------

# raw_8cts_adj <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_adj),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# summary(raw_8cts_adj)
# write.csv(summary(raw_8cts_adj), paste0(fig_path, "rmse_raw_8cts_adj.csv"))
# 
# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_adj)
#                         )
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots; sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)
# 
# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_8cts_cosine <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_cosine),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# summary(raw_8cts_cosine)
# write.csv(summary(raw_8cts_cosine), paste0(fig_path, "rmse_raw_8cts_cosine.csv"))
# 
# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_cosine)
#                         )
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots; cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)
# 
# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

```

### 75

```{r}

raw_75cts <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots),
                        "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots),
                        "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
summary(raw_75cts)
write.csv(summary(raw_75cts), paste0(fig_path, "rmse_raw_75cts.csv"))

raw_75cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots),
                        "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots)
                        )

ggplot(data = reshape2::melt(raw_75cts),
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels\n100 micron pixels, 75 cell-types",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=10),
        legend.position = "none")
ggplot2::ggsave(filename = paste0("1_100um_75cts_RMSE_lda_sl_rctd.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

# raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
# 
# ggplot(data = reshape2::melt(raw_8cts),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots",
#        x = "Method", y = "RMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_75cts_adj <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_adj),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# summary(raw_75cts_adj)
# write.csv(summary(raw_75cts_adj), paste0(fig_path, "rmse_raw_75cts_adj.csv"))
# 
# raw_75cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_adj),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_adj)
#                         )
# 
# ggplot(data = reshape2::melt(raw_75cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-subtype predictions in FN7 spots; sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, sd adj",
#        x = "Method", y = "RMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_75cts_cosine <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_cosine),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# summary(raw_75cts_cosine)
# write.csv(summary(raw_75cts_cosine), paste0(fig_path, "rmse_raw_75cts_cosine.csv"))
# 
# raw_75cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_cosine),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_cosine)
#                         )
# 
# ggplot(data = reshape2::melt(raw_75cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-subtype predictions in FN7 spots; cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

```

rmse differ between 8 and 75 because proportions of the 75 cts are much smaller

but comparing cell-type to cell-type should normalize before comparing

## ----------------------------------
## Compare across cell types

cts:
raw_RMSE_sl_8cts
raw_RMSE_rctd_8cts
raw_RMSE_lda_8cts
raw_RMSE_sl_noNeur_8cts
raw_RMSE_rctd_noNeur_8cts

raw_RMSE_sl_75cts
raw_RMSE_rctd_75cts
raw_RMSE_lda_75cts
raw_RMSE_sl_noNeur_8cts
raw_RMSE_rctd_noNeur_8cts

scaled_RMSE_sl_8cts
scaled_RMSE_rctd_8cts
scaled_RMSE_lda_8cts
scaled_RMSE_sl_noNeur_8cts
scaled_RMSE_rctd_noNeur_8cts

scaled_RMSE_sl_75cts
scaled_RMSE_rctd_75cts
scaled_RMSE_lda_75cts
scaled_RMSE_sl_noNeur_8cts
scaled_RMSE_rctd_noNeur_8cts

### 8

#### raw rmse

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion, # overall proportion in ground truth dataset
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary <- do.call("rbind", list(raw_RMSE_sl_8cts_df,
                                                  raw_RMSE_rctd_8cts_df,
                                                  raw_RMSE_lda_8cts_df,
                                                  raw_RMSE_sl_noNeur_8cts_df,
                                                  raw_RMSE_rctd_noNeur_8cts_df))

```

#### scaled rmse

```{r}

l_eachCt <- scaled_RMSE_sl_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_sl_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_rctd_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_rctd_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_lda_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_lda_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_sl_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight No Neuro", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_sl_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_rctd_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD No Neuro", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_rctd_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_scaled_ct_rmse_summary <- do.call("rbind", list(scaled_RMSE_sl_8cts_df,
                                                  scaled_RMSE_rctd_8cts_df,
                                                  scaled_RMSE_lda_8cts_df,
                                                  scaled_RMSE_sl_noNeur_8cts_df,
                                                  scaled_RMSE_rctd_noNeur_8cts_df))

```

#### raw NRMSE

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary_nrmse <- do.call("rbind", list(raw_RMSE_sl_8cts_df_nrmse,
                                                  raw_RMSE_rctd_8cts_df_nrmse,
                                                  raw_RMSE_lda_8cts_df_nrmse,
                                                  raw_RMSE_sl_noNeur_8cts_df_nrmse,
                                                  raw_RMSE_rctd_noNeur_8cts_df_nrmse))

```

#### Cosine

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary_cosine <- do.call("rbind", list(raw_RMSE_sl_8cts_df_cosine,
                                                  raw_RMSE_rctd_8cts_df_cosine,
                                                  raw_RMSE_lda_8cts_df_cosine,
                                                  raw_RMSE_sl_noNeur_8cts_df_cosine,
                                                  raw_RMSE_rctd_noNeur_8cts_df_cosine))

```

### 75

#### raw rmse

```{r}

l_eachCt <- raw_RMSE_sl_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary <- do.call("rbind", list(raw_RMSE_sl_75cts_df,
                                                  raw_RMSE_rctd_75cts_df,
                                                  raw_RMSE_lda_75cts_df))

```

#### scaled rmse

```{r}

l_eachCt <- scaled_RMSE_sl_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_sl_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_rctd_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_rctd_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- scaled_RMSE_lda_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Scaled", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

scaled_RMSE_lda_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_scaled_ct_rmse_summary <- do.call("rbind", list(scaled_RMSE_sl_75cts_df,
                                                  scaled_RMSE_rctd_75cts_df,
                                                  scaled_RMSE_lda_75cts_df))

```

#### raw NRMSE

```{r}

l_eachCt <- raw_RMSE_sl_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary_nrmse <- do.call("rbind", list(raw_RMSE_sl_75cts_df_nrmse,
                                                  raw_RMSE_rctd_75cts_df_nrmse,
                                                  raw_RMSE_lda_75cts_df_nrmse))

```

#### Cosine

```{r}

l_eachCt <- raw_RMSE_sl_75cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary_cosine <- do.call("rbind", list(raw_RMSE_sl_75cts_df_cosine,
                                                  raw_RMSE_rctd_75cts_df_cosine,
                                                  raw_RMSE_lda_75cts_df_cosine))

```

### visualize

k8_raw_ct_rmse_summary
k8_scaled_ct_rmse_summary
k75_raw_ct_rmse_summary
k75_scaled_ct_rmse_summary

```{r, fig.height=4, fig.width=10}

ggplot(data = k8_raw_ct_rmse_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 8 cell-type predictions by method",
       x = "Method", y = "RMSE")

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 8 cell-type predictions by method",
       x = "Method", y = "NRMSE")

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 8 cell-type predictions by method",
       x = "Method", y = "Cosine Similarity")

```

The RMSE above is the proportion for each cell type. In general could compare ct to ct but note that for some cts that have lower proportions overall like OD and pericytes, the RMSE not really comparable because it will be lower as their proportion is lower.

Microglia is the one major CT where LDA has some trouble compared to the other methods. LDA does better for Excitatory than other methods. Removal of Neuronal cells causes RCTD to struggle with Astrocytes. SPOTlight also has trouble with Microglia.

```{r, fig.height=16, fig.width=10}

ggplot(data = k75_raw_ct_rmse_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "RMSE")

ggplot(data = k75_raw_ct_rmse_summary_nrmse, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "NRMSE")

ggplot(data = k75_raw_ct_rmse_summary_cosine, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "Cosine Similarity")

```

Looking closer, SPOTlight also does worse with ODs. LDA does well for Inhibatory subtypes - sometimes better than RCTD and SPOTlight


Proportion = overall proportion in ground truth dataset

#### 8 cell-types each method

```{r, fig.height=6, fig.width=12}

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 8 cell-types", y = "Normalized RMSE",
       x = "proportion in ground truth dataset") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_8cts_NRMSE_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 8 cell-types", y = "Normalized RMSE",
       x = "Pixel proportion std") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_8cts_NRMSE_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

## ----------------------------------------------------------------

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 8 cell-types", y = "Cosine Similarity",
       x = "proportion in ground truth dataset") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_8cts_Cosine_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 8 cell-types", y = "Cosine Similarity",
       x = "Pixel proportion std") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_8cts_Cosine_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

```

STdeconvolve and SPOTlight in general do worse for cts at overall lower proportions.

```{r, fig.height=6, fig.width=16}

ggplot(data = k75_raw_ct_rmse_summary, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "RMSE")

ggplot(data = k75_scaled_ct_rmse_summary, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "Scaled RMSE")

ggplot(data = k75_raw_ct_rmse_summary_nrmse, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "NRMSE")

ggplot(data = k75_raw_ct_rmse_summary_cosine, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "Cosine Similarity")

```

```{r}

k75_raw_ct_rmse_summary_nrmse[k75_raw_ct_rmse_summary_nrmse$Cell.type != "I-39",]

```

#### 75 cell-types each method

```{r, fig.height=4, fig.width=12}

# only 1 I-39 cell in ref. Inflates the NRMSE. Remove
dat <- k75_raw_ct_rmse_summary_nrmse[k75_raw_ct_rmse_summary_nrmse$Cell.type != "I-39",]

ggplot(data = dat, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 75 cell-types", y = "Normalized RMSE",
       x = "proportion of ground truth dataset") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("2_100um_75cts_NRMSE_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = dat, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 75 cell-types", y = "Normalized RMSE",
       x = "pixel proportion std") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("2_100um_75cts_NRMSE_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

## ----------------------------------------------------------------

dat <- k75_raw_ct_rmse_summary_cosine[k75_raw_ct_rmse_summary_cosine$Cell.type != "I-39",]

ggplot(data = dat, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 75 cell-types", y = "Cosine Similarity",
       x = "proportion of ground truth dataset") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("2_100um_75cts_Cosine_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = dat, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 75 cell-types", y = "Cosine Similarity",
       x = "pixel proportion std") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("2_100um_75cts_Cosine_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

```


In general the trend is that at higher proportions each method has an easier time deconvolving cell types. But for rare neuronal subtypes, it is highly variable depending on subtype. Might be because the MERFISH genes were marker genes so in theory should be able to ID the subtypes. Of course some are probably similar and thus become more difficult to ID.



























