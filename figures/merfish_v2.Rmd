---
title: "Untitled"
author: "Brendan F. Miller"
date: "3/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

# all of the trained models for merfish:
# save(bregmaCellsGexpFN7, # 59651 cells in FN7 bregmas x 125 gene counts (blanks removed and ambiguous cells removed)
#       bregmaCellsGexpFN7_filt, # above but only cells kept in simulated patches (49142)
#       gtCtGenesFN7, # reference for 8 major cell types and 125 genes. relative average expression. Used all 59651 cells
#       gtCtNeuronalGenesFN7, # same as above but expanded into neuronal cts so 75 types
#       FN7, # hash table storing each simulated bregma in FN7. Built such that cellTypeTable is for 8 major cts
#       FN7_neuro, # same as above but with all cts
#       bregmaFN7FullSeur, # seurat object of the 49142 cells in patches. Meta data has all major and neuronal cts
#       bregmaFN7FullSeur_noNeuro, # 21652 non-neuronal cells also in patches
#       simBregmasFN7, # list of bregma corpuses and gt for each bregma in FN7
#       simBregmasFN7_neuro, # list of bregma corpuses and gt for each bregma in FN7_neuro
#       simFN7, # same as `simBregmasFN7` but all combined into single "bregma" corpus
#       simFN7_neuro, # same as `simBregmasFN7_neuro` but all combined into single "bregma" corpus. sim in both simFN7 and simFN7_neuro the same
#       FN7_K8, # LDA model K=8 and trained on simFN7 (entire FN7 animal)
#       FN7_K75, # LDA model K=75 and trained on simFN7 (entire FN7 animal)
#       bregmaFN7FullSeur_markers8cts, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur
#       bregmaFN7FullSeur_markers75neurocts, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur using all classes
#       bregmaFN7FullSeur_noNeuro_markers, # ct markers with Seurat::FindAllMarkers(object = bregmaFN7FullSeur_noNeuro 6 major cts
#       SL_bregmaFN7FullSeur8cts_fit, # SL deconvolve model using full `FN7`, `bregmaCellsGexpFN7`, and 8 major ct markers
#       SL_bregmaFN7FullSeur75neurocts_fit, # SL deconvolve model using full `simFN7_neuro`, `bregmaCellsGexpFN7`, and 75 major ct markers
#       RCTD_FN7_results_norm, # 3070 spots and 8 cts deconvolved with RCTD using bregmaCellsGexpFN7 ref with major classes
#       RCTD_FN7_neuro_results_norm, # 3070 spots and 73 cts deconvolved with RCTD using bregmaCellsGexpFN7 ref with All classes
#       SL_bregmaFN7FullSeur_noNeuro_fit, # SL deconvolve using `bregmaFN7FullSeur_noNeuro` (21652 cells) and noNeuro markers for 6 cts
#       RCTD_FN7_noNeuro_results_norm, # 3070 spots and 6 cts deconvovled with RCTD using `bregmaFN7FullSeur_noNeuro` 
#       file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/merfish_fitted_models.RData")

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/merfish_fitted_models.RData")

```

```{r}
fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/figures/merfish/"
draft_fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_figures/"
```

```{r}
fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/figures/pdfs/"
```

# Data and gexp references

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mpoa_merfish_clean2.RData") # note that clean2 newest and 135 genes
# has `annot.table`, `counts`, and `features` objects

# annot.table: table of the individual cells and data like coordinates, cell types, bregma, animal
# features: has cells and additional features. Also dataset they belong to
# counts: gene counts of cell in annot.table for 130 merfish genes profiled

# unique(features$dataset_name)
#  [1] "170908_FN3_2_M22_M26"    "170917_MN1_1pp_M22_M26" 
#  [3] "170919_FN4_1_M22_M26"    "170921_FN4_2_M22_M26"   
#  [5] "170923_FN4_1pp_M22_M26"  "170925_MN2_1p_M22_M26"  
#  [7] "171021_FN7_2_M22_M26"    "171023_FN7_1_M22_M26"   
#  [9] "171024_MN5_2p_M22_M26"   "171027_MN5_1p_M22_M26"  
# [11] "171104_MN6_2_M22_M26"    "171112_MN8_2pppp"       
# [13] "171114_MN8_M22_M26_2pp"  "171208_MN9_2ppp_M22_M26"
# [15] "171118_BD3_1pp"          "171119_BD5_1pp"         
# [17] "171121_BD5_1"            "171123_BD5_2p"          
# [19] "171124_BD6_2ppp"         "171126_BD6_1pppp"       
# [21] "171128_BD7_1ppp"         "171129_BD7_1ppp_actual" 
# [23] "171201_BD_2ppp"          "171203_BD8_1pp"         
# [25] "171210_BD9_1pp"          "171211_BD9_2ppp_M22_M26"
# [27] "171214_BD10_2_M22_M26"   "171216_BD11_1_M22_M26"  
# [29] "171217_BD11_2_M22_M26"   "171219_BD12_1p_M22_M26" 
# [31] "171221_BD12_2p_M22_M26"  "171223_BD13_2p_M22_M26" 

```

```{r}
dim(counts)
dim(counts[,!grepl("Blank", colnames(counts))])
```


171021_FN7_2_M22_M26 (anterior) and 171023_FN7_1_M22_M26 (posterior)

generate `spatial_position_and_class_FN7` and `bregmaCellsGexpFN7`

```{r}

# select cells that are part of given data set:
selected_cells_FN7 <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26', "171023_FN7_1_M22_M26")]

spatial_position_and_class_FN7 <- annot.table[selected_cells_FN7,
                                          c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]

# remove rows with NA
spatial_position_and_class_FN7 <- na.omit(spatial_position_and_class_FN7) 

```

```{r}

# reduce set of major cell class labels. Convert OD types to "OD Mature" and "OD Immature" so will be 9 cts total
# "Endothelial types to "Endothelial"

# spatial_position_and_class_FN7[grep(pattern = "OD",
#                                 x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD"

spatial_position_and_class_FN7[grep(pattern = "OD Mature",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD Mature"

spatial_position_and_class_FN7[grep(pattern = "OD Immature",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD Immature"

spatial_position_and_class_FN7[grep(pattern = "Endothelial",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "Endothelial"

# Remove Ambiguous cell type:
spatial_position_and_class_FN7 <- spatial_position_and_class_FN7[which(!spatial_position_and_class_FN7$Cell_class == "Ambiguous"),]

dim(spatial_position_and_class_FN7)
# [1] 59651     5

# gene counts for individual cells
bregmaCellsGexpFN7 <- counts[rownames(spatial_position_and_class_FN7),]

# remove "Blanks" from data
bregmaCellsGexpFN7 <- bregmaCellsGexpFN7[,!grepl("Blank", colnames(bregmaCellsGexpFN7))]

```

```{r}

# to expand to neuronal subtypes, make a secondary vector of "Cell_class" where
# "Excititory and "Inhibitory" are replaces with the respective "Neuron_cluster_ID"

Cell_class_major_FN7 <- spatial_position_and_class_FN7$Cell_class

Cell_class_with_neuronal_FN7 <- unlist(lapply(rownames(spatial_position_and_class_FN7), function(cell){
  class <- spatial_position_and_class_FN7[cell,]$Cell_class
  neuron <- spatial_position_and_class_FN7[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

length(Cell_class_with_neuronal_FN7)

```

Gexp ground truths:

Let's make a gexp reference using all the cells across the bregmas.

cell types
```{r}

cellTypes <- Cell_class_major_FN7
cells <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtGenes <- gtCtGenes[,!grepl("Blank", colnames(gtCtGenes))]
gtCtGenesFN7 <- gtCtGenesFN7/rowSums(gtCtGenesFN7)

dim(gtCtGenesFN7)

```

cell neuronal subtypes
```{r}

cellTypes <- Cell_class_with_neuronal_FN7
cells <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtNeuronalGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtNeuronalGenes <- gtCtNeuronalGenes[,!grepl("Blank", colnames(gtCtNeuronalGenes))]
gtCtNeuronalGenesFN7 <- gtCtNeuronalGenesFN7/rowSums(gtCtNeuronalGenesFN7)

dim(gtCtNeuronalGenesFN7)

```

Next generate the simulated ST spots at different resolutions. Each simulation also record the ground truth pixel proprotions as well.

# Simulations

## 100um Sim

this generates the hash tables of simulated spots for each bregma separately
```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                counts = bregmaCellsGexpFN7,
                                patch_size = 100)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 100)

```

Tables of counts of cell-types in each spot for entire FN7 animal (100um2)

```{r}

# table of number of cell types in each spot for entire FN7

# spot IDs for all spots in FN7
FN7_spotIDs <- unlist(lapply(hash::keys(FN7_hash), function(ix){
  # table to df
  rownames(FN7_hash[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_cellTypeTable <- lapply(hash::keys(FN7_hash), function(ix){
  # table to df
  as.data.frame.matrix(FN7_hash[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_cellTypeTable <- data.table::rbindlist(FN7_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_cellTypeTable[is.na(FN7_cellTypeTable)] <- 0

# spot IDs as row names
FN7_cellTypeTable <- as.matrix(FN7_cellTypeTable)
rownames(FN7_cellTypeTable) <- FN7_spotIDs

```

Tables of counts of cell-types and neuronal cell-types in each spot for entire FN7 animal (100um2)

```{r}

# spot IDs
FN7_neuro_spotIDs <- unlist(lapply(hash::keys(FN7_neuro_hash), function(ix){
  # table to df
  rownames(FN7_neuro_hash[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_neuro_cellTypeTable <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  # table to df
  as.data.frame.matrix(FN7_neuro_hash[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_neuro_cellTypeTable <- data.table::rbindlist(FN7_neuro_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_neuro_cellTypeTable[is.na(FN7_neuro_cellTypeTable)] <- 0

# spot IDs as row names
FN7_neuro_cellTypeTable <- as.matrix(FN7_neuro_cellTypeTable)
rownames(FN7_neuro_cellTypeTable) <- FN7_neuro_spotIDs

```

Generation of each simulated corpus for each bregma:

```{r}

simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)

```

Recall that the `$gtSpotTopics` of each simulated corpus are of primary interest to compare the fitted models to for each bregma.

The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches and so should be ignored if looking at the entire animal.

Combine the simulated bregmas in the `simBregma` lists to make a single corpus for all bregmas to train a single model.
The `gtSpotTopics` can be combined as well for a ground truth reference, but each `gtCtGenes` is built using just the cells in each given bregma. So instead use the `gtCtGenesFN7` or `gtCtNeuronalGenesFN7`, which were average gexp for cell types across all cells.


Combine the simulated matrices for each bregma into one corpus:

Major cell types

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7 <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)

```

Neuronal subtypes

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```

### ---------------
### save simulations

Simulations generated for the following combos:
 clean_counts or clean_counts2: one ends up with 125 genes, and the other 135, which is actually more correct of the dataset
 and combining oligodendrocytes into single cell-type for 8 cell types and 75 subtypes
 or splitting into OD Mature and Immature for 9 cell types and 76 subtypes

```{r}

# simFN7_9ct_135genes <- simFN7
# simFN7_9ct_125genes <- simFN7
# simFN7_8ct_135genes <- simFN7
# simFN7_8ct_125genes <- simFN7
# simFN7_neuro_9ct_135genes <- simFN7_neuro
# simFN7_neuro_9ct_125genes <- simFN7_neuro
# simFN7_neuro_8ct_135genes <- simFN7_neuro
# simFN7_neuro_8ct_125genes <- simFN7_neuro

```

```{r}

print("135 genes and 9 cell-types")
simFN7_9ct_135genes$sim
dim(simFN7_9ct_135genes$gtSpotTopics)
dim(simFN7_9ct_135genes$gtCtGenes)
print(" ")
print("135 genes and 8 cell-types")
simFN7_8ct_135genes$sim
dim(simFN7_8ct_135genes$gtSpotTopics)
dim(simFN7_8ct_135genes$gtCtGenes)
print(" ")
print("125 genes and 9 cell-types")
simFN7_9ct_125genes$sim
dim(simFN7_9ct_125genes$gtSpotTopics)
dim(simFN7_9ct_125genes$gtCtGenes)
print(" ")
print("125 genes and 8 cell-types")
simFN7_8ct_125genes$sim
dim(simFN7_8ct_125genes$gtSpotTopics)
dim(simFN7_8ct_125genes$gtCtGenes)
print(" ")
print("Neuronal subtypes")
print(" ")
print("135 genes and 9 cell-types")
simFN7_neuro_9ct_135genes$sim
dim(simFN7_neuro_9ct_135genes$gtSpotTopics)
dim(simFN7_neuro_9ct_135genes$gtCtGenes)
print(" ")
print("135 genes and 8 cell-types")
simFN7_neuro_8ct_135genes$sim
dim(simFN7_neuro_8ct_135genes$gtSpotTopics)
dim(simFN7_neuro_8ct_135genes$gtCtGenes)
print(" ")
print("125 genes and 9 cell-types")
simFN7_neuro_9ct_125genes$sim
dim(simFN7_neuro_9ct_125genes$gtSpotTopics)
dim(simFN7_neuro_9ct_125genes$gtCtGenes)
print(" ")
print("125 genes and 8 cell-types")
simFN7_neuro_8ct_125genes$sim
dim(simFN7_neuro_8ct_125genes$gtSpotTopics)
dim(simFN7_neuro_8ct_125genes$gtCtGenes)
```

### seurat inputs

```{r}

## use filtered counts from `clean_counts`, which has the 135 genes and 59651 cells in the 12 bregmas after removing ambiguous cells
dim(bregmaCellsGexpFN7)

```

8 cell-ypes and 125 genes:
```{r}

simulation <- simFN7_8ct_125genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_8ct_125genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 8ct 125 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_8ct_125genes[["Major_class"]] <- simFN7_8ct_125genes$annotDf$Cell_class
bregmaFN7FullSeur_8ct_125genes[["All_classes"]] <- simFN7_neuro_8ct_125genes$annotDf$Cell_class

```

8 cell-ypes and 135 genes:
```{r}

simulation <- simFN7_8ct_135genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_8ct_135genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 8ct 135 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_8ct_135genes[["Major_class"]] <- simFN7_8ct_135genes$annotDf$Cell_class
bregmaFN7FullSeur_8ct_135genes[["All_classes"]] <- simFN7_neuro_8ct_135genes$annotDf$Cell_class

```

9 cell-ypes and 125 genes:
```{r}

simulation <- simFN7_9ct_125genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_9ct_125genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 9ct 125 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_9ct_125genes[["Major_class"]] <- simFN7_9ct_125genes$annotDf$Cell_class
bregmaFN7FullSeur_9ct_125genes[["All_classes"]] <- simFN7_neuro_9ct_125genes$annotDf$Cell_class

```

9 cell-ypes and 135 genes:
```{r}

simulation <- simFN7_9ct_135genes

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simulation$annotDf),colnames(as.matrix(simulation$sim))]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_9ct_135genes <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 9ct 135 genes")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_9ct_135genes[["Major_class"]] <- simFN7_9ct_135genes$annotDf$Cell_class
bregmaFN7FullSeur_9ct_135genes[["All_classes"]] <- simFN7_neuro_9ct_135genes$annotDf$Cell_class

```

### save

```{r}

save(simFN7_8ct_125genes, simFN7_8ct_135genes, simFN7_9ct_125genes, simFN7_9ct_135genes,
     simFN7_neuro_8ct_125genes, simFN7_neuro_8ct_135genes, simFN7_neuro_9ct_125genes, simFN7_neuro_9ct_135genes,
      bregmaFN7FullSeur_8ct_125genes, bregmaFN7FullSeur_8ct_135genes, bregmaFN7FullSeur_9ct_125genes, bregmaFN7FullSeur_9ct_135genes,
      file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_v2-simFN7_8-9cts_125-135gene_combos.RData")

```

### ---------------

### pixel overdispersed genes

```{r}

simulation <- simFN7_8ct_135genes

counts <- t(as.matrix(simulation$sim)) # genes x pixels matrix
odGenes <- getOverdispersedGenes(counts,
                                 alpha = 0.05,
                                 plot = TRUE,
                                 details = TRUE,
                                 verbose = TRUE)
countsFilt <- counts[odGenes$ods,]

```

### MERINGUE comparison

for each bregma separately:

```{r}
helper <- function(pos, mat) {
  w <- MERINGUE::getSpatialNeighbors(pos, filterDist = 101)
  plotNetwork(pos, w)
  # get spatially clustered genes
  I <- MERINGUE::getSpatialPatterns(mat, w)
  # filter for significant hits driven by more than 5% of pixels (256*0.05 = 12.8)
  results.filter <- MERINGUE::filterSpatialPatterns(mat = mat,
                                                    I = I,
                                                    w = w,
                                                    adjustPv = TRUE,
                                                    alpha = 0.05,
                                                    minPercentCells = 0.10,
                                                    verbose = TRUE)
  # return results
  list(I=I, sig.genes=results.filter)
}
```

```{r}

## any simulation can be used as the simulated pixels all have the same coordinates
simulation <- simFN7_8ct_135genes

sigSpatialEachBregma <- lapply(names(simBregmasFN7), function(ix){
  ## get bregma information for the given bregma
  breg <- simulation$annotDf[simulation$annotDf$Bregma == ix,]
  ## get pixel coorinates that are in the given bregma
  cellCounts <- simulation$cellCounts[which(rownames(simulation$cellCounts) %in% breg$patch_id),]
  ## get the coordinates of the pixels
  pos <- cellCounts[,c("x", "y")]
  ## the gexp matrix for the pixels (use all 135 genes for now)
  mat <- t(as.matrix(simulation$sim)[rownames(cellCounts),]) # needs to be genes x pixels
  
  helper(pos = pos, mat = mat)
  
})

names(sigSpatialEachBregma) <- names(simBregmasFN7)

```

```{r}

sigSpatialEachBregmaUnion <- Reduce(union, list(sigSpatialEachBregma[["-0.04"]]$sig.genes,
      sigSpatialEachBregma[["-0.09"]]$sig.genes,
      sigSpatialEachBregma[["-0.14"]]$sig.genes,
      sigSpatialEachBregma[["-0.19"]]$sig.genes,
      sigSpatialEachBregma[["-0.24"]]$sig.genes,
      sigSpatialEachBregma[["-0.29"]]$sig.genes,
      sigSpatialEachBregma[["0.01"]]$sig.genes,
      sigSpatialEachBregma[["0.06"]]$sig.genes,
      sigSpatialEachBregma[["0.11"]]$sig.genes,
      sigSpatialEachBregma[["0.16"]]$sig.genes,
      sigSpatialEachBregma[["0.21"]]$sig.genes,
      sigSpatialEachBregma[["0.26"]]$sig.genes))

spatialGenes <- intersect(sigSpatialEachBregmaUnion, cross$sig.genes)
spatialGenes
```

across layers:

first get list of bregma pixel coordinates
```{r}

## any simulation can be used as the simulated pixels all have the same coordinates
simulation <- simFN7_8ct_135genes

mat <- t(as.matrix(simulation$sim))

bregPosListScaled <- lapply(names(simBregmasFN7), function(ix){
  ## get bregma information for the given bregma
  breg <- simulation$annotDf[simulation$annotDf$Bregma == ix,]
  ## get pixel coorinates that are in the given bregma
  cellCounts <- simulation$cellCounts[which(rownames(simulation$cellCounts) %in% breg$patch_id),]
  ## get the coordinates of the pixels
  pos <- cellCounts[,c("x", "y")]
  ## bring to same scale for all bregmas
  pos$x <- scale0_1(pos$x)
  pos$y <- scale0_1(pos$y)
  pos
})
names(bregPosListScaled) <- names(simBregmasFN7)

# K-mutual nearest neighbors across sections
cw <- getCrossLayerNeighbors(bregPosListScaled, k=3)
# Look for genes exhibiting spatial autocorrelation across layers
I <- getSpatialPatterns(mat, cw)
results.filter <- filterSpatialPatterns(mat = mat,
                                        I = I,
                                        w = cw,
                                        adjustPv = TRUE,
                                        alpha = 0.05,
                                        minPercentCells = 0.05,
                                        verbose = TRUE)
cross <- list(I=I, sig.genes=results.filter)

```


## -----------------
## LDA with different corpuses

```{r}

ks <- seq(from = 2, to = 20, by = 1)
ks <- c(ks, seq(from = 30, to = 70, by = 20))
ks <- c(ks, 75, 76)
ks

```

```{r}

# FN7_LDAs_125genes <- fitLDA(counts = as.matrix(simFN7_8ct_125genes$sim),
#                    Ks = ks,
#                    testSize = NULL,
#                    perc.rare.thresh = 0.025,
#                    seed = 0,
#                    ncores = 6,
#                    plot = TRUE)

FN7_LDAs_135genes <- fitLDA(counts = as.matrix(simFN7_8ct_135genes$sim), # same as simFN7_9ct_135genes
                   Ks = ks,
                   testSize = NULL,
                   perc.rare.thresh = 0.025,
                   seed = 0,
                   ncores = 6,
                   plot = TRUE)

FN7_LDAs_105spatialgenes <- fitLDA(counts = as.matrix(simFN7_8ct_135genes$sim)[,spatialGenes],
                   Ks = ks,
                   testSize = NULL,
                   perc.rare.thresh = 0.025,
                   seed = 0,
                   ncores = 6,
                   plot = TRUE)

```

See what it looks like for 5%
```{r}

ks <- seq(from = 2, to = 20, by = 1)
models <- FN7_LDAs_135genes
corpus <- as.matrix(simFN7_8ct_135genes$sim)
perc.rare.thresh <- 0.025

## check number of predicted cell-types at low proportions
out <- lapply(1:length(ks), function(i) {
  apply(getBetaTheta(lda = models$models[[i]], corpus = corpus)$theta, 2, mean)
})

## number of cell-types present at fewer than `perc.rare.thresh` on average across pixels
numrare <- unlist(lapply(out, function(x) sum(x < perc.rare.thresh)))

pScores <- models$perplexities[1:length(ks)]

dat <- data.frame(K = as.double(ks),
                  rareCts = numrare,
                  perplexity = pScores,
                  rareCtsAdj = scale0_1(numrare),
                  perplexAdj = scale0_1(pScores))

prim_ax_labs <- seq(min(dat$rareCts), max(dat$rareCts))
prim_ax_breaks <- scale0_1(prim_ax_labs)
## if number rareCts stays constant, then only one break. scale0_1(prim_ax_labs) would be NaN so change to 0
if(length(prim_ax_labs) == 1){
  prim_ax_breaks <- 0
  ## also the rareCtsAdj <- scale0_1(rareCts) would be NaN, so set to 0, so at same position as the tick,
  ## and its label will still be set to the constant value of rareCts
  dat$rareCtsAdj <- 0
}
if(max(dat$rareCts) < 1){
  sec_ax_labs <- seq(min(dat$perplexity), max(dat$perplexity), (max(dat$perplexity)-min(dat$perplexity))/1)
} else {
  sec_ax_labs <- seq(min(dat$perplexity), max(dat$perplexity), (max(dat$perplexity)-min(dat$perplexity))/max(dat$rareCts))
}
sec_ax_breaks <- scale0_1(sec_ax_labs)

plt <- ggplot2::ggplot(dat, aes(x=K)) +
  ggplot2::geom_line(aes(y=rareCtsAdj), col="blue", lwd = 2) +
  ggplot2::geom_line(aes(y=perplexAdj), col="red", lwd = 2) +
  ggplot2::scale_y_continuous(name=paste0("# cell-types with mean proportion < ", round(perc.rare.thresh*100, 2), "%"), breaks = prim_ax_breaks, labels = prim_ax_labs,
                              sec.axis=sec_axis(~ ., name="perplexity", breaks = sec_ax_breaks, labels = round(sec_ax_labs, 2))) +
  ggplot2::scale_x_continuous(breaks = min(dat$K):max(dat$K)) +
  ggplot2::ggtitle("Fitted model K's vs deconvolved cell-types and perplexity") +
  ggplot2::theme_classic() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(size=15, face=NULL),
    panel.grid.minor = ggplot2::element_blank(),
    panel.grid.major = ggplot2::element_line(color = "black", size = 0.1),
    axis.title.y.left = ggplot2::element_text(color="blue", size = 13),
    axis.text.y.left = ggplot2::element_text(color="blue", size = 13),
    axis.title.y.right = ggplot2::element_text(color="red", size = 15, vjust = 1.5),
    axis.text.y.right = ggplot2::element_text(color="red", size = 13),
    axis.text.x = ggplot2::element_text(angle = 0, size = 13),
    axis.title.x = ggplot2::element_text(size=13)
  )
print(plt)
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-A-lda_perplex_rarect_025-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```


```{r}

FN7_K9_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_135genes, opt = 9),
                         corpus = as.matrix(simFN7_8ct_135genes$sim),
                         deepSplit = 4,
                         colorScheme = "rainbow")

lda_k9_135genes_theta <- FN7_K9_135genes$theta
lda_k9_135genes_theta[lda_k9_135genes_theta < 0.025] <- 0

# readjust proportions
lda_k9_135genes_theta <- lda_k9_135genes_theta/rowSums(lda_k9_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k9_135genes_theta[is.na(lda_k9_135genes_theta)] <- 0

summary(lda_k9_135genes_theta)

ggplot(data = reshape2::melt(lda_k9_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k9_135genes_theta <- lda_k9_135genes_theta[,which(colSums(lda_k9_135genes_theta) > 0)]


# ---------------------------------------------------------------------------
FN7_K9_105spatialgenes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_105spatialgenes, opt = 9),
                         corpus = as.matrix(simFN7_8ct_135genes$sim)[,spatialGenes],
                         deepSplit = 4,
                         colorScheme = "rainbow")

lda_k9_105spatialgenes_theta <- FN7_K9_105spatialgenes$theta
lda_k9_105spatialgenes_theta[lda_k9_105spatialgenes_theta < 0.025] <- 0

# readjust proportions
lda_k9_105spatialgenes_theta <- lda_k9_105spatialgenes_theta/rowSums(lda_k9_105spatialgenes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k9_105spatialgenes_theta[is.na(lda_k9_105spatialgenes_theta)] <- 0

summary(lda_k9_105spatialgenes_theta)

ggplot(data = reshape2::melt(lda_k9_105spatialgenes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k9_105spatialgenes_theta <- lda_k9_105spatialgenes_theta[,which(colSums(lda_k9_105spatialgenes_theta) > 0)]


```

```{r}

FN7_K12_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_135genes, opt = 12),
                         corpus = as.matrix(simFN7_8ct_135genes$sim),
                         deepSplit = 4,
                         colorScheme = "rainbow")

lda_k12_135genes_theta <- FN7_K12_135genes$theta
lda_k12_135genes_theta[lda_k12_135genes_theta < 0.025] <- 0

# readjust proportions
lda_k12_135genes_theta <- lda_k12_135genes_theta/rowSums(lda_k12_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k12_135genes_theta[is.na(lda_k12_135genes_theta)] <- 0

summary(lda_k12_135genes_theta)

ggplot(data = reshape2::melt(lda_k12_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k12_135genes_theta <- lda_k12_135genes_theta[,which(colSums(lda_k12_135genes_theta) > 0)]

```


## save

```{r}

save(FN7_LDAs_135genes, FN7_LDAs_105spatialgenes, file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_v2-135-105spatGene_LDAmodels.RData")

```

# K=9 135 genes

## txn corr gt cts

```{r}

gt <- simFN7_9ct_135genes

clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D", ## ward.D
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  # ggplot2::xlab("Ground truth cell-types") +
  # ggplot2::ylab("Deconvolved cell-types") +
  # ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_9cts_135genes_gt_txn_profile_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```

```{r}

gt <- simFN7_9ct_135genes

clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D", ## ward.D
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)

ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes),
                         m2 = as.matrix(gt$gtCtGenes),
                         type = "b")


pdf(file = paste0(fig_path, "Supplemental_Figure_S2-D-ground_truth_txn_corr-9ct_135genes.pdf"),
    width = 6,
    height = 5)
gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,8))
dev.off()

```

Pair cell-types to ground truth based on txn profiles

```{r}

decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

# # matching up topics to gt cell-types for coloring
# corMtx <- getCorrMtx(m1 = decon$beta, # rows
#                      m2 = as.matrix(gt$gtCtGenes), # cols
#                      type = "b")
# 
# gplots::heatmap.2(x = corMtx,
#                   density.info = "none",
#                   trace = "none",
#                   # Rowv = clust$dendro,
#                   # Colv = clust$dendro,
#                   col = correlation_palette,
#                   breaks = correlation_breaks,
#                   key.xlab = "Correlation",
#                   # xlab = "Major cell class",
#                   # ylab = "Predicted topics",
#                   key.title = NA,
#                   cexRow = 0.9,
#                   cexCol = 0.9,
#                   # lhei = c(1,3),
#                   margins = c(6,15))



# ## 
corMtx_sort_vals <- do.call(rbind, lapply(rownames(corMtx), function(i){
  as.vector(sort(corMtx[i,], decreasing = TRUE))
}))
rownames(corMtx_sort_vals) <- rownames(corMtx)

corMtx_sort_vals_names <- do.call(rbind, lapply(rownames(corMtx), function(i){
  names(sort(corMtx[i,], decreasing = TRUE))
}))
rownames(corMtx_sort_vals_names) <- rownames(corMtx)


corMtx_sort_vals_gt <- do.call(rbind, lapply(colnames(corMtx), function(i){
  as.vector(sort(corMtx[,i], decreasing = TRUE))
}))
rownames(corMtx_sort_vals_gt) <- colnames(corMtx)

corMtx_sort_vals_names_gt <- do.call(rbind, lapply(colnames(corMtx), function(i){
  names(sort(corMtx[,i], decreasing = TRUE))
}))
rownames(corMtx_sort_vals_names_gt) <- colnames(corMtx)

# sort(FN7_K9_135genes$beta[1,], decreasing = TRUE)[1:10]



```

```{r}
rownames(gtCtGenesFN7)
```

## gt top genes

```{r}

deconGexp <- gtCtGenesFN7*1000
# counts <- as.matrix(simFN7_9ct_135genes$sim)

## for list of markers
gt_gene_set <- list()

for (i in seq(nrow(gtCtGenesFN7))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## ----------------------------------------------------
  ## txn profile, normalized and scaled expression
  
  dat <- data.frame(values = as.vector(vals), genes = names(vals), order = seq(length(vals)))
  # Hide all of the text labels.
  dat$selectedLabels <- ""
  # Let's just label these items.
  ix_label <- seq(20)
  dat$selectedLabels[ix_label] <- dat$genes[ix_label]
  
  p1 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0(rownames(gtCtGenesFN7)[celltype], " transcriptional profile"),
         x = "Gene expression rank", y = "Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.01, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "y", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=15),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p1)
  # ggplot2::ggsave(filename = paste0("4_k15_ct", celltype, "_txnProfile_barplot.png"),
  #          device = "png",
  #          path = fig_path,
  #          scale = 1.5,
  #          width = 5,
  #          height = 3,
  #          units = c("in"),
  #          dpi = 300)
  
  ## ----------------------------------------------------
  ## log2FC relative to other cell-types
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  ## for gene set of the ground truth cell-type, get the genes
  ## with log2FC > 1 (so FC > 2 over the mean exp of the other cell-types)
  markers <- names(log2fc[log2fc > 1])
  gt_gene_set[[ rownames(gtCtGenesFN7)[celltype] ]] <- markers
  
  dat <- data.frame(values = as.vector(log2fc), genes = names(log2fc), order = seq(length(log2fc)))
  # Hide all of the text labels.
  dat$selectedLabels1 <- ""
  # Let's just label these top items.
  ix_label <- seq(15)
  dat$selectedLabels1[ix_label] <- dat$genes[ix_label]
  
  # dat$selectedLabels2 <- ""
  # # Let's label these bottom items
  # ix_label <- tail(seq(length(log2fc)), 5)
  # dat$selectedLabels2[ix_label] <- dat$genes[ix_label]
  
  p2 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0(rownames(gtCtGenesFN7)[celltype], " transcriptional profile"),
         x = "Gene expression rank", y = "log2FC Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels1), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    # ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels2), size = 5, 
    #                 min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
    #                 # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
    #                 nudge_x = -10, direction = "y", hjust = "right",
    #                 # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    # ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=12),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          legend.position = "none"
          )
  print(p2)
  
  if (rownames(gtCtGenesFN7)[celltype] %in% c("Excitatory", "Inhibitory")){
    ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-C-log2fc_txn_", rownames(gtCtGenesFN7)[celltype], ".pdf"),
                  plot = p2,
                  device = "pdf",
                  path = fig_path,
                  scale = 1.5,
                  width = 5,
                  height = 3,
                  units = c("in"),
                  dpi = 300)
  }
  
  
}
```

## decon ct top genes

```{r}

deconGexp <- FN7_K9_135genes$beta*1000
counts <- as.matrix(simFN7_9ct_135genes$sim)
for (i in seq(nrow(deconGexp))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## ----------------------------------------------------
  ## txn profile, normalized and scaled expression
  
  dat <- data.frame(values = as.vector(vals), genes = names(vals), order = seq(length(vals)))
  # Hide all of the text labels.
  dat$selectedLabels <- ""
  # Let's just label these items.
  ix_label <- seq(20)
  dat$selectedLabels[ix_label] <- dat$genes[ix_label]
  
  p1 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=15),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p1)
  # ggplot2::ggsave(filename = paste0("4_k15_ct", celltype, "_txnProfile_barplot.png"),
  #          device = "png",
  #          path = fig_path,
  #          scale = 1.5,
  #          width = 5,
  #          height = 3,
  #          units = c("in"),
  #          dpi = 300)
  
  ## ----------------------------------------------------
  ## log2FC relative to other cell-types
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  dat <- data.frame(values = as.vector(log2fc), genes = names(log2fc), order = seq(length(log2fc)))
  # Hide all of the text labels.
  dat$selectedLabels1 <- ""
  # Let's just label these top items.
  ix_label <- seq(15)
  dat$selectedLabels1[ix_label] <- dat$genes[ix_label]
  
  # dat$selectedLabels2 <- ""
  # # Let's label these bottom items
  # ix_label <- tail(seq(length(log2fc)), 5)
  # dat$selectedLabels2[ix_label] <- dat$genes[ix_label]
  
  p2 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "log2FC Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels1), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    # ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels2), size = 5, 
    #                 min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
    #                 # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
    #                 nudge_x = -10, direction = "y", hjust = "right",
    #                 # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    # ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=12),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          legend.position = "none"
          )
  print(p2)
  
  if (celltype %in% c(2, 7)){
    ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-C-log2fc_txn_celltype_", celltype, ".pdf"),
                  plot = p2,
                  device = "pdf",
                  path = fig_path,
                  scale = 1.5,
                  width = 5,
                  height = 3,
                  units = c("in"),
                  dpi = 300)
  }
  
}
```

## gsea

```{r}

deconGexp <- FN7_K9_135genes$beta*1000
gset <- gt_gene_set

for (i in seq(nrow(deconGexp))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  gsea.results <- liger::iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  # print(gsea.results[order(gsea.results$p.val),])
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  # print(gsea.sig)
  
  ## order of selection:
  ## 1. q-val
  ## 2. edge score
  ## 3. sscore
  gsea.sig <- gsea.sig %>%
    arrange(q.val, -edge, -sscore)
  print(gsea.sig)
  
}

```

cell-type 2 and 7 are both inhibitory.
Also makes some sense because if you look at the mean pixel proportions of ground truth and deconvolution for inhibitory, there is a pretty large gap. A lot is under reported for inhibitory.

Some cell-types are significantly enriched in microglia and pericyte genes, but are more significantly enriched with other ground truth cell-type genes.

So no pairing for microglia and pericytes

```{r}

deconGexp <- FN7_K9_135genes$beta*1000
gset <- gt_gene_set

i <- "1"
g <- "OD Immature"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "1"
g <- "Inhibitory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))


i <- "2"
g <- "Inhibitory"
pdf(file = paste0(fig_path, "Supplemental_Figure_S3-D-gsea_celltype_", i, "_", g, ".pdf"),
    width = 6,
    height = 5)
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))
dev.off()

i <- "2"
g <- "Excitatory"
pdf(file = paste0(fig_path, "Supplemental_Figure_S3-D-gsea_celltype_", i, "_", g, ".pdf"),
    width = 6,
    height = 5)
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))
dev.off()

i <- "3"
g <- "Ependymal"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "4"
g <- "Inhibitory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "5"
g <- "OD Mature"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "6"
g <- "Endothelial"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "7"
g <- "Inhibitory"
pdf(file = paste0(fig_path, "Supplemental_Figure_S3-D-gsea_celltype_", i, "_", g, ".pdf"),
    width = 6,
    height = 5)
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))
dev.off()

i <- "7"
g <- "Excitatory"
pdf(file = paste0(fig_path, "Supplemental_Figure_S3-D-gsea_celltype_", i, "_", g, ".pdf"),
    width = 6,
    height = 5)
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))
dev.off()

i <- "8"
g <- "Excitatory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "9"
g <- "Astrocyte"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

```


## Viz predictions

### one bregma

```{r, fig.height=4, fig.width=4}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")


simulation <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

# ## colors for the ground truth cell-types based on their txn ordering
# clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
#                        clustering = "ward.D", ## ward.D
#                        dynamic = "hybrid",
#                        deepSplit = 4,
#                        plot = FALSE)
# ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])
# 
# classCols <- rainbow(length(ct_txn_order))
# names(classCols) <- ct_txn_order


# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = decon$beta, # rows
                     m2 = as.matrix(gt$gtCtGenes), # cols
                     type = "b")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

# plot each bregma separately
for(ix in names(simBregmasFN7)[1]){
  
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]
  
  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]
  cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])
  
  
  ## -------------------------------------------------------
  ## STdeconvolve all topics together
  p1 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=cols,
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = TRUE,
                     plotTitle = ix)
  print(p1)
  ggplot2::ggsave(filename = paste0("Figure_2-C-bregma_", ix, "_stdecon_allTopics_9cts_135genes.pdf"),
         device = "pdf",
         plot = p1,
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  ## STdeconvolve each cell-type separately:
  plts1 <- lapply(colnames(m), function(i){
    ct <- m[,i]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")
    
    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = paste0("Cell-type ", i))
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  layout <- t(matrix(seq(9), nrow = 3, ncol = 3))
  plts1_grid <- gridExtra::grid.arrange(
                    grobs = plts1,
                    layout_matrix = layout
  )
  plts1_grid
  ggplot2::ggsave(filename = paste0("Figure_2-C-bregma_", ix, "_stdecon_9cts_135genes.pdf"),
                  plot = plts1_grid,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
  # -------------------------------------------------------------
  ## ground truth cell-types
  
  plts1 <- lapply(colnames(m), function(i){
    gt_ct <- colnames(corMtx)[pairs$colsix][as.numeric(i)]
    ct <- gtFreqs[, gt_ct]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")
    
    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = gt_ct)
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  layout <- t(matrix(seq(9), nrow = 3, ncol = 3))
  plts1_grid <- gridExtra::grid.arrange(
                    grobs = plts1,
                    layout_matrix = layout
  )
  plts1_grid
  ggplot2::ggsave(filename = paste0("Figure_2-B-bregma_", ix, "_simulated_9cts_135genes.pdf"),
                  plot = plts1_grid,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
  
  ## -------------------------------------------------------------
  ## ground truth cell-types all cell-types
  gt_ct <- colnames(corMtx)[pairs$colsix]
  ct <- gtFreqs[, gt_ct]

  p1 <- vizAllTopics(theta = ct,
                     pos = p,
                     topicOrder=seq(ncol(ct)),
                     topicCols=cols,
                     groups = rep("0", dim(ct)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = TRUE,
                     plotTitle = NA)
  p1 + theme(plot.title = element_text(size = 15))
  print(p1)
  ggplot2::ggsave(filename = paste0("Figure_2-B-bregma_", ix, "_simulated_allTopics_9cts_135genes.pdf"),
                  plot = p1,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
   # -------------------------------------------------------------
  ## cell-types as points
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  ## have the cell-types appear in same order as the simulated scatter pies
  breg <- breg %>%
    mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
    arrange(Cell_class)
  
  # -------------------------------------------------------------
  # each cell type separately
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    facet_wrap(~Cell_class) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    theme_classic() +
    theme(
          #panel.background = element_rect(fill = "white"),
          strip.text = element_text(size=15),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p1)
  # ggsave(filename = paste0("0_9cts_separate_bregma_", ix, ".png"),
  #        device = "png",
  #        path = fig_path,
  #        scale = 1,
  #        width = 6,
  #        height = 6,
  #        units = c("in"),
  #        dpi = 300)
  
  # -------------------------------------------------------------
  # all cells with grid showing
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") #+
    #ggtitle(ix)
  print(p2)
  ggplot2::ggsave(filename = paste0("Figure_2-A-bregma_", ix, "_gt_grid_9cts_135genes.pdf"),
                  plot = p2,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
}

```

### all bregmas separate cts

```{r, fig.height=48, fig.width=4}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")


simulation <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

n <- 12

# ## colors for the ground truth cell-types based on their txn ordering
# clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
#                        clustering = "ward.D", ## ward.D
#                        dynamic = "hybrid",
#                        deepSplit = 4,
#                        plot = FALSE)
# ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])
# 
# classCols <- rainbow(length(ct_txn_order))
# names(classCols) <- ct_txn_order


## matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = decon$beta, # rows
                     m2 = as.matrix(gt$gtCtGenes), # cols
                     type = "b")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

## -------------------------------------------------------------
## STdeconvolve
stdev_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){

  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]

  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]
  cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])

  plts <- lapply(colnames(m), function(i){
    ct <- m[,i]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")

    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = paste0("Cell-type ", i))
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  plts
})

layout <- t(matrix(seq(9*n), nrow = 3, ncol = 3*n))
plts1_grid <- gridExtra::grid.arrange(
                  grobs = do.call(c, stdev_grobs),
                  layout_matrix = layout
)
plts1_grid
ggplot2::ggsave(filename = paste0("Supplementary_Figure_S1-C-bregma_All_stdecon_9cts_135genes.pdf"),
                  plot = plts1_grid,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 4,
                  height = 48,
                  units = c("in"),
                  dpi = 300)

## -------------------------------------------------------------
## ground truth cell-types sim proprotions
gt_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){

  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]

  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]
  cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])

  plts <- lapply(colnames(m), function(i){
    gt_ct <- names(classCols[colnames(corMtx)[pairs$colsix]][as.numeric(i)])
    ct <- gtFreqs[, gt_ct]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")

    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = gt_ct)
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  plts
})

layout <- t(matrix(seq(9*n), nrow = 3, ncol = 3*n))
plts2_grid <- gridExtra::grid.arrange(
                  grobs = do.call(c, gt_grobs),
                  layout_matrix = layout
)
plts2_grid
ggplot2::ggsave(filename = paste0("Supplementary_Figure_S1-B-bregma_All_simulated_9cts_135genes.pdf"),
                  plot = plts2_grid,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 4,
                  height = 48,
                  units = c("in"),
                  dpi = 300)

# ## -------------------------------------------------------------
# ## cell-types as points
# ct_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
# 
#   breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
#   cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
# 
#   ## have the cell-types appear in same order as the simulated scatter pies
#   breg <- breg %>%
#     mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
#     arrange(Cell_class)
# 
#   p1 <- ggplot() +
#     geom_point(data = breg,
#                aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
#     facet_wrap(~Cell_class) +
#     scale_color_manual(values = classCols[breg$Cell_class]) +
#     theme_classic() +
#     theme(
#           #panel.background = element_rect(fill = "white"),
#           strip.text = element_text(size=15),
#           panel.grid = element_blank(),
#           axis.line=element_blank(),
#           axis.text.x=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(),
#           legend.position = "none") +
#     ggtitle(ix)
#   ggplotGrob(p1)
# })
# layout <- matrix(seq(n))
# plts3_grid <- gridExtra::grid.arrange(
#                   grobs = ct_grobs,
#                   layout_matrix = layout
# )
# plts3_grid
# ggplot2::ggsave(filename = paste0("0_9cts_135genes_separate_cts_bregma_all.png"),
#                 plot = plts3_grid,
#                 device = "png",
#                 path = fig_path,
#                 scale = 1,
#                 width = 4,
#                 height = 48,
#                 units = c("in"),
#                 dpi = 300)

## -------------------------------------------------------------
## cell-types as points with grid
ctgrid_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
  
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]

  ## have the cell-types appear in same order as the simulated scatter pies
  breg <- breg %>%
    mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
    arrange(Cell_class)
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size = 0.1) +
    facet_wrap(~Cell_class) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "solid", size = 0.1) +
    theme_classic() +
    theme(
          #panel.background = element_rect(fill = "white"),
          strip.text = element_text(size=12),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})
layout <- matrix(seq(n))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = ctgrid_grobs,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S1-A-bregma_All_gt_grid_9cts_135genes.pdf"),
                  plot = plts4_grid,
                  device = "pdf",
                  path = fig_path,
                  scale = 1,
                  width = 4,
                  height = 48,
                  units = c("in"),
                  dpi = 300)

```

### all bregmas combined cts

```{r, fig.height=48, fig.width=5}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

simulation <- lda_k9_135genes_theta
gt <- simFN7_9ct_135genes

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = simulation, # rows
                     m2 = as.matrix(gt$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows


## -------------------------------------------------------------
## each cell type separately
plts1 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.3) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})

layout <- matrix(seq(12))
plts1_grid <- gridExtra::grid.arrange(
                  grobs = plts1,
                  layout_matrix = layout
)
plts1_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_separateCts_AllBregmas.png"),
                plot = plts1_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

## -------------------------------------------------------------
## all cells with grid showing
plts2 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.4) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") #+
    #ggtitle(ix)
  ggplotGrob(p2)
})

layout <- matrix(seq(12))
plts2_grid <- gridExtra::grid.arrange(
                  grobs = plts2,
                  layout_matrix = layout
)
plts2_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_grid_AllBregmas.png"),
                plot = plts2_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## ground truth proportions
plts3 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]

  m <- as.matrix(gt$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = NA)
  ggplotGrob(p3)
})

layout <- matrix(seq(12))
plts3_grid <- gridExtra::grid.arrange(
                  grobs = plts3,
                  layout_matrix = layout
)
plts3_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_simST_AllBregmas.png"),
                plot = plts3_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## STdeconvolve proportions
plts4 <- lapply(names(simBregmasFN7), function(ix){

  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]

  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]

  p4 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = FALSE,
                     plotTitle = NA)
  ggplotGrob(p4)
})

layout <- matrix(seq(12))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = plts4,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_STdeconvolve_AllBregmas.png"),
                plot = plts4_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

# layout <- t(matrix(seq(length((simBregmasFN7))*4), nrow=4))

```

## Correlations 


correlation between deconvolved cell-type txn profiles

```{r}

decon <- FN7_K9_135genes

clust <- clusterTopics(beta = as.matrix(decon$beta),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
decon_txn_order <- rownames(as.matrix(decon$beta)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(decon$beta),
                         m2 = as.matrix(decon$beta),
                         type = "b")

rownames(corMtx_txn) <- paste0("Cell-type ", rownames(corMtx_txn))
colnames(corMtx_txn) <- paste0("Cell-type ", colnames(corMtx_txn))


gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,8))


corMtx_txn <- getCorrMtx(m1 = as.matrix(decon$beta)[decon_txn_order,],
                         m2 = as.matrix(decon$beta)[decon_txn_order,],
                         type = "b")

rownames(corMtx_txn) <- paste0("Cell-type ", rownames(corMtx_txn))
colnames(corMtx_txn) <- paste0("Cell-type ", colnames(corMtx_txn))

pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  # ggplot2::xlab("Ground truth cell-types") +
  # ggplot2::ylab("Deconvolved cell-types") +
  # ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()

```

```{r}

## color by transcriptional similarity


# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

filt_theta <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## scale mtx:
corMtx_txn_rs <- apply(corMtx_txn_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_txn_rs <- t(corMtx_txn_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_txn_rs) <- colnames(corMtx_txn_1)

corMtx_txn_cs <- apply(corMtx_txn_rs, 2, scale)
rownames(corMtx_txn_cs) <- rownames(corMtx_txn_1)


## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1) #  corMtx_txn_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-B-txn_corr-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

## scale mtx:
corMtx_prop_rs <- apply(corMtx_prop_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_prop_rs <- t(corMtx_prop_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_prop_rs) <- colnames(corMtx_prop_1)

corMtx_prop_cs <- apply(corMtx_prop_rs, 2, scale)
rownames(corMtx_prop_cs) <- rownames(corMtx_prop_1)

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1) #  corMtx_prop_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("Figure_2-E-proportion_corr-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_prop_corr_heatmap_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")



## correlations are between matched cell-types.
## custom switch:
## cell-type 7 inhibitory based on marker genes
## cell-type 2 excitatory based on marker genes
transcriptional <- diag(corMtx_txn_1)
transcriptional[7] <- corMtx_txn_1["Inhibitory", "Cell-type 7"]
transcriptional[8] <- corMtx_txn_1["Inhibitory", "Cell-type 2"]

proportional <- diag(corMtx_prop_4)
proportional[7] <- corMtx_prop_4["Inhibitory", "Cell-type 7"]
proportional[8] <- corMtx_prop_4["Inhibitory", "Cell-type 2"]

## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = transcriptional,
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = proportional
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("Figure_2-F-matched_ct_corrs_boxplots-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 2.5,
         height = 4,
         units = c("in"),
         dpi = 300)


## record final matches:
gt_matches <- rownames(corMtx_txn_1)
ct_matches <- colnames(corMtx_txn_1)
names(gt_matches) <- ct_matches
gt_matches[7] <- "Inhibitory"
gt_matches[8] <- "Inhibitory"

## adjust the deconvolved pixel proportions based on the new match assignment of cell-types

filt_theta_adj <- filt_theta[,pairs$colsix]
filt_theta_adj <- cbind(filt_theta_adj, rowSums(filt_theta[,c("4","7","8")]))
colnames(filt_theta_adj) <- c("OD Immature", "Excitatory",  "drop",  "Astrocyte", "Ependymal", "Endothelial", "Pericytes",   "Microglia", "OD Mature", "Inhibitory")

filt_theta_adj <- filt_theta_adj[,ct_txn_order]
filt_theta_adj[,"Microglia"] <- 0
filt_theta_adj[,"Pericytes"] <- 0

# # -----------------------------------------
# t_raw <- data.frame(gt$gtSpotTopics[,ct_txn_order], group = "Actual")
# p_raw <- data.frame(filt_theta_adj[,ct_txn_order], group = "Deconvolved")
# dat <- rbind(t_raw, p_raw)
# 
# ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   labs(title = "Deconvolved pixel proportions versus ground truth",
#        x = "Cell-type match", y = "pixel proportions") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         axis.text.y=element_text(size = 15),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_text(size=15),
#         axis.title.y=element_text(size=15),
#         panel.background=element_blank()
#         )
# # -----------------------------------------

## proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics),
                         m2 = filt_theta,
                         type = "t")

gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))

```

## Gene ranks

```{r}

dim(gtCtGenesFN7)

```


MERIGNUE differential genes for each cluster:
```{r}

se <- bregmaFN7FullSeur_9ct_135genes

# cells and their associated clusters
neuroClusters <- se@meta.data$All_classes
names(neuroClusters) <- rownames(se@meta.data)
# I-39 only has one cell so drop 
neuroClusters <- neuroClusters[which(!neuroClusters %in% c("I-39"))]
difGenesNeuro <- MERINGUE::getDifferentialGenes(cd = se@assays$RNA@counts, cols = neuroClusters)

# cells and their associated clusters
majorClusters <- se@meta.data$Major_class
names(majorClusters) <- rownames(se@meta.data)
difGenesMajor <- MERINGUE::getDifferentialGenes(cd = se@assays$RNA@counts, cols = majorClusters)
                                            
```

```{r}

# gt_matches

m1 <- FN7_K9_135genes$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

rownames(m1) <- paste0("Cell-type ", seq(9))

summary_df <- do.call(rbind, lapply(names(gt_matches), function(i){
        # get paired ct
        ct <- as.vector(gt_matches[i])
        topic <- i
        print(ct)
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        # prsn <- cor(x, y, method = "pearson")
        # sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank))
                # labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                #                    "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Cell-type transcriptional profiles",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic() +
        ggplot2::theme(axis.text.x=element_text(size=15),
                       axis.text.y=element_text(size=15),
                       axis.title.y=element_text(size=15),
                       axis.title.x=element_text(size=15),
                       plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("Figure_2-D-_gene_ranks_hex-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 4,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```


```{r}

gt_matches

m1 <- FN7_K9_135genes$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

# corMtx <- getCorrMtx(m1 = m1, # rows
#                      m2 = m2, # cols
#                      type = "b")
# pairs <- lsatPairs(corMtx)

rownames(m1) <- paste0("Cell-type ", seq(9))

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct
        ct <- rownames(m2)[pairs$colsix[i]]
        topic <- i
        
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank)) +
                labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Cell-type transcriptional profiles",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic() +
        ggplot2::theme(axis.text.x=element_text(size=15),
                       axis.text.y=element_text(size=15),
                       axis.title.y=element_text(size=15),
                       axis.title.x=element_text(size=15),
                       plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 4,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

# K=12 135 genes

## decon ct top genes

```{r}

deconGexp <- FN7_K12_135genes$beta*1000
counts <- as.matrix(simFN7_9ct_135genes$sim)
for (i in seq(nrow(deconGexp))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## ----------------------------------------------------
  ## txn profile, normalized and scaled expression
  
  dat <- data.frame(values = as.vector(vals), genes = names(vals), order = seq(length(vals)))
  # Hide all of the text labels.
  dat$selectedLabels <- ""
  # Let's just label these items.
  ix_label <- seq(20)
  dat$selectedLabels[ix_label] <- dat$genes[ix_label]
  
  p1 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=15),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p1)
  # ggplot2::ggsave(filename = paste0("4_k15_ct", celltype, "_txnProfile_barplot.png"),
  #          device = "png",
  #          path = fig_path,
  #          scale = 1.5,
  #          width = 5,
  #          height = 3,
  #          units = c("in"),
  #          dpi = 300)
  
  ## ----------------------------------------------------
  ## log2FC relative to other cell-types
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  dat <- data.frame(values = as.vector(log2fc), genes = names(log2fc), order = seq(length(log2fc)))
  # Hide all of the text labels.
  dat$selectedLabels1 <- ""
  # Let's just label these top items.
  ix_label <- seq(15)
  dat$selectedLabels1[ix_label] <- dat$genes[ix_label]
  
  # dat$selectedLabels2 <- ""
  # # Let's label these bottom items
  # ix_label <- tail(seq(length(log2fc)), 5)
  # dat$selectedLabels2[ix_label] <- dat$genes[ix_label]
  
  p2 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "log2FC Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels1), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    # ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels2), size = 5, 
    #                 min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
    #                 # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
    #                 nudge_x = -10, direction = "y", hjust = "right",
    #                 # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    # ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=12),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p2)
  # ggplot2::ggsave(filename = paste0("0_gt_9ct_deconvolved_ct_", celltype, "_txnProfile_log2FC_barplot.png"),
  #                 plot = p2,
  #                  device = "png",
  #                  path = fig_path,
  #                  scale = 1.5,
  #                  width = 5,
  #                  height = 3,
  #                  units = c("in"),
  #                  dpi = 300)
  
}
```

## gsea

```{r}

deconGexp <- FN7_K12_135genes$beta*1000
gset <- gt_gene_set

for (i in seq(nrow(deconGexp))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  gsea.results <- liger::iterative.bulk.gsea(values=vals, set.list=gset, rank=TRUE)
  # print(gsea.results[order(gsea.results$p.val),])
  
  # filter for top hits
  gsea.sig <- gsea.results[gsea.results$q.val < 0.1,]
  gsea.sig <- gsea.sig[order(gsea.sig$p.val),]
  # print(gsea.sig)
  
  ## order of selection:
  ## 1. q-val
  ## 2. edge score
  ## 3. sscore
  gsea.sig <- gsea.sig %>%
    arrange(q.val, -edge, -sscore)
  print(gsea.sig)
  
}

```

```{r}

deconGexp <- FN7_K12_135genes$beta*1000
gset <- gt_gene_set

i <- "1"
g <- "Ependymal"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "2"
g <- "Inhibitory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "3"
g <- "Pericytes"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "4"
g <- "Excitatory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "5"
g <- "OD Mature"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "6"
g <- "Endothelial"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "7"
g <- "Inhibitory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "8"
g <- "Excitatory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "9"
g <- "OD Immature"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "10"
g <- "Inhibitory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "11"
g <- "Excitatory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))

i <- "12"
g <- "Excitatory"
gsea(values=sort(deconGexp[i,], decreasing = TRUE),
     geneset=gset[[g]], plot=TRUE, rank=TRUE,
     main = paste("Cell-type", i, "enriched with", g, "genes"))


```

astrocytes and microglia are now unassigned 

6 is really close to astrocytes and endothelial

9 is also really close to astrocytes and OD immature

## Viz predictions

### one bregma

```{r, fig.height=4, fig.width=4}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")


simulation <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

# ## colors for the ground truth cell-types based on their txn ordering
# clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
#                        clustering = "ward.D", ## ward.D
#                        dynamic = "hybrid",
#                        deepSplit = 4,
#                        plot = FALSE)
# ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])
# 
# classCols <- rainbow(length(ct_txn_order))
# names(classCols) <- ct_txn_order


# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = decon$beta, # rows
                     m2 = as.matrix(gt$gtCtGenes), # cols
                     type = "b")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

# plot each bregma separately
for(ix in names(simBregmasFN7)[1]){
  
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]
  
  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]
  cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])
  
  # p1 <- vizAllTopics(theta = m,
  #                    pos = p,
  #                    topicOrder=seq(ncol(m)),
  #                    topicCols=cols,
  #                    groups = rep("0", dim(m)[1]),
  #                    group_cols = c("0" = "black"),
  #                    r = 40,
  #                    lwd = 0.4,
  #                    showLegend = TRUE,
  #                    plotTitle = ix)
  # print(p1)
  # ggplot2::ggsave(filename = paste0("0_9cts_135genes_STdev_bregma_", ix, ".png"),
  #        device = "png",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 300)
  
  # -------------------------------------------------------------
  ## each cell-type separately:
  plts1 <- lapply(colnames(m), function(i){
    ct <- m[,i]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")
    
    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = paste0("Cell-type ", i))
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  layout <- t(matrix(seq(9), nrow = 3, ncol = 3))
  plts1_grid <- gridExtra::grid.arrange(
                    grobs = plts1,
                    layout_matrix = layout
  )
  plts1_grid
  ggplot2::ggsave(filename = paste0("0_9cts_135genes_STdev_bregma_", ix, ".png"),
                  plot = plts1_grid,
                  device = "png",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
  # -------------------------------------------------------------
  ## ground truth cell-types
  plts1 <- lapply(colnames(m), function(i){
    gt_ct <- names(classCols[colnames(corMtx)[pairs$colsix]][as.numeric(i)])
    ct <- gt$gtSpotTopics[spots, gt_ct]
    other <- 1 - ct
    m_ <- cbind(ct, other)
    colnames(m_) <- c(i, "other")
    
    p1 <- vizAllTopics(theta = m_,
                       pos = p,
                       topicOrder=seq(ncol(m_)),
                       topicCols=c(cols[as.numeric(i)], "white"),
                       groups = rep("0", dim(m_)[1]),
                       group_cols = c("0" = "black"),
                       r = 40,
                       lwd = 0.1,
                       showLegend = FALSE,
                       plotTitle = gt_ct)
    p1 + theme(plot.title = element_text(size = 15))
    ggplotGrob(p1)
  })
  layout <- t(matrix(seq(9), nrow = 3, ncol = 3))
  plts1_grid <- gridExtra::grid.arrange(
                    grobs = plts1,
                    layout_matrix = layout
  )
  plts1_grid
  ggplot2::ggsave(filename = paste0("0_9cts_135genes_simST_bregma_", ix, ".png"),
                  plot = plts1_grid,
                  device = "png",
                  path = fig_path,
                  scale = 1,
                  width = 6,
                  height = 6,
                  units = c("in"),
                  dpi = 300)
  
   # -------------------------------------------------------------
  ## cell-types as points
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  ## have the cell-types appear in same order as the simulated scatter pies
  breg <- breg %>%
    mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
    arrange(Cell_class)
  
  # -------------------------------------------------------------
  # each cell type separately
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    facet_wrap(~Cell_class) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    theme_classic() +
    theme(
          #panel.background = element_rect(fill = "white"),
          strip.text = element_text(size=15),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p1)
  ggsave(filename = paste0("0_9cts_separate_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1,
         width = 6,
         height = 6,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  # all cells with grid showing
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p2)
  ggsave(filename = paste0("0_9cts_grid_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1,
         width = 6,
         height = 6,
         units = c("in"),
         dpi = 300)
  
}

```

### all bregmas separate cts

```{r, fig.height=48, fig.width=4}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")


simulation <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_9ct_135genes

n <- 12

# ## colors for the ground truth cell-types based on their txn ordering
# clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
#                        clustering = "ward.D", ## ward.D
#                        dynamic = "hybrid",
#                        deepSplit = 4,
#                        plot = FALSE)
# ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])
# 
# classCols <- rainbow(length(ct_txn_order))
# names(classCols) <- ct_txn_order


## matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = decon$beta, # rows
                     m2 = as.matrix(gt$gtCtGenes), # cols
                     type = "b")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

# ## -------------------------------------------------------------
# ## STdeconvolve 
# stdev_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
# 
#   breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
#   cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
#   spots <- rownames(cellCounts)
#   gtFreqs <- gt$gtSpotTopics[spots,]
# 
#   m <- simulation[spots,]
#   p <- cellCounts[, c("x", "y")]
#   cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])
# 
#   plts <- lapply(colnames(m), function(i){
#     ct <- m[,i]
#     other <- 1 - ct
#     m_ <- cbind(ct, other)
#     colnames(m_) <- c(i, "other")
# 
#     p1 <- vizAllTopics(theta = m_,
#                        pos = p,
#                        topicOrder=seq(ncol(m_)),
#                        topicCols=c(cols[as.numeric(i)], "white"),
#                        groups = rep("0", dim(m_)[1]),
#                        group_cols = c("0" = "black"),
#                        r = 40,
#                        lwd = 0.1,
#                        showLegend = FALSE,
#                        plotTitle = paste0("Cell-type ", i))
#     p1 + theme(plot.title = element_text(size = 15))
#     ggplotGrob(p1)
#   })
#   plts
# })
#   
# layout <- t(matrix(seq(9*n), nrow = 3, ncol = 3*n))
# plts1_grid <- gridExtra::grid.arrange(
#                   grobs = do.call(c, stdev_grobs),
#                   layout_matrix = layout
# )
# plts1_grid
# ggplot2::ggsave(filename = paste0("0_9cts_135genes_STdev_bregma_all.png"),
#                 plot = plts1_grid,
#                 device = "png",
#                 path = fig_path,
#                 scale = 1,
#                 width = 4,
#                 height = 48,
#                 units = c("in"),
#                 dpi = 300)
# 
# ## -------------------------------------------------------------
# ## ground truth cell-types sim proprotions
# gt_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
# 
#   breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
#   cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
#   spots <- rownames(cellCounts)
#   gtFreqs <- gt$gtSpotTopics[spots,]
# 
#   m <- simulation[spots,]
#   p <- cellCounts[, c("x", "y")]
#   cols <- as.vector(classCols[colnames(corMtx)[pairs$colsix]])
# 
#   plts <- lapply(colnames(m), function(i){
#     gt_ct <- names(classCols[colnames(corMtx)[pairs$colsix]][as.numeric(i)])
#     ct <- gtFreqs[, gt_ct]
#     other <- 1 - ct
#     m_ <- cbind(ct, other)
#     colnames(m_) <- c(i, "other")
# 
#     p1 <- vizAllTopics(theta = m_,
#                        pos = p,
#                        topicOrder=seq(ncol(m_)),
#                        topicCols=c(cols[as.numeric(i)], "white"),
#                        groups = rep("0", dim(m_)[1]),
#                        group_cols = c("0" = "black"),
#                        r = 40,
#                        lwd = 0.1,
#                        showLegend = FALSE,
#                        plotTitle = gt_ct)
#     p1 + theme(plot.title = element_text(size = 15))
#     ggplotGrob(p1)
#   })
#   plts
# })
#   
# layout <- t(matrix(seq(9*n), nrow = 3, ncol = 3*n))
# plts2_grid <- gridExtra::grid.arrange(
#                   grobs = do.call(c, gt_grobs),
#                   layout_matrix = layout
# )
# plts2_grid
# ggplot2::ggsave(filename = paste0("0_9cts_135genes_simST_bregma_all.png"),
#                 plot = plts2_grid,
#                 device = "png",
#                 path = fig_path,
#                 scale = 1,
#                 width = 4,
#                 height = 48,
#                 units = c("in"),
#                 dpi = 300)
# 
# ## -------------------------------------------------------------
# ## cell-types as points
# ct_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
#   
#   breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
#   cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
# 
#   ## have the cell-types appear in same order as the simulated scatter pies
#   breg <- breg %>%
#     mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
#     arrange(Cell_class)
#   
#   p1 <- ggplot() +
#     geom_point(data = breg,
#                aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
#     facet_wrap(~Cell_class) +
#     scale_color_manual(values = classCols[breg$Cell_class]) +
#     theme_classic() +
#     theme(
#           #panel.background = element_rect(fill = "white"),
#           strip.text = element_text(size=15),
#           panel.grid = element_blank(),
#           axis.line=element_blank(),
#           axis.text.x=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks=element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.background=element_blank(),
#           legend.position = "none") +
#     ggtitle(ix)
#   ggplotGrob(p1)
# })
# layout <- matrix(seq(n))
# plts3_grid <- gridExtra::grid.arrange(
#                   grobs = ct_grobs,
#                   layout_matrix = layout
# )
# plts3_grid
# ggplot2::ggsave(filename = paste0("0_9cts_135genes_separate_cts_bregma_all.png"),
#                 plot = plts3_grid,
#                 device = "png",
#                 path = fig_path,
#                 scale = 1,
#                 width = 4,
#                 height = 48,
#                 units = c("in"),
#                 dpi = 300)

## -------------------------------------------------------------
## cell-types as points with grid
ctgrid_grobs <- lapply(names(simBregmasFN7[1:n]), function(ix){
  
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]

  ## have the cell-types appear in same order as the simulated scatter pies
  breg <- breg %>%
    mutate(Cell_class = factor(Cell_class, levels = names(classCols[colnames(corMtx)[pairs$colsix]]))) %>%
    arrange(Cell_class)
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size = 0.1) +
    facet_wrap(~Cell_class) +
    scale_color_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "solid", size = 0.1) +
    theme_classic() +
    theme(
          #panel.background = element_rect(fill = "white"),
          strip.text = element_text(size=12),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})
layout <- matrix(seq(n))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = ctgrid_grobs,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("0_9cts_135genes_separate_cts_grid_bregma_all.png"),
                plot = plts4_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 4,
                height = 48,
                units = c("in"),
                dpi = 300)

```

### all bregmas combined cts

```{r, fig.height=48, fig.width=5}

## reverse rainbow
classCols <- c("Astrocyte" = "#FF00AA",
               "Endothelial" = "#AA00FF",
               "Ependymal" = "#0000FF",
               "Excitatory" = "#00AAFF",
               "Inhibitory" = "#00FFAA",
               "Microglia" = "#00FF00",
               "OD Immature" = "#AAFF00",
               "OD Mature" = "#FFAA00",
               "Pericytes" = "#FF0000")

## rainbow
# classCols <- c("Astrocyte" = "#FF0000",
#                "Endothelial" = "#FFAA00",
#                "Ependymal" = "#AAFF00",
#                "Excitatory" = "#00FF00",
#                "Inhibitory" = "#00FFAA",
#                "Microglia" = "#00AAFF",
#                "OD Immature" = "#0000FF",
#                "OD Mature" = "#AA00FF",
#                "Pericytes" = "#FF00AA")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

simulation <- lda_k9_135genes_theta
gt <- simFN7_9ct_135genes

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = simulation, # rows
                     m2 = as.matrix(gt$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows


## -------------------------------------------------------------
## each cell type separately
plts1 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.3) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})

layout <- matrix(seq(12))
plts1_grid <- gridExtra::grid.arrange(
                  grobs = plts1,
                  layout_matrix = layout
)
plts1_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_separateCts_AllBregmas.png"),
                plot = plts1_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

## -------------------------------------------------------------
## all cells with grid showing
plts2 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.4) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") #+
    #ggtitle(ix)
  ggplotGrob(p2)
})

layout <- matrix(seq(12))
plts2_grid <- gridExtra::grid.arrange(
                  grobs = plts2,
                  layout_matrix = layout
)
plts2_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_grid_AllBregmas.png"),
                plot = plts2_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## ground truth proportions
plts3 <- lapply(names(simBregmasFN7), function(ix){
  breg <- gt$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]

  m <- as.matrix(gt$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = NA)
  ggplotGrob(p3)
})

layout <- matrix(seq(12))
plts3_grid <- gridExtra::grid.arrange(
                  grobs = plts3,
                  layout_matrix = layout
)
plts3_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_simST_AllBregmas.png"),
                plot = plts3_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## STdeconvolve proportions
plts4 <- lapply(names(simBregmasFN7), function(ix){

  breg <- gt$annotDf[gt$annotDf$Bregma == ix,]
  cellCounts <- gt$cellCounts[which(rownames(gt$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- gt$gtSpotTopics[spots,]

  m <- simulation[spots,]
  p <- cellCounts[, c("x", "y")]

  p4 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = FALSE,
                     plotTitle = NA)
  ggplotGrob(p4)
})

layout <- matrix(seq(12))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = plts4,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_STdeconvolve_AllBregmas.png"),
                plot = plts4_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

# layout <- t(matrix(seq(length((simBregmasFN7))*4), nrow=4))

```

## Correlations 

```{r}

## color by transcriptional similarity


# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

filt_theta <- lda_k12_135genes_theta
decon <- FN7_K12_135genes
gt <- simFN7_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
colnames(corMtx_txn) <- paste0("Cell-type ", colnames(corMtx_txn))
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## scale mtx:
corMtx_txn_rs <- apply(corMtx_txn_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_txn_rs <- t(corMtx_txn_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_txn_rs) <- colnames(corMtx_txn_1)

corMtx_txn_cs <- apply(corMtx_txn_rs, 2, scale)
rownames(corMtx_txn_cs) <- rownames(corMtx_txn_1)


## plot the txn correlations
dat <- reshape2::melt(corMtx_txn) #  corMtx_txn_1
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_txn_corr_heatmap.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)


dat <- reshape2::melt(corMtx_txn_1) #  corMtx_txn_1
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_txn_corr_heatmap.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

## scale mtx:
corMtx_prop_rs <- apply(corMtx_prop_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_prop_rs <- t(corMtx_prop_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_prop_rs) <- colnames(corMtx_prop_1)

corMtx_prop_cs <- apply(corMtx_prop_rs, 2, scale)
rownames(corMtx_prop_cs) <- rownames(corMtx_prop_1)

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1) #  corMtx_prop_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_prop_corr_heatmap_txn_ordered_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_prop_corr_heatmap_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")



# ## correlations are between matched cell-types.
# ## custom switch:
# ## cell-type 7 inhibitory based on marker genes
# ## cell-type 2 excitatory based on marker genes
# transcriptional <- diag(corMtx_txn_1)
# transcriptional[7] <- corMtx_txn_1["Inhibitory", "Cell-type 7"]
# transcriptional[8] <- corMtx_txn_1["Inhibitory", "Cell-type 2"]
# 
# proportional <- diag(corMtx_prop_4)
# proportional[7] <- corMtx_prop_4["Inhibitory", "Cell-type 7"]
# proportional[8] <- corMtx_prop_4["Inhibitory", "Cell-type 2"]
# 
# ## boxplot summary of correlations
# dat3 <- reshape2::melt(data.frame(
#                                   transcriptional = transcriptional,
#                                   # proportional_txn = diag(corMtx_prop_1),
#                                   # proportional_prop = diag(corMtx_prop_4)
#                                   proportional = proportional
#                                   ))
# colnames(dat3) <- c("Comparison", "Correlation")
# ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
#   # ggplot2::geom_violin(trim=TRUE, fill="gray") +
#   ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
#   ggplot2::geom_jitter(width = 0.2) +
#   ylim(c(-1,1)) +
#   ggplot2::scale_fill_grey() +
#   ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
#                 x = "Comparison",
#                 y = "Correlation") +
#   ggplot2::theme_classic() +
#   ggplot2::theme(axis.text.x=element_text(size=15),
#                  axis.text.y=element_text(size=15),
#                  axis.title.y=element_text(size=15),
#                  axis.title.x=element_blank(),
#                  plot.title=element_text(size=15))
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_heatmap_daig_corrs_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 2.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# 
# ## record final matches:
# gt_matches <- rownames(corMtx_txn_1)
# ct_matches <- colnames(corMtx_txn_1)
# names(gt_matches) <- ct_matches
# gt_matches[7] <- "Inhibitory"
# gt_matches[8] <- "Inhibitory"
# 



## adjust the deconvolved pixel proportions based on the new match assignment of cell-types

filt_theta_adj <- filt_theta

## correlations first, then agreement that most match up will with top differentially expressed genes for gt cell-types
## helps to assign cell-types that fall into same ground truths, like the inhibitory and excitatory

assignment <- c("Ependymal", "Inhibitory", "Pericytes", "Inhibitory", "OD Mature", "Endothelial", "Inhibitory", "Excitatory", "OD Immature", "Inhibitory", "Excitatory", "Excitatory")

filt_theta_adj <- cbind(filt_theta_adj,
                        rowSums(filt_theta[,c("2","4","7","10")]), # inhibitory
                        rowSums(filt_theta[,c("8","11","12")]) # excitatory
                        )

## cell-types assigned based on above, need to add in microglia and astrocyte columns
filt_theta_adj <- cbind(filt_theta_adj, rep(0, dim(filt_theta_adj)[1]))
filt_theta_adj <- cbind(filt_theta_adj, rep(0, dim(filt_theta_adj)[1]))

colnames(filt_theta_adj) <- c("Ependymal", "drop", "Pericytes", "drop", "OD Mature", "Endothelial", "drop", "drop", "OD Immature", "drop", "drop", "drop", "Inhibitory", "Excitatory", "Microglia", "Astrocyte")

filt_theta_adj <- filt_theta_adj[,ct_txn_order]


## proportional pairing based on the combined and matched cts:

corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta_adj,
                         type = "t")
corMtx_prop_4[is.na(corMtx_prop_4)] <- 0
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  proportional = diag(corMtx_prop_4)
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_heatmap_daig_corrs_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 2.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)


## proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")

gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  Rowv = NULL,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Major cell class",
                  # ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))


# # -----------------------------------------
# t_raw <- data.frame(gt$gtSpotTopics[,ct_txn_order], group = "Actual")
# p_raw <- data.frame(filt_theta_adj[,ct_txn_order], group = "Deconvolved")
# dat <- rbind(t_raw, p_raw)
# 
# ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   labs(title = "Deconvolved pixel proportions versus ground truth",
#        x = "Cell-type match", y = "pixel proportions") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         axis.text.y=element_text(size = 15),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_text(size=15),
#         axis.title.y=element_text(size=15),
#         panel.background=element_blank()
#         )
# # -----------------------------------------

```

# k = 76 135 genes

## deepsplit 4

```{r}

FN7_K76_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_135genes, opt = 76),
                         corpus = as.matrix(simFN7_neuro_9ct_135genes$sim),
                         deepSplit = 4,
                         colorScheme = "rainbow")

lda_k76_135genes_theta <- FN7_K76_135genes$theta
lda_k76_135genes_theta[lda_k76_135genes_theta < 0.025] <- 0

# readjust proportions
lda_k76_135genes_theta <- lda_k76_135genes_theta/rowSums(lda_k76_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k76_135genes_theta[is.na(lda_k76_135genes_theta)] <- 0

summary(lda_k76_135genes_theta)

ggplot(data = reshape2::melt(lda_k76_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k76_135genes_theta <- lda_k76_135genes_theta[,which(colSums(lda_k76_135genes_theta) > 0)]

```

## deepsplit 1

```{r}

FN7_K76_135genes_ds1 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_135genes, opt = 76),
                         corpus = as.matrix(simFN7_neuro_9ct_135genes$sim),
                         deepSplit = 1,
                         colorScheme = "rainbow")

## 0 = 8 clusters
## 1 = 13 clusters

```

```{r}

lda_k76_135genes_theta_ds1 <- FN7_K76_135genes_ds1$thetaCombn
lda_k76_135genes_theta_ds1[lda_k76_135genes_theta_ds1 < 0.025] <- 0

# readjust proportions
lda_k76_135genes_theta_ds1 <- lda_k76_135genes_theta_ds1/rowSums(lda_k76_135genes_theta_ds1)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k76_135genes_theta_ds1[is.na(lda_k76_135genes_theta_ds1)] <- 0

summary(lda_k76_135genes_theta_ds1)

ggplot(data = reshape2::melt(lda_k76_135genes_theta_ds1)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k76_135genes_theta_ds1 <- lda_k76_135genes_theta_ds1[,which(colSums(lda_k76_135genes_theta_ds1) > 0)]

```


```{r}

filt_theta <- lda_k76_135genes_theta_ds1
decon <- FN7_K76_135genes_ds1
gt <- simFN7_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$betaCombn,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## scale mtx:
corMtx_txn_rs <- apply(corMtx_txn_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_txn_rs <- t(corMtx_txn_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_txn_rs) <- colnames(corMtx_txn_1)

corMtx_txn_cs <- apply(corMtx_txn_rs, 2, scale)
rownames(corMtx_txn_cs) <- rownames(corMtx_txn_1)


## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1) #  corMtx_txn_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-B-txn_corr-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$betaCombn,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

## scale mtx:
corMtx_prop_rs <- apply(corMtx_prop_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_prop_rs <- t(corMtx_prop_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_prop_rs) <- colnames(corMtx_prop_1)

corMtx_prop_cs <- apply(corMtx_prop_rs, 2, scale)
rownames(corMtx_prop_cs) <- rownames(corMtx_prop_1)

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1) #  corMtx_prop_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("Figure_2-E-proportion_corr-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_prop_corr_heatmap_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")



# ## correlations are between matched cell-types.
# ## custom switch:
# ## cell-type 7 inhibitory based on marker genes
# ## cell-type 2 excitatory based on marker genes
# transcriptional <- diag(corMtx_txn_1)
# transcriptional[7] <- corMtx_txn_1["Inhibitory", "Cell-type 7"]
# transcriptional[8] <- corMtx_txn_1["Inhibitory", "Cell-type 2"]
# 
# proportional <- diag(corMtx_prop_4)
# proportional[7] <- corMtx_prop_4["Inhibitory", "Cell-type 7"]
# proportional[8] <- corMtx_prop_4["Inhibitory", "Cell-type 2"]

## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = transcriptional,
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = proportional
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
# ggplot2::ggsave(filename = paste0("Figure_2-F-matched_ct_corrs_boxplots-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 2.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)


## record final matches:
# gt_matches <- rownames(corMtx_txn_1)
# ct_matches <- colnames(corMtx_txn_1)
# names(gt_matches) <- ct_matches
# gt_matches[7] <- "Inhibitory"
# gt_matches[8] <- "Inhibitory"

## adjust the deconvolved pixel proportions based on the new match assignment of cell-types

# filt_theta_adj <- filt_theta[,pairs$colsix]
# filt_theta_adj <- cbind(filt_theta_adj, rowSums(filt_theta[,c("4","7","8")]))
# colnames(filt_theta_adj) <- c("OD Immature", "Excitatory",  "drop",  "Astrocyte", "Ependymal", "Endothelial", "Pericytes",   "Microglia", "OD Mature", "Inhibitory")
# 
# filt_theta_adj <- filt_theta_adj[,ct_txn_order]
# filt_theta_adj[,"Microglia"] <- 0
# filt_theta_adj[,"Pericytes"] <- 0

# # -----------------------------------------
# t_raw <- data.frame(gt$gtSpotTopics[,ct_txn_order], group = "Actual")
# p_raw <- data.frame(filt_theta_adj[,ct_txn_order], group = "Deconvolved")
# dat <- rbind(t_raw, p_raw)
# 
# ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   labs(title = "Deconvolved pixel proportions versus ground truth",
#        x = "Cell-type match", y = "pixel proportions") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         axis.text.y=element_text(size = 15),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_text(size=15),
#         axis.title.y=element_text(size=15),
#         panel.background=element_blank()
#         )
# # -----------------------------------------

# proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics),
                         m2 = filt_theta,
                         type = "t")

gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))


gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))

```

## deepsplit 0

```{r}

FN7_K76_135genes_ds0 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_135genes, opt = 76),
                         corpus = as.matrix(simFN7_neuro_9ct_135genes$sim),
                         deepSplit = 0,
                         colorScheme = "rainbow")

## 0 = 8 clusters
## 1 = 13 clusters

```

```{r}

lda_k76_135genes_theta_ds0 <- FN7_K76_135genes_ds0$thetaCombn
lda_k76_135genes_theta_ds0[lda_k76_135genes_theta_ds0 < 0.025] <- 0

# readjust proportions
lda_k76_135genes_theta_ds0 <- lda_k76_135genes_theta_ds0/rowSums(lda_k76_135genes_theta_ds0)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k76_135genes_theta_ds0[is.na(lda_k76_135genes_theta_ds0)] <- 0

summary(lda_k76_135genes_theta_ds0)

ggplot(data = reshape2::melt(lda_k76_135genes_theta_ds0)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k76_135genes_theta_ds0 <- lda_k76_135genes_theta_ds0[,which(colSums(lda_k76_135genes_theta_ds0) > 0)]

```

if more ground truths than deconvovled cell-types

```{r}

filt_theta <- lda_k76_135genes_theta_ds0
decon <- FN7_K76_135genes_ds0
gt <- simFN7_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$betaCombn,
                         type = "b")

# proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics),
                         m2 = filt_theta,
                         type = "t")

gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))


gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,15))

```

results are kind of like what 

## Correlations 

```{r}

simulation <- lda_k76_135genes_theta
gt <- simFN7_neuro_9ct_135genes

clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D", ## ward.D
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  # ggplot2::xlab("Ground truth cell-types") +
  # ggplot2::ylab("Deconvolved cell-types") +
  # ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=6),
                 axis.text.y=element_text(angle=0, size=6),
                 axis.title.y=element_blank(),
                 axis.title.x=element_blank(),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-F-txn_corr-76gt_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```

```{r}

gt <- simFN7_neuro_9ct_135genes
decon <- FN7_K76_135genes
filt_theta <- lda_k76_135genes_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## scale mtx:
corMtx_txn_rs <- apply(corMtx_txn_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_txn_rs <- t(corMtx_txn_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_txn_rs) <- colnames(corMtx_txn_1)

corMtx_txn_cs <- apply(corMtx_txn_rs, 2, scale)
rownames(corMtx_txn_cs) <- rownames(corMtx_txn_1)


## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1) #  corMtx_txn_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("Supplemental_Figure_S3-B-txn_corr-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

## scale mtx:
corMtx_prop_rs <- apply(corMtx_prop_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_prop_rs <- t(corMtx_prop_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_prop_rs) <- colnames(corMtx_prop_1)

corMtx_prop_cs <- apply(corMtx_prop_rs, 2, scale)
rownames(corMtx_prop_cs) <- rownames(corMtx_prop_1)

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1) #  corMtx_prop_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("Figure_2-E-proportion_corr-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_9cts_135genes_prop_corr_heatmap_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")



## correlations are between matched cell-types.
## custom switch:
## cell-type 7 inhibitory based on marker genes
## cell-type 2 excitatory based on marker genes
transcriptional <- diag(corMtx_txn_1)
# transcriptional[7] <- corMtx_txn_1["Inhibitory", "Cell-type 7"]
# transcriptional[8] <- corMtx_txn_1["Inhibitory", "Cell-type 2"]

proportional <- diag(corMtx_prop_4)
# proportional[7] <- corMtx_prop_4["Inhibitory", "Cell-type 7"]
# proportional[8] <- corMtx_prop_4["Inhibitory", "Cell-type 2"]

## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = transcriptional,
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = proportional
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
# ggplot2::ggsave(filename = paste0("Figure_2-F-matched_ct_corrs_boxplots-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 2.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)


# ## record final matches:
# gt_matches <- rownames(corMtx_txn_1)
# ct_matches <- colnames(corMtx_txn_1)
# names(gt_matches) <- ct_matches
# gt_matches[7] <- "Inhibitory"
# gt_matches[8] <- "Inhibitory"
# 
# ## adjust the deconvolved pixel proportions based on the new match assignment of cell-types
# 
# filt_theta_adj <- filt_theta[,pairs$colsix]
# filt_theta_adj <- cbind(filt_theta_adj, rowSums(filt_theta[,c("4","7","8")]))
# colnames(filt_theta_adj) <- c("OD Immature", "Excitatory",  "drop",  "Astrocyte", "Ependymal", "Endothelial", "Pericytes",   "Microglia", "OD Mature", "Inhibitory")
# 
# filt_theta_adj <- filt_theta_adj[,ct_txn_order]
# filt_theta_adj[,"Microglia"] <- 0
# filt_theta_adj[,"Pericytes"] <- 0
# 
# # # -----------------------------------------
# # t_raw <- data.frame(gt$gtSpotTopics[,ct_txn_order], group = "Actual")
# # p_raw <- data.frame(filt_theta_adj[,ct_txn_order], group = "Deconvolved")
# # dat <- rbind(t_raw, p_raw)
# # 
# # ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
# #   # geom_boxplot() +
# #   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
# #   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
# #   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
# #   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
# #   labs(title = "Deconvolved pixel proportions versus ground truth",
# #        x = "Cell-type match", y = "pixel proportions") +
# #   theme_classic() +
# #   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
# #         # panel.grid = element_blank(),
# #         # axis.line=element_blank(),
# #         # axis.text.x=element_blank(),
# #         axis.text.y=element_text(size = 15),
# #         # axis.ticks=element_blank(),
# #         axis.title.x=element_text(size=15),
# #         axis.title.y=element_text(size=15),
# #         panel.background=element_blank()
# #         )
# # # -----------------------------------------
# 
# ## proportional correlations of all cell-types before combining and clustered
# corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics),
#                          m2 = filt_theta,
#                          type = "t")
# 
# gplots::heatmap.2(x = corMtx_prop_5,
#                   density.info = "none",
#                   trace = "none",
#                   Rowv = clust$dendro,
#                   # Colv = clust$dendro,
#                   col = correlation_palette,
#                   breaks = correlation_breaks,
#                   key.xlab = "Correlation",
#                   xlab = "Deconvolved cell-types",
#                   ylab = "Ground truth cell-types",
#                   key.title = NA,
#                   cexRow = 0.9,
#                   cexCol = 0.9,
#                   # lhei = c(1,3),
#                   margins = c(6,15))

```

```{r}

filt_theta <- lda_k76_135genes_theta
decon <- FN7_K76_135genes
gt <- simFN7_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$betaCombn,
                         type = "b")

# proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics),
                         m2 = filt_theta,
                         type = "t")

gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.5,
                  # lhei = c(1,3),
                  margins = c(6,15))


gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  Rowv = clust$dendro,
                  # Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Deconvolved cell-types",
                  ylab = "Ground truth cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.5,
                  # lhei = c(1,3),
                  margins = c(6,15))

```

```{r, fig.height=10, fig.width=15}

filt_theta <- lda_k9_135genes_theta
decon <- FN7_K9_135genes
gt <- simFN7_neuro_9ct_135genes

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])



## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = decon$beta,
                         m2 = as.matrix(gt$gtCtGenes),
                         type = "b")

# proportional correlations of all cell-types before combining and clustered
corMtx_prop_5 <- getCorrMtx(m1 = filt_theta,
                         m2 = as.matrix(gt$gtSpotTopics)[,rownames(as.matrix(gt$gtCtGenes))],
                         type = "t")



gplots::heatmap.2(x = corMtx_prop_5,
                  density.info = "none",
                  trace = "none",
                  # Rowv = clust$dendro,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Ground truth cell-types",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 2,
                  cexCol = 2,
                  # lhei = c(1,3),
                  margins = c(20,3))


gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  # Rowv = clust$dendro,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Ground truth cell-types",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 2,
                  cexCol = 1,
                  # lhei = c(1,3),
                  margins = c(20,4))

pdf(file = paste0(fig_path, "Supplemental_Figure_S3-E-txn_corr-100um_k9_ct9_135genes_vs76_gt.pdf"),
    width = 15, height = 10)
gplots::heatmap.2(x = corMtx_txn,
                  density.info = "none",
                  trace = "none",
                  # Rowv = clust$dendro,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Ground truth cell-types",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 2,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(20,4))
dev.off()

```

Shows how expanding K gets good correlations.

Then if do expanded 76 gt and 76 ct, then see that also decent performance

```{r, fig.height=10, fig.width=15}

gt <- simFN7_neuro_9ct_135genes
decon <- FN7_K76_135genes
filt_theta <- lda_k76_135genes_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = decon$beta,
                         m2 = as.matrix(gt$gtCtGenes),
                         type = "b")

## for pairing:
corMtx_txn_ <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn_)

gplots::heatmap.2(x = corMtx_txn[pairs$colsix,],
                  density.info = "none",
                  trace = "none",
                  Rowv = NA,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(8,4))

# figure g
pdf(file = paste0(fig_path, "Supplemental_Figure_S3-G-txn_corr-100um_k76_ct76_135genes_vs76_gt.pdf"),
    width = 15, height = 15)
gplots::heatmap.2(x = corMtx_txn[pairs$colsix,],
                  density.info = "none",
                  trace = "none",
                  Rowv = NA,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(8,4))
dev.off()

txncorrs <- corMtx_txn[pairs$colsix,clust$order]



# figure h
corMtx_prop <- getCorrMtx(m1 = filt_theta[,rownames(corMtx_txn[pairs$colsix,])],
                         m2 = as.matrix(gt$gtSpotTopics)[,rownames(as.matrix(gt$gtCtGenes))],
                         type = "t")
gplots::heatmap.2(x = corMtx_prop,
                  density.info = "none",
                  trace = "none",
                  Rowv = NA,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(8,4))

pdf(file = paste0(fig_path, "Supplemental_Figure_S3-H-prop_corr-100um_k76_ct76_135genes_vs76_gt.pdf"),
    width = 15, height = 15)
gplots::heatmap.2(x = corMtx_prop,
                  density.info = "none",
                  trace = "none",
                  Rowv = NA,
                  Colv = clust$dendro,
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "",
                  ylab = "Deconvolved cell-types",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(8,4))
dev.off()

propcorrs <- corMtx_prop[,clust$order]


## boxplot summary of correlations
dat <- reshape2::melt(data.frame(
                                  transcriptional = diag(txncorrs),
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = diag(propcorrs)
                                  ))
colnames(dat) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
# ggplot2::ggsave(filename = paste0("Figure_2-F-matched_ct_corrs_boxplots-100um_k9_ct9_135genes.pdf"),
#          device = "pdf",
#          path = fig_path,
#          scale = 1.5,
#          width = 2.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)




```

## -----------------

## SPOTlight models

### 9 cell-types 135 genes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur_9ct_135genes) <- bregmaFN7FullSeur_9ct_135genes@meta.data$Major_class

levels(bregmaFN7FullSeur_9ct_135genes@active.ident)

Seur_9ct_135genes_markers <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur_9ct_135genes,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

set.seed(888)

SL_fit_9ct_135genes <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur_9ct_135genes,
  counts_spatial = t(as.matrix(simFN7_9ct_135genes$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = Seur_9ct_135genes_markers, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

sl_9ct_135genes <- SPOTlightPredict(nmfRef = SL_fit_9ct_135genes[[1]], stCounts = t(as.matrix(simFN7_9ct_135genes$sim)))


sl_k9_135genes_theta <- sl_9ct_135genes$thetaCt
sl_k9_135genes_theta[sl_k9_135genes_theta < 0.025] <- 0

# readjust proportions
sl_k9_135genes_theta <- sl_k9_135genes_theta/rowSums(sl_k9_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_k9_135genes_theta[is.na(sl_k9_135genes_theta)] <- 0

summary(sl_k9_135genes_theta)

ggplot(data = reshape2::melt(sl_k9_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_k9_135genes_theta <- sl_k9_135genes_theta[,which(colSums(sl_k9_135genes_theta) > 0)]

# ------------------------------------------------------------------

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur_9ct_135genes) <- bregmaFN7FullSeur_9ct_135genes@meta.data$All_classes

levels(bregmaFN7FullSeur_9ct_135genes@active.ident)

Seur_76ct_135genes_markers_neuro <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur_9ct_135genes,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

set.seed(888)

SL_fit_76ct_135genes_neuro <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur_9ct_135genes,
  counts_spatial = t(as.matrix(simFN7_9ct_135genes$sim)),
  clust_vr = "All_classes", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = Seur_76ct_135genes_markers_neuro, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

sl_76ct_135genes_neuro <- SPOTlightPredict(nmfRef = SL_fit_76ct_135genes_neuro[[1]], stCounts = t(as.matrix(simFN7_9ct_135genes$sim)))


sl_k76_135genes_theta <- sl_76ct_135genes_neuro$thetaCt
sl_k76_135genes_theta[sl_k76_135genes_theta < 0.025] <- 0

# readjust proportions
sl_k76_135genes_theta <- sl_k76_135genes_theta/rowSums(sl_k76_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_k76_135genes_theta[is.na(sl_k76_135genes_theta)] <- 0

summary(sl_k76_135genes_theta)

ggplot(data = reshape2::melt(sl_k76_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_k76_135genes_theta <- sl_k76_135genes_theta[,which(colSums(sl_k76_135genes_theta) > 0)]

```

### 135 genes no neuronal

```{r}

# remove neuronal cells
no_neuronal_9ct_135genes_df <- simFN7_9ct_135genes$annotDf[which(!simFN7_9ct_135genes$annotDf$Cell_class %in% c("Excitatory", "Inhibitory")),]
bregmaCellsGexpFN7_noNeuro <- bregmaCellsGexpFN7[rownames(no_neuronal_9ct_135genes_df),]
dim(bregmaCellsGexpFN7_noNeuro)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_9ct_135genes_noNeuro <- CreateSeuratObject(counts = t(bregmaCellsGexpFN7_noNeuro), project = "9ct 135 genes no neuro")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_9ct_135genes_noNeuro[["Major_class"]] <- no_neuronal_9ct_135genes_df$Cell_class


# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur_9ct_135genes_noNeuro) <- bregmaFN7FullSeur_9ct_135genes_noNeuro@meta.data$Major_class

levels(bregmaFN7FullSeur_9ct_135genes_noNeuro@active.ident)


bregmaFN7FullSeur_9ct_135genes_noNeuro_markers <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur_9ct_135genes_noNeuro,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

set.seed(888)

SL_fit_9ct_135genes_noNeuro <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur_9ct_135genes_noNeuro,
  counts_spatial = t(as.matrix(simFN7_9ct_135genes$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFN7FullSeur_9ct_135genes_noNeuro_markers, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

sl_9ct_135genes_noNeuro <- SPOTlightPredict(nmfRef = SL_fit_9ct_135genes_noNeuro[[1]], stCounts = t(as.matrix(simFN7_9ct_135genes$sim)))


sl_k9_135genes_noNeuro_theta <- sl_9ct_135genes_noNeuro$thetaCt
sl_k9_135genes_noNeuro_theta[sl_k9_135genes_noNeuro_theta < 0.025] <- 0

# readjust proportions
sl_k9_135genes_noNeuro_theta <- sl_k9_135genes_noNeuro_theta/rowSums(sl_k9_135genes_noNeuro_theta)
# if NAs because all cts are 0 in a spot, replace with 0
sl_k9_135genes_noNeuro_theta[is.na(sl_k9_135genes_noNeuro_theta)] <- 0

summary(sl_k9_135genes_noNeuro_theta)

ggplot(data = reshape2::melt(sl_k9_135genes_noNeuro_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
sl_k9_135genes_noNeuro_theta <- sl_k9_135genes_noNeuro_theta[,which(colSums(sl_k9_135genes_noNeuro_theta) > 0)]

```


## RCTD models

### 9 cell-types 135 genes

reference
```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_9ct_135gene_ref/"

ref <- bregmaFN7FullSeur_9ct_135genes

meta_ref <- ref@meta.data[,c("Major_class", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

data sets
```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7_135genes/"
d <- simFN7_9ct_135genes

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_9ct_135gene_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7_135genes/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7 <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_fit <- RCTD::run.RCTD(RCTD_FN7, doublet_mode = TRUE)

RCTD_FN7_results <- RCTD_FN7_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_9ct_135genes_results_norm <-  sweep(RCTD_FN7_results$weights, 1, rowSums(RCTD_FN7_results$weights), '/')


rctd_9ct_135genes_theta <- as.matrix(RCTD_9ct_135genes_results_norm)
rctd_9ct_135genes_theta[rctd_9ct_135genes_theta < 0.025] <- 0

# readjust proportions
rctd_9ct_135genes_theta <- rctd_9ct_135genes_theta/rowSums(rctd_9ct_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_9ct_135genes_theta[is.na(rctd_9ct_135genes_theta)] <- 0

summary(rctd_9ct_135genes_theta)

ggplot(data = reshape2::melt(rctd_9ct_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_9ct_135genes_theta <- rctd_9ct_135genes_theta[,which(colSums(rctd_9ct_135genes_theta) > 0)]

```

### 76 cell-types 135 genes

reference
```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_76ct_135gene_ref/"

ref <- bregmaFN7FullSeur_9ct_135genes

meta_ref <- ref@meta.data[,c("All_classes", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$All_classes),
                         Name = unique(ref@meta.data$All_classes)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

data sets
```{r}

# p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7_135genes/"
# d <- simFN7_9ct_135genes
# 
# x <- as.data.frame(t(as.matrix(d$sim)))
# cols <- colnames(x)
# x$Row.names <- rownames(x)
# x <- x[,c("Row.names", cols)]
# write.table(x=x, sep = ",",
#             col.names = colnames(x),
#             row.names = FALSE,
#             file=paste0(p, "MappedDGEForR.csv"))
# 
# beads <- d$cellCounts[,c("x", "y")]
# colnames(beads) <- c("xcoord", "ycoord")
# beads$barcodes <- rownames(beads)
# beads <- beads[,c("barcodes", "xcoord", "ycoord")]
# write.table(x=beads,
#             sep = ",",
#             row.names = FALSE,
#             file=paste0(p, "BeadLocationsForR.csv"))

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_76ct_135gene_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7_135genes/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7 <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_fit <- RCTD::run.RCTD(RCTD_FN7, doublet_mode = TRUE)

RCTD_FN7_results <- RCTD_FN7_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_76ct_135genes_results_norm <-  sweep(RCTD_FN7_results$weights, 1, rowSums(RCTD_FN7_results$weights), '/')


rctd_76ct_135genes_theta <- as.matrix(RCTD_76ct_135genes_results_norm)
rctd_76ct_135genes_theta[rctd_76ct_135genes_theta < 0.025] <- 0

# readjust proportions
rctd_76ct_135genes_theta <- rctd_76ct_135genes_theta/rowSums(rctd_76ct_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_76ct_135genes_theta[is.na(rctd_76ct_135genes_theta)] <- 0

summary(rctd_76ct_135genes_theta)

ggplot(data = reshape2::melt(rctd_76ct_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_76ct_135genes_theta <- rctd_76ct_135genes_theta[,which(colSums(rctd_76ct_135genes_theta) > 0)]

```

### 135 genes no neuronal

reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_9ct_135gene_no_neuro_ref/"

ref <- bregmaFN7FullSeur_9ct_135genes_noNeuro

meta_ref <- ref@meta.data[,c("Major_class", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregmaFullFN7_9ct_135gene_no_neuro_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/0draft_data/RCTD/bregma_datasets/FN7_135genes/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7_noNeuro <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_noNeuro_fit <- RCTD::run.RCTD(RCTD_FN7_noNeuro, doublet_mode = TRUE)

RCTD_FN7_noNeuro_results <- RCTD_FN7_noNeuro_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_9ct_135genes_noNeuro_results_norm <-  sweep(RCTD_FN7_noNeuro_results$weights, 1, rowSums(RCTD_FN7_noNeuro_results$weights), '/')



rctd_9ct_135genes_noNeuro_theta <- as.matrix(RCTD_9ct_135genes_noNeuro_results_norm)
rctd_9ct_135genes_noNeuro_theta[rctd_9ct_135genes_noNeuro_theta < 0.025] <- 0

# readjust proportions
rctd_9ct_135genes_noNeuro_theta <- rctd_9ct_135genes_noNeuro_theta/rowSums(rctd_9ct_135genes_noNeuro_theta)
# if NAs because all cts are 0 in a spot, replace with 0
rctd_9ct_135genes_noNeuro_theta[is.na(rctd_9ct_135genes_noNeuro_theta)] <- 0

summary(rctd_9ct_135genes_noNeuro_theta)

ggplot(data = reshape2::melt(rctd_9ct_135genes_noNeuro_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
rctd_9ct_135genes_noNeuro_theta <- rctd_9ct_135genes_noNeuro_theta[,which(colSums(rctd_9ct_135genes_noNeuro_theta) > 0)]

```

# check

```{r}

## SL 9 cts and 135 genes from sl deconvolution
SL_fit_9ct_135genes
## 9 cts present, 131 genes actually kept as marker genes

## from SPOTlightPredict script
sl_9ct_135genes

## filtered out cts < 0.025
sl_k9_135genes_theta

## all check out



## SL 76 cts and 135 genes from sl deconvolution
SL_fit_76ct_135genes_neuro
## 76 cts and 131 genes kept as marker genes

## from SPOTlightPredict script
sl_76ct_135genes_neuro

## filtered out cts < 0.025
sl_k76_135genes_theta

## all check out


## SL 7 cts (9 - 2 neuronals) and 135 genes from sl deconvolution
SL_fit_9ct_135genes_noNeuro
## the 7 cell-types but 129 genes kept as markers

## from SPOTlightPredict script
sl_9ct_135genes_noNeuro

## filtered out cts < 0.025
sl_k9_135genes_noNeuro_theta

## all check out

```

```{r}

### RCTD prediction
RCTD_9ct_135genes_results_norm
## 3070 pixels, 9 cell-types, 135 genes confirmed in data and reference

## filtered out cts < 0.025
rctd_9ct_135genes_theta

## all check out


### RCTD prediction
RCTD_76ct_135genes_results_norm
## 3070 pixels and I-39 and I-37 missing

rctd_76ct_135genes_theta
## 3070 pixels and I-39 and I-37 missing

## all check out


### RCTD prediction
RCTD_9ct_135genes_noNeuro_results_norm

## filtered out cts < 0.025
rctd_9ct_135genes_noNeuro_theta

## all check out

```

# save

```{r}

save(
  ## SL 9 cts and 135 genes from sl deconvolution
  SL_fit_9ct_135genes,
  ## from SPOTlghtPredict script
  sl_9ct_135genes,
  ## filtered out cts < 0.025
  sl_k9_135genes_theta,
  ## SL 76 cts and 135 genes from sl deconvolution
  SL_fit_76ct_135genes_neuro,
  ## from SPOTlightPredict script
  sl_76ct_135genes_neuro,
  ## filtered out cts < 0.025
  sl_k76_135genes_theta,
  ## SL 7 cts (9 - 2 neuronals) and 135 genes from sl deconvolution
  SL_fit_9ct_135genes_noNeuro,
  ## from SPOTlightPredict script
  sl_9ct_135genes_noNeuro,
  ## filtered out cts < 0.025
  sl_k9_135genes_noNeuro_theta,
  ### RCTD prediction
  RCTD_9ct_135genes_results_norm,
  ## filtered out cts < 0.025
  rctd_9ct_135genes_theta,
  ### RCTD prediction
  RCTD_76ct_135genes_results_norm,
  ## filtered out cts < 0.025
  rctd_76ct_135genes_theta,
  ### RCTD prediction
  RCTD_9ct_135genes_noNeuro_results_norm,
  ## filtered out cts < 0.025
  rctd_9ct_135genes_noNeuro_theta,
  file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_v2-9cts_135genes_SL_RCTD_models.RData"
)

```


# ======================
## 10um Sim

this generates the hash tables of simulates spots for each bregma separately

```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 10)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 10)

```

Generate each simulated corpus for each simulated bregma:

Major cell types

```{r}

simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)

```

Recall that the `$gtSpotTopics` of each simulated corpus are of primary interest to compare the fitted models to for each bregma.

The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches and so should be ignored if looking at the entire animal.

Combine the simulated bregmas in the `simBregma` lists to make a single corpus for all bregmas to train a single model.
The `gtSpotTopics` can be combined as well for a ground truth reference, but each `gtCtGenes` is built using just the cells in each given bregma. So instead use the `gtCtGenesFN7` or `gtCtNeuronalGenesFN7`, which were average gexp for cell types across all cells.


Combine the simulated matrices for each bregma into one corpus:

Major cell types

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_10um <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)

```

Neuronal subtypes:

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro_10um <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```

at 10um, most simulated pixels are actual single cells with a few doublets. very rare triplets

```{r}

# hist(rowSums(simFN7_10um$gtSpotTopics > 0))

table(rowSums(simFN7_10um$gtSpotTopics > 0))

```

## 20um Sim

this generates the hash tables of simulates spots for each bregma separately
```{r}

# simulate spots for each bregma and contain in a hash table
spatial_position_and_class_FN7$Cell_class <- Cell_class_major_FN7
FN7_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 20)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro_hash <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 20)


simBregmasFN7 <- lapply(hash::keys(FN7_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- hash::keys(FN7_hash)

simBregmasFN7_neuro <- lapply(hash::keys(FN7_neuro_hash), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro_hash, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- hash::keys(FN7_neuro_hash)



# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_20um <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)



# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro_20um <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```


```{r}

# hist(rowSums(simFN7_10um$gtSpotTopics > 0))

table(rowSums(simFN7_20um$gtSpotTopics > 0))

sum(table(rowSums(simFN7_20um$gtSpotTopics > 0)))


```

## seurat input

```{r}

dim(bregmaCellsGexpFN7)

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simFN7$annotDf),]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur <- Seurat::CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "FN7 in pixels scRNAseq")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur[["Major_class"]] <- simFN7$annotDf$Cell_class
bregmaFN7FullSeur[["All_classes"]] <- simFN7_neuro$annotDf$Cell_class

```

# ----------------------------------
## 10 um 8 major

57397x125.

```{r}

# fit models to a range of K's that include 9 (for 8-9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
# ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

same corpus for `simFN7` and `simFN7_neuro` so can use either for model fitting

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs_10um <- fitLDA(counts = simFN7_10um$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
# dev.off()

```

```{r}

FN7_LDAs_10um_k8 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_10um, opt = 8),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

### viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(8)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7)[1], function(ix){
  
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  
  m <- FN7_LDAs_10um_k8$theta[spots,]
  p <- simFN7_10um$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 5,
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
  
  # set.seed(8)
  # 
  # m <- simFN7$gtSpotTopics[spots,] # The ground truth proportions for 9 major cts
  # p <- simFN7$cellCounts[spots, c("x", "y")] # the positions of sim spots for the bregma -0.04
  # 
  # vizAllTopics(theta = m,
  #              pos = p,
  #              topicOrder=seq(ncol(m)),
  #              topicCols=randomcoloR::distinctColorPalette(ncol(m)),
  #              groups = NA,
  #              group_cols = NA,
  #              r = 40,
  #              lwd = 0.5,
  #              showLegend = TRUE,
  #              plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-3_FN7_gt_8_mjrcts_", ix, ".pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
  
})

```

### theta correlation

FN7 fitted with k=8 major cell types (ambiguous removed)

```{r}

corMtx <- getCorrMtx(m1 = FN7_LDAs_10um_k8$theta,
                           m2 = as.matrix(simFN7_10um$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

```

### beta correlation

```{r}

corMtx <- getCorrMtx(m1 = FN7_LDAs_10um_k8$beta,
                     m2 = as.matrix(simFN7_10um$gtCtGenes), # gt made from cells in bregma
                     type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = corMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(corMtx)
gplots::heatmap.2(x = corMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

```

```{r}

mat <- FN7_LDAs_10um_k8$theta
mat[mat < 0.3] <- 0

a <- rowSums(mat > 0)
b <- rowSums(simFN7_10um$gtSpotTopics > 0)

table(a)
table(b)

```

### singles, doublets

```{r}

print("percentages")
print("doublets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)

print("predicted doublets that were actually doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2))))*100, 2)
print("predicted doublets that were actually singlets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(a == 2))))*100, 2)

```

```{r}

print("percentages")
print("singlets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)

print("predicted singlets that were actually singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1))))*100, 2)
print("predicted singlets that were actually doublets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(a == 1))))*100, 2)

```

Seems to do really well detecting singlets, but most predicted doublets are actually singlets. Does poor job detecting doublets.
# ----------------------------------
## 20 um 9 cts 135 genes

45978x125 corpus

```{r}

# fit models to a range of K's that include 9 (for 8-9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 20, by = 1)
# ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

same corpus for `simFN7` and `simFN7_neuro` so can use either for model fitting

```{r}

FN7_LDAs_20um_135genes <- fitLDA(counts = as.matrix(simFN7_20um$sim),
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)

```

```{r}

FN7_LDAs_20um_k9_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_20um_135genes, opt = 9),
                                   corpus = as.matrix(simFN7_20um$sim),
                                   deepSplit = 4,
                                   colorScheme = "rainbow")

lda_20um_k9_135genes_theta <- FN7_LDAs_20um_k9_135genes$theta
lda_20um_k9_135genes_theta[lda_20um_k9_135genes_theta < 0.025] <- 0

# readjust proportions
lda_20um_k9_135genes_theta <- lda_20um_k9_135genes_theta/rowSums(lda_20um_k9_135genes_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_20um_k9_135genes_theta[is.na(lda_20um_k9_135genes_theta)] <- 0

summary(lda_20um_k9_135genes_theta)

ggplot(data = reshape2::melt(lda_20um_k9_135genes_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_20um_k9_135genes_theta <- lda_20um_k9_135genes_theta[,which(colSums(lda_20um_k9_135genes_theta) > 0)]

```

### Summary stats

```{r}

# summary(FN7_cellTypeTable)
# 
# # total cells in pixels
# print("total cells in pixels")
# summary(rowSums(FN7_cellTypeTable))
# # pdf(file = paste0(fig_path, "Fig_S1_cells-in-pixels.pdf"),   # The directory you want to save the file in
# #     width = 5, # The width of the plot in inches
# #     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_cellTypeTable), breaks = 20,
#      col = "white",
#      main = "",
#      xlab = "Number of cells",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# dev.off()

# -------------------------------------------------------------
# total cell types in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_cellTypeTable > 0), breaks = 8,
#      col = "white",
#      main = "",
#      xlab = "Number of cell-types",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# # dev.off()
# 
# print("cell types in pixels:")
# summary(rowSums(FN7_cellTypeTable > 0))
# 
# print("cell subtypes in pixels:")
# summary(rowSums(FN7_neuro_cellTypeTable > 0))

# -------------------------------------------------------------
# total cell subtypes in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
# par(mar=c(5,5,1,1)) # bottom, left, top, right margins
# hist(rowSums(FN7_neuro_cellTypeTable > 0), breaks = 20,
#      col = "white",
#      main = "",
#      xlab = "Number of cell-subtypes",
#      ylab = "Number of pixels",
#      cex.lab = 1,
#      cex.axis = 1)
# title(line = 0)
# dev.off()

# -------------------------------------------------------------
# cell-type proportions across spots (non-zero)
# pdf(file = paste0(fig_path, "Fig_S1_all-cell-types-proportions.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
hist(as.vector(simFN7_20um$gtSpotTopics[simFN7_20um$gtSpotTopics > 0]),
     breaks = 101,
     col = "white",
     main = "non-zero cell-type proportions in pixels",
     xlab = "Proportion",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
# dev.off()

print("cell types proportions in each pixel:")
summary(as.vector(simFN7_20um$gtSpotTopics[simFN7_20um$gtSpotTopics > 0]))
summary(simFN7_20um$gtSpotTopics)
print("cell subtypes proportions in each pixel:")
summary(as.vector(simFN7_neuro_20um$gtSpotTopics[simFN7_neuro_20um$gtSpotTopics > 0]))

```

```{r}

ggplot(data = reshape2::melt(simFN7_neuro_20um$gtSpotTopics)) +
  # geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  geom_jitter(aes(x = reorder(Var2, -value), y = value), position=position_jitter(0.1), cex=0.1) +
  scale_y_continuous(breaks = seq(0,1,0.05)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        )

```

### deconvolved gexp

```{r}

deconGexp <- FN7_LDAs_20um_k9_135genes$beta*1000
# counts <- as.matrix(simFN7_20um$sim)
for (i in seq(nrow(deconGexp))){
  celltype <- i
  vals <- sort(deconGexp[celltype,], decreasing = TRUE)
  
  ## ----------------------------------------------------
  ## txn profile, normalized and scaled expression
  
  dat <- data.frame(values = as.vector(vals), genes = names(vals), order = seq(length(vals)))
  # Hide all of the text labels.
  dat$selectedLabels <- ""
  # Let's just label these items.
  ix_label <- seq(10)
  dat$selectedLabels[ix_label] <- dat$genes[ix_label]
  
  p1 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels), size = 5, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 10, direction = "y", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=15),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p1)
  # ggplot2::ggsave(filename = paste0("4_k15_ct", celltype, "_txnProfile_barplot.png"),
  #          device = "png",
  #          path = fig_path,
  #          scale = 1.5,
  #          width = 5,
  #          height = 3,
  #          units = c("in"),
  #          dpi = 300)
  
  ## ----------------------------------------------------
  ## log2FC relative to other cell-types
  
  ## highly expressed in cell-type of interest
  highgexp <- names(which(deconGexp[celltype,] > 5))
  ## high log2(fold-change) compared to other deconvolved cell-types
  log2fc <- sort(log2(deconGexp[celltype,highgexp]/colMeans(deconGexp[-celltype,highgexp])), decreasing=TRUE)
  
  dat <- data.frame(values = as.vector(log2fc), genes = names(log2fc), order = seq(length(log2fc)))
  # Hide all of the text labels.
  dat$selectedLabels1 <- ""
  # Let's just label these top items.
  ix_label <- seq(10)
  dat$selectedLabels1[ix_label] <- dat$genes[ix_label]
  
  # dat$selectedLabels2 <- ""
  # # Let's label these bottom items
  # ix_label <- tail(seq(length(log2fc)), 5)
  # dat$selectedLabels2[ix_label] <- dat$genes[ix_label]
  
  p2 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "log2FC Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels1), size = 5, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2, direction = "y", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    # ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels2), size = 5, 
    #                 min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
    #                 # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
    #                 nudge_x = -10, direction = "y", hjust = "right",
    #                 # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    # ) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 0, size = 15),
          axis.text.y = element_text(size=15),
          # strip.text = element_text(size=15),
          axis.title.x = element_text(size=15),
          axis.title.y = element_text(size=12),
          axis.title=element_text(size=15),
          plot.title = element_text(size=15, face=NULL),
          )
  print(p2)
  ggplot2::ggsave(filename = paste0("0_20um_gt_9ct_deconvolved_ct_", celltype, "_txnProfile_log2FC_barplot.png"),
                  plot = p2,
                   device = "png",
                   path = fig_path,
                   scale = 1.5,
                   width = 5,
                   height = 3,
                   units = c("in"),
                   dpi = 300)
  
}
```

### Correlations 

```{r}

## color by transcriptional similarity


# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

filt_theta <- lda_20um_k9_135genes_theta
decon <- FN7_LDAs_20um_k9_135genes
gt <- simFN7_20um

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## scale mtx:
corMtx_txn_rs <- apply(corMtx_txn_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_txn_rs <- t(corMtx_txn_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_txn_rs) <- colnames(corMtx_txn_1)

corMtx_txn_cs <- apply(corMtx_txn_rs, 2, scale)
rownames(corMtx_txn_cs) <- rownames(corMtx_txn_1)


## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1) #  corMtx_txn_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(20 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S4-B-txn_corr-20um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

## scale mtx:
corMtx_prop_rs <- apply(corMtx_prop_1, 1, scale) # subtract row mean and divide by sd; essentially z-scores
corMtx_prop_rs <- t(corMtx_prop_rs) # apply returns each transformed row as a column in a new matrix. transpose
colnames(corMtx_prop_rs) <- colnames(corMtx_prop_1)

corMtx_prop_cs <- apply(corMtx_prop_rs, 2, scale)
rownames(corMtx_prop_cs) <- rownames(corMtx_prop_1)

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1) #  corMtx_prop_cs
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  # ggplot2::scale_fill_gradient(low = "white", high = "red",
  #                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(20 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S4-C-proportion_corr-20um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(20 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_20um_9cts_135genes_prop_corr_heatmap_after_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")



## correlations are between matched cell-types.
## custom switch:
## cell-type 7 inhibitory based on marker genes
## cell-type 2 inhibitory based on marker genes
transcriptional <- diag(corMtx_txn_1)
transcriptional[7] <- corMtx_txn_1["Inhibitory", "Cell-type 7"]
transcriptional[8] <- corMtx_txn_1["Inhibitory", "Cell-type 2"]

proportional <- diag(corMtx_prop_4)
proportional[7] <- corMtx_prop_4["Inhibitory", "Cell-type 7"]
proportional[8] <- corMtx_prop_4["Inhibitory", "Cell-type 2"]

## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = transcriptional,
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = proportional
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  # ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.21, outlier.shape = NA) +
  ggplot2::geom_jitter(width = 0.2) +
  ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S4-D-matched_ct_corrs_boxplots-20um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 2.5,
         height = 4,
         units = c("in"),
         dpi = 300)


## record final matches:
gt_matches_20um <- rownames(corMtx_txn_1)
ct_matches_20um <- colnames(corMtx_txn_1)
names(gt_matches_20um) <- ct_matches_20um
gt_matches_20um[7] <- "Inhibitory"
gt_matches_20um[8] <- "Inhibitory"

```

### Gene ranks

MERIGNUE differential genes for each cluster:

```{r}

# cells and their associated clusters
neuroClusters <- bregmaFN7FullSeur@meta.data$All_classes
names(neuroClusters) <- rownames(bregmaFN7FullSeur@meta.data)
# I-39 only has one cell so drop 
neuroClusters <- neuroClusters[which(!neuroClusters %in% c("I-39"))]
difGenesNeuro <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = neuroClusters)

# cells and their associated clusters
majorClusters <- bregmaFN7FullSeur@meta.data$Major_class
names(majorClusters) <- rownames(bregmaFN7FullSeur@meta.data)
difGenesMajor <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = majorClusters)
                                            
```

```{r}

# gt_matches

m1 <- FN7_LDAs_20um_k9_135genes$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

rownames(m1) <- paste0("Cell-type ", seq(9))

summary_df <- do.call(rbind, lapply(names(gt_matches_20um), function(i){
        # get paired ct
        ct <- as.vector(gt_matches_20um[i])
        topic <- i
        print(ct)
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        # prsn <- cor(x, y, method = "pearson")
        # sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank))
                # labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                #                    "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Cell-type transcriptional profiles",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic() +
        ggplot2::theme(axis.text.x=element_text(size=15),
                       axis.text.y=element_text(size=15),
                       axis.title.y=element_text(size=15),
                       axis.title.x=element_text(size=15),
                       plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S4-A_gene_ranks_hex-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 4,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```


```{r}

m1 <- FN7_LDAs_20um_k8$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m1, # rows
                     m2 = m2, # cols
                     type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct
        ct <- rownames(m2)[pairs$colsix[i]]
        topic <- i
        
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot2::ggplot(data = ct_df) +
                ggplot2::geom_point(aes(x = gexp_rank, y = beta_rank)) +
                ggplot2::labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Deconvolved vs ground truth transcriptional profile gene rank",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_20um_8cts_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

### singlets, doublets

```{r}

dat <- do.call(rbind, lapply(seq(0.01, 1, 0.01), function(i){
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < i] <- 0
  a <- rowSums(mat > 0)
  b <- rowSums(simFN7_20um$gtSpotTopics > 0)
  
  # "true doublets assigned as doublets"
  d_tp <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2)))), 2)
  # "true singlets assigned as singlets"
  s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  # "predicted doublets that were true doublets"
  d_tpr <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2)))), 2)
  # "predicted singlets that were true singlets"
  s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  
  row <- c(s_tpr, d_tpr, s_tp, d_tp)
  row
  
}))

rownames(dat) <- seq(0.01, 1, 0.01)
colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")

```

```{r}

ggplot(data = reshape2::melt(dat)) +
  geom_line(aes(x = Var1, y = value, color = Var2)) +
  xlab("proportion cutoff") +
  ylab("")
  

```

```{r}

# corMtx <- getCorrMtx(m1 = FN7_LDAs_20um_k8$theta,
#                      m2 = as.matrix(simFN7_20um$gtSpotTopics),
#                      type = "t")
# pairs <- lsatPairs(corMtx)
# topics <- rownames(corMtx[pairs$rowix, pairs$colsix])
# cts <- colnames(corMtx[pairs$rowix, pairs$colsix])

for(ct in seq(8)){
  
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < 0.2] <- 0
  mat[mat >= 0.2] <- 1
  mat <- mat/rowSums(mat)
  a <- mat[,pairs$rowix[ct]]
  b <- simFN7_20um$gtSpotTopics[,pairs$colsix[ct]]
  dat <- cbind(a, b)
  
  plt <- ggplot(data = data.frame(dat)) +
    geom_hex(aes(x = a, y = b)) +
    xlab("predicted proportion") +
    ylab("gt proportion") +
    ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  print(plt)
  
  # lapply(seq(0.01, 1, 0.01), function(i){
  #   mat <- FN7_LDAs_20um_k8$theta
  #   mat[mat < i] <- 0
  #   mat[mat >= i] <- 1
  #   mat <- mat/rowSums(mat)
  #   a <- mat[,pairs$rowix[ct]]
  #   b <- simFN7_20um$gtSpotTopics[,pairs$colsix[ct]]
  #   dat <- cbind(a, b)
  #   plt <- ggplot(data = reshape2::melt(dat)) +
  #     geom_point(aes(x = Var1, y = value, color = Var2)) +
  #     xlab("proportion cutoff") +
  #     ylab("") +
  #     ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  #   print(plt)
  #   
  #   # "true singlets assigned as singlets"
  #   s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  #   # "predicted singlets that were true singlets"
  #   s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  #   
  #   # "true singlets assigned as singlets"
  #   d_tp <- round((length(intersect(names(which(a == 0.5)), names(which(b == 0.5)))) / length(names(which(b == 0.5)))), 2)
  #   # "predicted singlets that were true singlets"
  #   d_tpr <- round((length(intersect(names(which(a == 0.5)), names(which(b == 0.5)))) / length(names(which(a == 0.5)))), 2)
  #   
  #   row <- c(s_tpr, d_tpr, s_tp, d_tp)
  #   row
  #   
  # })
  # 
  # rownames(dat) <- seq(0.01, 1, 0.01)
  # colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")
  # 
  # plt <- ggplot(data = reshape2::melt(dat)) +
  #   geom_line(aes(x = Var1, y = value, color = Var2)) +
  #   xlab("proportion cutoff") +
  #   ylab("") +
  #   ggtitle(colnames(corMtx[pairs$rowix, pairs$colsix])[ct])
  # print(plt)
  
}


```

```{r}

dat <- do.call(rbind, lapply(seq(0.01, 1, 0.01), function(i){
  mat <- FN7_LDAs_20um_k8$theta
  mat[mat < i] <- 0
  mat[mat >= i] <- 1
  mat <- mat/rowSums(mat)
  a <- rowSums(mat > 0)
  b <- rowSums(simFN7_20um$gtSpotTopics > 0)
  
  # "true doublets assigned as doublets"
  d_tp <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2)))), 2)
  # "true singlets assigned as singlets"
  s_tp <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1)))), 2)
  # "predicted doublets that were true doublets"
  d_tpr <- round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2)))), 2)
  # "predicted singlets that were true singlets"
  s_tpr <- round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1)))), 2)
  
  row <- c(s_tpr, d_tpr, s_tp, d_tp)
  row
  
}))

rownames(dat) <- seq(0.01, 1, 0.01)
colnames(dat) <- c("singlet.tpr", "doublet.tpr", "s_tp", "d_tp")

```


```{r}

mat <- FN7_LDAs_20um_k8$theta
mat[mat < 0.23] <- 0

a <- rowSums(mat > 0)
b <- rowSums(simFN7_20um$gtSpotTopics > 0)

table(a)
table(b)

```

what is the overlap between the singles, doublets, triples of the actual vs predictions? 

```{r}

print("percentages")
print("doublets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)
print("doublets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 2)))) / length(names(which(b == 2))))*100, 2)

print("predicted doublets that were actually doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 2)))) / length(names(which(a == 2))))*100, 2)
print("predicted doublets that were actually singlets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(a == 2))))*100, 2)

```

```{r}

print("percentages")
print("singlets assigned as singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as doublets")
round((length(intersect(names(which(a == 2)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as triplets")
round((length(intersect(names(which(a == 3)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)
print("singlets assigned as nill")
round((length(intersect(names(which(a == 0)), names(which(b == 1)))) / length(names(which(b == 1))))*100, 2)

print("predicted singlets that were actually singlets")
round((length(intersect(names(which(a == 1)), names(which(b == 1)))) / length(names(which(a == 1))))*100, 2)
print("predicted singlets that were actually doublets")
round((length(intersect(names(which(a == 1)), names(which(b == 2)))) / length(names(which(a == 1))))*100, 2)

```
# ----------------------------------
## 100 um

### Viz bregmas

```{r}

classCols <- c("Astrocyte" = "#F8766D",
               "Endothelial" = "#CD9600",
               "Ependymal" = "#7CAE00",
               "Excitatory" = "#00BE67",
               "Inhibitory" = "#00BFC4",
               "Microglia" = "#00A9FF",
               "OD" = "#C77CFF",
               "Pericytes" = "#FF61CC")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

for(ix in names(simBregmasFN7)[1]){
# do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  # -------------------------------------------------------------
  # each cell type separately
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p1)
  ggsave(filename = paste0("0_8cts_separate_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  # all cells with grid showing
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  print(p2)
  ggsave(filename = paste0("0_8cts_grid_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  
  # -------------------------------------------------------------
  # ground truth proportions
  m <- as.matrix(simFN7$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = ix)
  print(p3)
  ggsave(filename = paste0("0_8cts_simST_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)
  # c(p1, p2, p3)
  
}
  

# }

```

### Summary stats

```{r}

summary(FN7_cellTypeTable)

# total cells in pixels
print("total cells in pixels")
summary(rowSums(FN7_cellTypeTable))

pdf(file = paste0(fig_path, "Supplemental_Figure_S2-A-100um_cells_in_pixels.pdf"),   # The directory you want to save the file in
    width = 5, # The width of the plot in inches
    height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_cellTypeTable), breaks = 20,
     col = "white",
     main = "",
     xlab = "Number of cells",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
dev.off()

# -------------------------------------------------------------
# total cell types in pixels

pdf(file = paste0(fig_path, "Supplemental_Figure_S2-B-100um_cells_types_in_pixels.pdf"),   # The directory you want to save the file in
    width = 5, # The width of the plot in inches
    height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_cellTypeTable > 0), breaks = 8,
     col = "white",
     main = "",
     xlab = "Number of cell-types",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
dev.off()

print("cell types in pixels:")
summary(rowSums(FN7_cellTypeTable > 0))

print("cell subtypes in pixels:")
summary(rowSums(FN7_neuro_cellTypeTable > 0))

# -------------------------------------------------------------
# total cell subtypes in pixels
# pdf(file = paste0(fig_path, "Fig_S1_mjr-cell-types-in-pixels.pdf"),   # The directory you want to save the file in
#     width = 5, # The width of the plot in inches
#     height = 3) # The height of the plot in inches
par(mar=c(5,5,1,1)) # bottom, left, top, right margins
hist(rowSums(FN7_neuro_cellTypeTable > 0), breaks = 20,
     col = "white",
     main = "",
     xlab = "Number of cell-subtypes",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
title(line = 0)
# dev.off()

# -------------------------------------------------------------
# cell-type proportions across spots (non-zero)

pdf(file = paste0(fig_path, "Supplemental_Figure_S2-C-100um_cells_proportions_in_pixels.pdf"),   # The directory you want to save the file in
    width = 5, # The width of the plot in inches
    height = 3) # The height of the plot in inches
hist(as.vector(simFN7_9ct_135genes$gtSpotTopics[simFN7_9ct_135genes$gtSpotTopics > 0]),
     breaks = 101,
     col = "white",
     main = "non-zero cell-type proportions in pixels",
     xlab = "Proportion",
     ylab = "Number of pixels",
     cex.lab = 1,
     cex.axis = 1)
dev.off()

print("cell types proportions in each pixel:")
summary(as.vector(simFN7_9ct_135genes$gtSpotTopics[simFN7_9ct_135genes$gtSpotTopics > 0]))
summary(simFN7_9ct_135genes$gtSpotTopics)
print("cell subtypes proportions in each pixel:")
summary(as.vector(simFN7_neuro_9ct_135genes$gtSpotTopics[simFN7_neuro_9ct_135genes$gtSpotTopics > 0]))

```

```{r}

ggplot(data = reshape2::melt(simFN7_neuro$gtSpotTopics)) +
  # geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  geom_jitter(aes(x = reorder(Var2, -value), y = value), position=position_jitter(0.1), cex=0.1) +
  scale_y_continuous(breaks = seq(0,1,0.05)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        )

```

### Train LDA

```{r}

ks <- seq(from = 2, to = 20, by = 1)
ks <- c(ks, seq(from = 30, to = 70, by = 20))
ks <- c(ks, 75, 76)
ks

```

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs <- fitLDA(counts = as.matrix(simFN7$sim),
                   Ks = ks,
                   testSize = NULL,
                   seed = 0,
                   ncores = 7,
                   plot = TRUE)
# dev.off()

```

### k = 8

viz the perplexity and rare cts just for viz purposes here

```{r}

ks <- seq(from = 2, to = 20, by = 1)

```

```{r}

# pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs_2to20_135genes <- fitLDA(counts = as.matrix(simFN7$sim),
                   Ks = ks,
                   testSize = NULL,
                   perc.rare.thresh = 0.025,
                   seed = 0,
                   ncores = 7,
                   plot = TRUE)
# dev.off()

```

### extract betas thetas

```{r}

FN7_K9_135genes <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs_2to20_135genes, opt = 9),
                         corpus = as.matrix(simFN7$sim),
                         deepSplit = 4,
                         colorScheme = "rainbow")

```

```{r}
FN7_K8 ## 125 genes and 8 cts
FN7_K8_135genes ## 135 genes and 8 cts
FN7_K9_135genes ## 135 genes and 9 cts
```


In the actual corpus, the lowest non-zero proportion is 2.5%, so remove all proportions less than that

```{r}

lda_k8_theta <- FN7_K8_135genes$theta
lda_k8_theta[lda_k8_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
# ambig <- 1 - rowSums(lda_k8_theta)
# lda_k8_theta2 <- cbind(lda_k8_theta, ambig)

# readjust proportions
lda_k8_theta <- lda_k8_theta/rowSums(lda_k8_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k8_theta[is.na(lda_k8_theta)] <- 0

summary(lda_k8_theta)

ggplot(data = reshape2::melt(lda_k8_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop any cts that are 0 for all pixels
lda_k8_theta <- lda_k8_theta[,which(colSums(lda_k8_theta) > 0)]
# lda_k8_theta2 <- lda_k8_theta2[,which(colSums(lda_k8_theta2) > 0)]

```

#### Viz predictions

```{r}

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = lda_k8_theta, # rows
                     m2 = as.matrix(simFN7$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows

# plot each bregma separately
for(ix in names(simBregmasFN7)[1]){
  
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- simFN7$gtSpotTopics[spots,]
  
  m <- lda_k8_theta[spots,]
  p <- cellCounts[, c("x", "y")]
  
  p1 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = TRUE,
                     plotTitle = ix)
  print(p1)
  ggplot2::ggsave(filename = paste0("0_8cts_135genes_STdev_bregma_", ix, ".png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

}

```

```{r, fig.height=48, fig.width=5}

classCols <- c("Astrocyte" = "#F8766D",
               "Endothelial" = "#CD9600",
               "Ependymal" = "#7CAE00",
               "Excitatory" = "#00BE67",
               "Inhibitory" = "#00BFC4",
               "Microglia" = "#00A9FF",
               "OD" = "#C77CFF",
               "Pericytes" = "#FF61CC")

# classCols <- c("Astrocyte" = "#F8766D",
#                "Endothelial" = "#D39200",
#                "Ependymal" = "#93AA00",
#                "Excitatory" = "#00BA38",
#                "Inhibitory" = "#00C19F",
#                "Microglia" = "#00B9E3",
#                "OD Immature" = "#619CFF",
#                "OD Mature" = "#DB72FB",
#                "Pericytes" = "#FF61C3")

# matching up topics to gt cell-types for coloring
corMtx <- getCorrMtx(m1 = lda_k8_theta, # rows
                     m2 = as.matrix(simFN7$gtSpotTopics), # cols
                     type = "t")
pairs <- lsatPairs(corMtx) # reorder cols (gt cell-types) by best matches to the rows


## -------------------------------------------------------------
## each cell type separately
plts1 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  p1 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.3) +
    facet_wrap(~Cell_class) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") +
    ggtitle(ix)
  ggplotGrob(p1)
})

layout <- matrix(seq(12))
plts1_grid <- gridExtra::grid.arrange(
                  grobs = plts1,
                  layout_matrix = layout
)
plts1_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_separateCts_AllBregmas.png"),
                plot = plts1_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

## -------------------------------------------------------------
## all cells with grid showing
plts2 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  
  p2 <- ggplot() +
    geom_point(data = breg,
               aes(x = Centroid_X, y = Centroid_Y, color = Cell_class), size=0.4) +
    scale_fill_manual(values = classCols[breg$Cell_class]) +
    geom_rect(data = cellCounts,
              aes(xmin = x - 0, xmax = x + 100,
                  ymin = y - 0, ymax = y + 100),
              fill = NA, color = "black", linetype = "dashed") +
    theme(
          #panel.background = element_rect(fill = "white"),
          panel.grid = element_blank(),
          axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          legend.position = "none") #+
    #ggtitle(ix)
  ggplotGrob(p2)
})

layout <- matrix(seq(12))
plts2_grid <- gridExtra::grid.arrange(
                  grobs = plts2,
                  layout_matrix = layout
)
plts2_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_grid_AllBregmas.png"),
                plot = plts2_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## ground truth proportions
plts3 <- lapply(names(simBregmasFN7), function(ix){
  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]

  m <- as.matrix(simFN7$gtSpotTopics[rownames(cellCounts),])
  pos <- cellCounts[,c("x", "y")]
  p3 <- vizAllTopics(theta = m,
               pos = pos,
               topicOrder=seq(ncol(m)),
               topicCols=as.vector(classCols[colnames(m)[colSums(m) > 0]]),
               groups = rep("0", dim(m)[1]),
               group_cols = c("0" = "black"),
               r = 40, # different size piecharts for mOB data sets
               lwd = 0.4,
               showLegend = FALSE,
               plotTitle = NA)
  ggplotGrob(p3)
})

layout <- matrix(seq(12))
plts3_grid <- gridExtra::grid.arrange(
                  grobs = plts3,
                  layout_matrix = layout
)
plts3_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_simST_AllBregmas.png"),
                plot = plts3_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)
  
## -------------------------------------------------------------
## STdeconvolve proportions
plts4 <- lapply(names(simBregmasFN7), function(ix){

  breg <- simFN7$annotDf[simFN7$annotDf$Bregma == ix,]
  cellCounts <- simFN7$cellCounts[which(rownames(simFN7$cellCounts) %in% breg$patch_id),]
  spots <- rownames(cellCounts)
  gtFreqs <- simFN7$gtSpotTopics[spots,]

  m <- lda_k8_theta[spots,]
  p <- cellCounts[, c("x", "y")]

  p4 <- vizAllTopics(theta = m,
                     pos = p,
                     topicOrder=seq(ncol(m)),
                     topicCols=as.vector(classCols[pairs$colsix]),
                     groups = rep("0", dim(m)[1]),
                     group_cols = c("0" = "black"),
                     r = 40,
                     lwd = 0.4,
                     showLegend = FALSE,
                     plotTitle = NA)
  ggplotGrob(p4)
})

layout <- matrix(seq(12))
plts4_grid <- gridExtra::grid.arrange(
                  grobs = plts4,
                  layout_matrix = layout
)
plts4_grid
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_STdeconvolve_AllBregmas.png"),
                plot = plts4_grid,
                device = "png",
                path = fig_path,
                scale = 1,
                width = 5,
                height = 48,
                units = c("in"),
                dpi = 300)

# layout <- t(matrix(seq(length((simBregmasFN7))*4), nrow=4))

```

#### Correlations 

```{r}

gt <- simFN7

clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D", ## ward.D
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
# colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  # ggplot2::xlab("Ground truth cell-types") +
  # ggplot2::ylab("Deconvolved cell-types") +
  # ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_8cts_135genes_gt_txn_profile_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```


```{r}

gt <- simFN7
decon <- FN7_K8_135genes
filt_theta <- lda_k8_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Transcriptional profile correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()
                 # legend.position = "bottom"
                 ) +
  # ggplot2::guides(color = guide_colourbar(nbin = 10, raster = F, direction = "horizontal", barwidth = 20, barheight = 0.8)) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_txn_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_prop_corr_heatmap_txn_ordered_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------

# corMtx_prop_2 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                           m2 = decon$theta[,pairs$colsix],
#                           type = "t")
# colnames(corMtx_prop_2) <- paste0("Cell-type ", colnames(corMtx_prop_2))
# 
# # plot the proportion correlations, cell-types ordered based on transcriptional pairing
# dat <- reshape2::melt(corMtx_prop_2)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_8cts_prop_corr_heatmap_txn_ordered_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (txn order, before filtering) across diag:", mean(diag(corMtx_prop_2)), "\n")
# cat("median proportional corr (txn order, before filtering) across diag:", median(diag(corMtx_prop_2)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
# corMtx_prop_3 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                          m2 = decon$theta,
#                          type = "t")
# pairs <- lsatPairs(corMtx_prop_3)
# ## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
# ## the properly ordered proportional correlation matrix
# corMtx_prop_3 <- corMtx_prop_3[pairs$rowix, pairs$colsix]
# colnames(corMtx_prop_3) <- paste0("Cell-type ", colnames(corMtx_prop_3))
# 
# # plot the proportion correlations
# dat <- reshape2::melt(corMtx_prop_3)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 8 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_8cts_prop_corr_heatmap_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (prop order, before filtering) across diag:", mean(diag(corMtx_prop_3)), "\n")
# cat("median proportional corr (prop order, before filtering) across diag:", median(diag(corMtx_prop_3)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_prop_corr_heatmap_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  # proportional_txn = diag(corMtx_prop_1),
                                  # proportional_prop = diag(corMtx_prop_4)
                                  proportional = diag(corMtx_prop_4)
                                  ))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1) +
  ggplot2::ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth\ncell-type correlations",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x=element_text(size=15),
                 axis.text.y=element_text(size=15),
                 axis.title.y=element_text(size=15),
                 axis.title.x=element_blank(),
                 plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_heatmap_daig_corrs_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 3,
         height = 4,
         units = c("in"),
         dpi = 300)

```

#### Gene ranks

MERIGNUE differential genes for each cluster:
```{r}

# cells and their associated clusters
neuroClusters <- bregmaFN7FullSeur@meta.data$All_classes
names(neuroClusters) <- rownames(bregmaFN7FullSeur@meta.data)
# I-39 only has one cell so drop 
neuroClusters <- neuroClusters[which(!neuroClusters %in% c("I-39"))]
difGenesNeuro <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = neuroClusters)

# cells and their associated clusters
majorClusters <- bregmaFN7FullSeur@meta.data$Major_class
names(majorClusters) <- rownames(bregmaFN7FullSeur@meta.data)
difGenesMajor <- MERINGUE::getDifferentialGenes(cd = bregmaFN7FullSeur@assays$RNA@counts, cols = majorClusters)
                                            
```

```{r}

m1 <- FN7_K8_135genes$beta
m2 <- as.matrix(gtCtGenesFN7)

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m1, # rows
                     m2 = m2, # cols
                     type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct
        ct <- rownames(m2)[pairs$colsix[i]]
        topic <- i
        
        # the corresponding diff genes table
        ct_df <- difGenesMajor[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank)) +
                labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[topic, ct],2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Cell-type transcriptional profiles",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic() +
        ggplot2::theme(axis.text.x=element_text(size=15),
                       axis.text.y=element_text(size=15),
                       axis.title.y=element_text(size=15),
                       axis.title.x=element_text(size=15),
                       plot.title=element_text(size=15))
ggplot2::ggsave(filename = paste0("0_100um_8cts_135genes_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 4,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

### k = 75

```{r}

FN7_K75 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs, opt = "75"),
                          corpus = as.matrix(simFN7$sim),
                          deepSplit = 2, # collapsed more to reduce number of clusters to 15
                          colorScheme = "rainbow")

```

In the actual corpus, the lowest non-zero proportion is 2.5%, so remove all proportions less than that

```{r}

lda_k75_theta <- FN7_K75$theta
lda_k75_theta[lda_k75_theta < 0.025] <- 0

# try just calling the unassigned proportions "ambiguous"
# ambig <- 1 - rowSums(lda_k75_theta)
# lda_k75_theta2 <- cbind(lda_k75_theta, ambig)

# readjust proportions
lda_k75_theta <- lda_k75_theta/rowSums(lda_k75_theta)
# if NAs because all cts are 0 in a spot, replace with 0
lda_k75_theta[is.na(lda_k75_theta)] <- 0

summary(lda_k75_theta)

ggplot(data = reshape2::melt(lda_k75_theta)) +
  geom_boxplot(aes(x = reorder(Var2, -value), y = value)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# drop ant cts that are 0 for all pixels
lda_k75_theta <- lda_k75_theta[,which(colSums(lda_k75_theta) > 0)]
# lda_k75_theta2 <- lda_k75_theta2[,which(colSums(lda_k75_theta2) > 0)]

```

#### Correlations 

```{r}

gt <- simFN7_neuro
decon <- FN7_K75
filt_theta <- lda_k75_theta

## cluster ground truth cell-types transcriptionally
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix
corMtx_txn_1 <- corMtx_txn[pairs$rowix, pairs$colsix]
colnames(corMtx_txn_1) <- paste0("Cell-type ", colnames(corMtx_txn_1))

## plot the txn correlations
dat <- reshape2::melt(corMtx_txn_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type transcriptional profile correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_txn_corr_heatmap.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean transcriptional corr across diag:", mean(diag(corMtx_txn_1)), "\n")
cat("median transcriptional corr across diag:", median(diag(corMtx_txn_1)), "\n")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
## rows are the ground truth in order of their transcriptional similarity
corMtx_txn <- getCorrMtx(m1 = as.matrix(gt$gtCtGenes)[ct_txn_order,],
                         m2 = decon$beta,
                         type = "b")
pairs <- lsatPairs(corMtx_txn)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered txn correlation matrix

## now get the pixel proportional correlations and order based on above pairings, which are based on txn similarities:
corMtx_prop_1 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                          m2 = filt_theta[,pairs$colsix],
                          type = "t")
colnames(corMtx_prop_1) <- paste0("Cell-type ", colnames(corMtx_prop_1))

# plot the proportion correlations, cell-types ordered based on transcriptional pairing
dat <- reshape2::melt(corMtx_prop_1)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_txn_ordered_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (txn order, after filtering) across diag:", mean(diag(corMtx_prop_1)), "\n")
cat("median proportional corr (txn order, after filtering) across diag:", median(diag(corMtx_prop_1)), "\n")

# plot the pixel proportions of each paired cell-type
# after removing removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on transcriptional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------

# corMtx_prop_2 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                           m2 = decon$theta[,pairs$colsix],
#                           type = "t")
# colnames(corMtx_prop_2) <- paste0("Cell-type ", colnames(corMtx_prop_2))
# 
# # plot the proportion correlations, cell-types ordered based on transcriptional pairing
# dat <- reshape2::melt(corMtx_prop_2)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_txn_ordered_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (txn order, before filtering) across diag:", mean(diag(corMtx_prop_2)), "\n")
# cat("median proportional corr (txn order, before filtering) across diag:", median(diag(corMtx_prop_2)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated txn profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## before filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
# corMtx_prop_3 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
#                          m2 = decon$theta,
#                          type = "t")
# pairs <- lsatPairs(corMtx_prop_3)
# ## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
# ## the properly ordered proportional correlation matrix
# corMtx_prop_3 <- corMtx_prop_3[pairs$rowix, pairs$colsix]
# colnames(corMtx_prop_3) <- paste0("Cell-type ", colnames(corMtx_prop_3))
# 
# # plot the proportion correlations
# dat <- reshape2::melt(corMtx_prop_3)
# ggplot2::ggplot(data = dat) +
#   ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
#   ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
#   ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
#   ggplot2::xlab("Ground truth cell-types") +
#   ggplot2::ylab("Deconvolved cell-types") +
#   ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
#   ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
#                 panel.grid = element_blank(),
#                 axis.line=element_blank(),
#                 # axis.text.x=element_blank(),
#                 axis.text.y=element_text(size=5),
#                 axis.ticks=element_blank(),
#                 # axis.title.x=element_blank(),
#                 # axis.title.y=element_blank(),
#                 panel.background=element_blank()) +
#   ggplot2::coord_fixed()
# ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_before_filtering.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# cat("mean proportional corr (prop order, before filtering) across diag:", mean(diag(corMtx_prop_3)), "\n")
# cat("median proportional corr (prop order, before filtering) across diag:", median(diag(corMtx_prop_3)), "\n")
# 
# # plot the pixel proportions of each paired cell-type
# # note that this is without removing predicted cts from spots if less than 2.5%
# dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
#                    "STdeconvolve" = colMeans(decon$theta[,pairs$colsix]),
#                    "Cell Type" = ct_txn_order,
#                    "Topic" = names(colMeans(decon$theta[,pairs$colsix])))
# ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.1) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nbefore filtering",
#        x = "Cell-types", y = "mean pixel proportion")

## -------------------------------------------------------------------
## pairing of deconvolved and ground truth based on proportional profiles
## after filtering out cell-types <2.5% from deconvolved theta
## -------------------------------------------------------------------
corMtx_prop_4 <- getCorrMtx(m1 = as.matrix(gt$gtSpotTopics)[,ct_txn_order],
                         m2 = filt_theta,
                         type = "t")
pairs <- lsatPairs(corMtx_prop_4)
## pairs$colsix are now how the deconvolved cell-types pair with the ground truths
## the properly ordered proportional correlation matrix
corMtx_prop_4 <- corMtx_prop_4[pairs$rowix, pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Cell-type pixel proportion correlation\n(100 micron pixels, 75 cell-types)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=5),
                panel.grid = element_blank(),
                axis.line=element_blank(),
                # axis.text.x=element_blank(),
                axis.text.y=element_text(size=5),
                axis.ticks=element_blank(),
                # axis.title.x=element_blank(),
                # axis.title.y=element_blank(),
                panel.background=element_blank()) +
  ggplot2::coord_fixed()
ggplot2::ggsave(filename = paste0("0_100um_75cts_prop_corr_heatmap_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

cat("mean proportional corr (prop order, after filtering) across diag:", mean(diag(corMtx_prop_4)), "\n")
cat("median proportional corr (prop order, after filtering) across diag:", median(diag(corMtx_prop_4)), "\n")

# plot the pixel proportions of each paired cell-type
# note that this is without removing predicted cts from spots if less than 2.5%
dat2 <- data.frame("Ground Truth" = colMeans(gt$gtSpotTopics[,ct_txn_order]),
                   "STdeconvolve" = colMeans(filt_theta[,pairs$colsix]),
                   "Cell Type" = ct_txn_order,
                   "Topic" = names(colMeans(filt_theta[,pairs$colsix])))
ggplot(data = reshape2::melt(dat2), aes(x = reorder(Cell.Type, -value), y = value, color = variable)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.1) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  labs(title = "Actual and deconvolved cell-type mean pixel proportions\npairs based on correlated proportion profile\nafter filtering",
       x = "Cell-types", y = "mean pixel proportion")


## boxplot summary of correlations
dat3 <- reshape2::melt(data.frame(
                                  transcriptional = diag(corMtx_txn_1),
                                  proportional_txn = diag(corMtx_prop_1),
                                  proportional_prop = diag(corMtx_prop_4)))
colnames(dat3) <- c("Comparison", "Correlation")
ggplot2::ggplot(data = dat3, aes(x=Comparison, y=Correlation)) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1) +
  ggplot2::ylim(c(-1,1)) +
  ggplot2::scale_fill_grey() +
  ggplot2::labs(title = "Deconvolved and ground truth cell-type correlations, between pairs\n(100 micron pixels, 75 cell-types)",
                x = "Comparison",
                y = "Correlation") +
  ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_100um_75cts_heatmap_daig_corrs_after_filtering.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

```

Transcriptional correlation still high but pixel proportions lower, but this is likely due to the fact that it is more difficult to deconvovle rare cell-types. (note that this positional correlation is when pairing cells based on highest pixel proportional correlation. If I pair based on transcriptional correlation, then compute pixel proportional correlation, then its a lot lower. So this probably speaks to the fact that a lot of the rare cell types are also very transcriptionally similar, making it even harder to assign the right one. But if more distinct, cell-types instead of subtypes, it becomes a lot easier. The pairing based on transcriptional and proportional correlation is the same)

#### Gene ranks

```{r}

m1 <- FN7_K75$beta
m2 <- as.matrix(gtCtNeuronalGenesFN7) # drop I-39
m2 <- m2[rownames(m2) != "I-39",]

sharedGenes <- intersect(colnames(m1), colnames(m2))

corMtx <- getCorrMtx(m1 = m2,
                      m2 = m1,
                      type = "b")
pairs <- lsatPairs(corMtx)

summary_df <- do.call(rbind, lapply(pairs$rowix, function(i){
        # get paired ct and topic
        ct <- rownames(m2)[i]
        topic <- pairs$colsix[i]
        
        # the corresponding diff genes table
        ct_df <- difGenesNeuro[[ct]]
        
        # filter for sig diff genes for specific ct
        # ct_df <- ct_df[ct_df$p.adj < 0.05,]
        
        # ct sig genes that are also in corpus
        genes <- intersect(sharedGenes, rownames(ct_df))
        topic_betas <- m1[topic, genes]
        ct_df <- ct_df[genes,]
        
        # gexp values
        ct_genes <- m2[ct, genes]
        
        # add extra columns to df for ggplot
        ct_df$gexp <- ct_genes
        ct_df$gexp_rank <- rank(ct_genes)
        ct_df$beta <- topic_betas
        ct_df$beta_rank <- rank(topic_betas) # 1 = lowest beta
        ct_df$pair <- paste0(topic, " vs ", ct)
        
        # take top 10 betas
        # ct_df <- ct_df[ct_df$beta_rank > 83,]
         
        # x <- -log10(ct_df$p.adj)
        # x <- log10(ct_df$gexp + 1)
        x <- ct_df$gexp_rank
        # y <- ct_df$beta
        y <- ct_df$beta_rank
        # y <- ct_df$beta
         
        prsn <- cor(x, y, method = "pearson")
        sprn <- cor(x, y, method = "spearman")
        p <- ggplot(data = ct_df) +
                geom_point(aes(x = gexp_rank, y = beta_rank)) +
                labs(title = paste("Beta pairs: Topic", topic, "vs", ct, "; cor =", round(corMtx[ct,topic], 2), "\n",
                                   "pearson =", round(prsn, 2), "spearman =", round(sprn, 2)))
        # print(p)
        ct_df
})) 

ggplot2::ggplot(data = summary_df) +
        ggplot2::geom_hex(aes(x = gexp_rank, y = beta_rank), bins=10) +
        ggplot2::scale_fill_gradient(low = "white", high = "red") +
        ggplot2::labs(title = "Deconvolved vs ground truth transcriptional profile gene rank",
                      x = "Ground truth gene expression level",
                      y = "Deconvolved gene expression level") +
        ggplot2::theme_classic()
ggplot2::ggsave(filename = paste0("0_100um_75cts_gene_ranks_hex.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

x <- summary_df$gexp_rank
# y <- ct_df$beta
y <- summary_df$beta_rank
# y <- ct_df$beta
 
cor(x, y, method = "pearson")
cor(x, y, method = "spearman")

```

# ======================

# Number of pixels benchmark

```{r}
numPixelsBenchmark <- readRDS("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/numPixelsBenchmark.Rds")
```

```{r}

corpus <- as.matrix(simFN7$sim)
Ks <- seq(3,10)
numDocs <- c(3,5,10,50,100,150)
# numDocs <- c(3,10,50,100)
numReps <- seq(10)
# numDocs <- c(3,5)
# numReps <- seq(3)

# Ks <- seq(2,3)
# numDocs <- c(3,10)
# numReps <- seq(1)

numPixelsBenchmark <- do.call(rbind, lapply(numDocs, function(d){
# for(d in numDocs){
  combined_df <- data.frame(numDocs=character(),
                            replicate=character(),
                            K=character(),
                            RMSE=double())
  for(r in numReps){
    set.seed(r)
    ## for each replicate, get a sample of pixel of size d
    s <- sample(nrow(corpus), d)
    sampleCorpus <- corpus[s,]
    gtCorpus <- simFN7$gtSpotTopics[s,]
    ## drop cell-types that are 0 for all samples pixels
    gtCorpus <- gtCorpus[,which(colSums(gtCorpus) > 0)]
    
    ## fit LDA models for each K in Ks on the sampled corpus
    ldas <- fitLDA(counts = sampleCorpus,
                   Ks = Ks,
                   testSize = NULL,
                   seed = seed,
                   ncores = 7,
                   plot = FALSE)
    # get beta and theta of sampled pixels for each fitted LDA model
    for(k in Ks){
      res <- getBetaTheta(lda = optimalModel(models = ldas, opt = k),
                          corpus = sampleCorpus)
      ## compute rmse
      ## get pairs of topics and ground truth cell types that correlate best
      ## cannot have more rows than columns when pairing
      if (ncol(res$theta) <= ncol(as.matrix(gtCorpus))){
        theta_pairs <- lsatPairs(getCorrMtx(m1 = as.matrix(res$theta),
                                            m2 = as.matrix(gtCorpus),
                                            type = "t"))
        predict_theta <- res$theta[,theta_pairs$rowix]
        truth_theta <- gtCorpus[,theta_pairs$colsix]
      } else {
        theta_pairs <- lsatPairs(getCorrMtx(m1 = as.matrix(gtCorpus),
                                            m2 = as.matrix(res$theta),
                                            type = "t"))
        predict_theta <- res$theta[,theta_pairs$colsix]
        truth_theta <- gtCorpus[,theta_pairs$rowix]
      }
      ## the rmse for the pixels, for a given K and numDocs; and for each replicate of that combo
      rmses <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
        # for each spot, compute RMSE based on proportions across cts
        # so a RMSE for each spots based on all the cts
        actual <- as.vector(truth_theta[i,])
        predict <- as.vector(predict_theta[i,])
        mltools::rmse(preds = predict, actuals = actual)
      }))
      m <- data.frame(numDocs = rep(d, length(rmses)),
                      replicate = rep(r, length(rmses)),
                      K = rep(k, length(rmses)),
                      RMSE = rmses)
      combined_df <- rbind(combined_df, m)
    }
  }
  combined_df
}))

numPixelsBenchmark

```

```{r}

tmp_df <- numPixelsBenchmark[numPixelsBenchmark$K %in% c(9),]
tmp_df <- tmp_df[tmp_df$numDocs %in% c(5,10,50,100,150),]

## mean rmse for each replicate
summary_df <- tmp_df %>%
  group_by(numDocs, replicate) %>%
  dplyr::summarize(MeanRMSE = mean(RMSE, na.rm=TRUE),
                   n = n(),
                   sd = sd(RMSE, na.rm=TRUE),
                   se = sd/sqrt(n))

## mean rmse for the means of all replicates for a given numDoc
summary_df2 <- summary_df %>%
  group_by(numDocs) %>%
  dplyr::summarize(MeanRMSEreps = mean(MeanRMSE, na.rm=TRUE),
                   n = n(),
                   sd = sd(MeanRMSE, na.rm=TRUE),
                   se = sd/sqrt(n))

ggplot() +
  geom_point(data = summary_df, aes(x = numDocs, y = MeanRMSE)) +
  geom_line(data = summary_df2, aes(x = numDocs, y = MeanRMSEreps), lwd = 2) +
  # geom_ribbon(aes(ymax = `Mean RMSE` + sd, ymin = `Mean RMSE` - sd, x = numDocs, fill = as.character(K)), alpha = 0.2, lwd = 0)
  # guides(color=guide_legend(title="K (number of cell-types")) +
  scale_x_continuous(breaks = c(5,10,50,100,150), labels = c(5,10,50,100,150)) +
  labs(title = "STdeconvolve accuracy on MERFISH ST dataset",
       x = "number of pixels", y = "mean RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size=15),
        axis.title.y = element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        panel.grid.minor = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_line(color = "black", size = 0.1)
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S15-numPixels_benchmark-100um_k9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 3,
         units = c("in"),
         dpi = 300)

```

# ----------------------------------

Use the RMSE for each pixel Because each method would be compared to the same cell-type for each pixel, ok to use RMSE, as the units would technically be equivalent for all methods.

But when comparing each cell-type individually, should normalize.

Double check the the normalization is doing what you think it is.


# RMSE

save(
  ## SL 9 cts and 135 genes from sl deconvolution
  SL_fit_9ct_135genes,
  ## from SPOTlghtPredict script
  sl_9ct_135genes,
  ## filtered out cts < 0.025
  sl_k9_135genes_theta,
  ## SL 76 cts and 135 genes from sl deconvolution
  SL_fit_76ct_135genes_neuro,
  ## from SPOTlightPredict script
  sl_76ct_135genes_neuro,
  ## filtered out cts < 0.025
  sl_k76_135genes_theta,
  ## SL 7 cts (9 - 2 neuronals) and 135 genes from sl deconvolution
  SL_fit_9ct_135genes_noNeuro,
  ## from SPOTlightPredict script
  sl_9ct_135genes_noNeuro,
  ## filtered out cts < 0.025
  sl_k9_135genes_noNeuro_theta,
  ### RCTD prediction
  RCTD_9ct_135genes_results_norm,
  ## filtered out cts < 0.025
  rctd_9ct_135genes_theta,
  ### RCTD prediction
  RCTD_76ct_135genes_results_norm,
  ## filtered out cts < 0.025
  rctd_76ct_135genes_theta,
  ### RCTD prediction
  RCTD_9ct_135genes_noNeuro_results_norm,
  ## filtered out cts < 0.025
  rctd_9ct_135genes_noNeuro_theta,
  file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_v2-9cts_135genes_SL_RCTD_models.RData"
)

## SL

### 9 ct 135 genes

```{r}

# breg_theta <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
breg_theta <- sl_k9_135genes_theta
# fix column names so they match
colnames(breg_theta) <- sub("\\.", " ", colnames(breg_theta))

breg_gt_theta <- as.matrix(simFN7_9ct_135genes$gtSpotTopics)
# fix column names so they match
colnames(breg_gt_theta) <- sub("\\-", " ", colnames(breg_gt_theta)) # for neuronal subtypes with "I-39" for example

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "Actual")
p_raw <- data.frame(predict_theta, group = "Deconvolved")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  labs(title = "SPOTlight deconvolved pixel proportions versus reference",
       x = "Cell-type", y = "pixel proportions") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        axis.text.y=element_text(size = 15),
        # axis.ticks=element_blank(),
        axis.title.x=element_text(size=15),
        axis.title.y=element_text(size=15),
        panel.background=element_blank()
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-B-spotlight_pixel_proportions-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# # because RMSE is scale-dependent, transform proportions of each cell-type to the same scale
# # this way, each prediction to truth comparison will contribute equally to the RMSE.
# # so rare cell-types with inherently low proportions will not contribute small values but instead
# # contribute same values as what would be returned by the same relative difference between
# # prediction and truth of cell-types with high proportions.
# truth_theta <- apply(truth_theta, 2, scale0_1)
# predict_theta <- apply(predict_theta, 2, scale0_1)

# # BUT! If a truth has proportions that are already 0-1, and the predictions are small, lets say
# # 0 to 0.1, then this scale gets inflated to 0-1, and then the large differences between truth and prediction are no longer captured.
# # So the reported RMSE will be lower than what the actual error is. For this to work, the truth and predictions will 
# # have to initially be in the same range. 

# ---------------------------------------------
# # There is the possibility of computing RMSE for each cell type separately. Each RMSE will be wrt the units, or range or proportions
# # for that cell-type. Then to compare the RMSE for each cell-type, you can normalize the RMSEs. Divide by the sd or min-max for example.

# # Could then get the normalized RMSE for each cell-type across pixels, then plot the distribution of normalized RMSE for each method and compare side by side. Would also see cell-types that each method predicts well and Cts that are predicted poorly, compared across methods. And I think this would make more sense for the scatter plot of RMSE vs ct proportion.

# RMSE for each ct. Unadjusted proportions. But not normalize the RMSEs to be able to compare them
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_8cts_cosine) <- colnames(truth_theta)


# -----------------------------------------
# ggplot(data = reshape2::melt(truth_theta)) +
#   geom_jitter(aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   scale_y_continuous(breaks = seq(0,max(truth_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   ggtitle("Truth Scaled")

# t_scaled <- data.frame(truth_theta, group = "T")
# p_scaled <- data.frame(predict_theta, group = "P")
# dat <- rbind(t_scaled, p_scaled)
# 
# ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
#   # geom_boxplot() +
#   geom_point(position=position_jitterdodge(0.1), cex=0.01) +
#   # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
#   # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
#   # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
#         # panel.grid = element_blank(),
#         # axis.line=element_blank(),
#         # axis.text.x=element_blank(),
#         # axis.text.y=element_blank(),
#         # axis.ticks=element_blank(),
#         axis.title.x=element_blank(),
#         axis.title.y=element_blank(),
#         panel.background=element_blank()
#         ) +
#   ggtitle("Scaled 0-1")
# # -----------------------------------------
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_8cts) <- colnames(truth_theta)

```
### 76 ct 135 genes

```{r}

# breg_theta <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
breg_theta <- sl_k76_135genes_theta
# fix column names so they match
colnames(breg_theta) <- sub("\\.", " ", colnames(breg_theta))

breg_gt_theta <- as.matrix(simFN7_neuro_9ct_135genes$gtSpotTopics)
# fix column names so they match
colnames(breg_gt_theta) <- sub("\\-", " ", colnames(breg_gt_theta)) # for neuronal subtypes with "I-39" for example

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_sl_75cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_75cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_75cts_cosine) <- colnames(truth_theta)

# # -----------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_75cts) <- colnames(truth_theta)

```

## RCTD

### 9 ct 135 genes

```{r}

# breg_theta <- RCTD_FN7_results_norm
breg_theta <- rctd_9ct_135genes_theta
breg_gt_theta <- as.matrix(simFN7_9ct_135genes$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "Actual")
p_raw <- data.frame(predict_theta, group = "Deconvolved")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  labs(title = "RCTD deconvolved pixel proportions versus reference",
       x = "Cell-type", y = "pixel proportions") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        axis.text.y=element_text(size = 15),
        # axis.ticks=element_blank(),
        axis.title.x=element_text(size=15),
        axis.title.y=element_text(size=15),
        panel.background=element_blank()
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-B-rctd_pixel_proportions-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots)
  raw_RMSE_rctd_8cts_spots <- c(raw_RMSE_rctd_8cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots_adj)
  raw_RMSE_rctd_8cts_spots_adj <- c(raw_RMSE_rctd_8cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_8cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_8cts_spots_cosine)
  raw_RMSE_rctd_8cts_spots_cosine <- c(raw_RMSE_rctd_8cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_8cts_cosine) <- colnames(truth_theta)

# # ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_8cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_8cts_spots)
#   scaled_RMSE_rctd_8cts_spots <- c(scaled_RMSE_rctd_8cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_8cts) <- colnames(truth_theta)

```

### 76 cts 135 genes

```{r}

# breg_theta <- RCTD_FN7_neuro_results_norm # 3070 and 73 cts
breg_theta <- rctd_76ct_135genes_theta
colnames(breg_theta) <- sub("\\-", " ", colnames(breg_theta))

breg_gt_theta <- as.matrix(simFN7_neuro_9ct_135genes$gtSpotTopics)
colnames(breg_gt_theta) <- sub("\\-", " ", colnames(breg_gt_theta))

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots)
  raw_RMSE_rctd_75cts_spots <- c(raw_RMSE_rctd_75cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_75cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots_adj)
  raw_RMSE_rctd_75cts_spots_adj <- c(raw_RMSE_rctd_75cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_75cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_75cts_spots_cosine)
  raw_RMSE_rctd_75cts_spots_cosine <- c(raw_RMSE_rctd_75cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_75cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_75cts_cosine) <- colnames(truth_theta)

# # ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_75cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_75cts_spots)
#   scaled_RMSE_rctd_75cts_spots <- c(scaled_RMSE_rctd_75cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_75cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_75cts) <- colnames(truth_theta)

```

## LDA

### 9 cts 135 genes

```{r}

# breg_theta <- FN7_K8$theta
breg_theta <- lda_k9_135genes_theta

gt <- simFN7_9ct_135genes
breg_gt_theta <- as.matrix(gt$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
# theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
#                                     m2 = breg_gt_theta,
#                                     type = "t"))

# -----------------------------------------
## get the proper pairing between ground truth and deconvolved cell-types
clust <- clusterTopics(beta = as.matrix(gt$gtCtGenes),
                       clustering = "ward.D",
                       dynamic = "hybrid",
                       deepSplit = 4,
                       plot = FALSE)
ct_txn_order <- rownames(as.matrix(gt$gtCtGenes)[clust$order,])

corMtx_prop_4 <- getCorrMtx(m1 = breg_gt_theta[,ct_txn_order],
                         m2 = breg_theta,
                         type = "t")
theta_pairs <- lsatPairs(corMtx_prop_4)

corMtx_prop_4 <- corMtx_prop_4[theta_pairs$rowix, theta_pairs$colsix]
colnames(corMtx_prop_4) <- paste0("Cell-type ", colnames(corMtx_prop_4))

# plot the proportion correlations
dat <- reshape2::melt(corMtx_prop_4)
ggplot2::ggplot(data = dat) +
  ggplot2::geom_tile(aes(x = Var1, y = Var2, fill=value)) +
  ggplot2::scale_fill_gradientn(colors = correlation_palette, breaks = correlation_breaks, limits = c(-1,1),
                                guide = guide_colorbar(title = "correlation", ticks = FALSE, label = FALSE)) +
  ggplot2::scale_y_discrete(breaks=dat$Var2, labels=dat$Var2) +
  ggplot2::xlab("Ground truth cell-types") +
  ggplot2::ylab("Deconvolved cell-types") +
  ggplot2::ggtitle("Pixel proportion correlation\n(100 micron pixels)") +
  ggplot2::theme(axis.text.x=element_text(angle=-90, size=10),
                 axis.text.y=element_text(angle=0, size=10),
                 axis.title.y=element_text(size=12),
                 axis.title.x=element_text(size=12),
                 plot.title = element_text(size=15),
                 panel.grid = element_blank(),
                 axis.line=element_blank(),
                 axis.ticks=element_blank(),
                 panel.background=element_blank()) +
  ggplot2::coord_fixed()


## adjust the proportions based on adjusted matches
## 4, 7, 8 combined into inhibitory
## pericytes and microglias not detected

predict_theta <- breg_theta[,theta_pairs$colsix]
predict_theta <- cbind(predict_theta, rowSums(predict_theta[,c("4","7","2")]))
colnames(predict_theta) <- c("OD Immature", "Excitatory",  "drop",  "Astrocyte", "Ependymal", "Endothelial", "Pericytes",   "Microglia", "OD Mature", "Inhibitory")

predict_theta <- predict_theta[,ct_txn_order]
predict_theta[,"Microglia"] <- 0
predict_theta[,"Pericytes"] <- 0
# -----------------------------------------

truth_theta <- breg_gt_theta[,ct_txn_order]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "Actual")
p_raw <- data.frame(predict_theta, group = "Deconvolved")
colnames(p_raw) <- colnames(t_raw)
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  labs(title = "STdeconvolve pixel proportions versus reference",
       x = "Cell-type", y = "pixel proportions") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        axis.text.y=element_text(size = 15),
        # axis.ticks=element_blank(),
        axis.title.x=element_text(size=15),
        axis.title.y=element_text(size=15),
        panel.background=element_blank()
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-B-stdecon_pixel_proportions-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_lda_8cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_lda_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_lda_8cts_nrmse <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_lda_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option.

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_lda_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_lda_8cts_cosine <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_lda_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
#
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_lda_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
#
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_lda_8cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_lda_8cts) <- colnames(truth_theta)

```

### 76 cts 135 genes

```{r}

# breg_theta <- FN7_K75$theta
breg_theta <- lda_k76_135genes_theta
breg_gt_theta <- as.matrix(simFN7_neuro_9ct_135genes$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                    m2 = breg_gt_theta,
                                    type = "t"))
# reorder the predicted topics to match their paired cell type
# rows are spots and columns are topics
# `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
predict_theta <- breg_theta[,theta_pairs$rowix]
# the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
truth_theta <- breg_gt_theta[,theta_pairs$colsix]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "T")
p_raw <- data.frame(predict_theta, group = "P")
colnames(p_raw) <- colnames(t_raw)
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        # axis.text.y=element_blank(),
        # axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank()
        ) +
  ggtitle("Raw")
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_lda_75cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_lda_75cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_lda_75cts_nrmse <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_lda_75cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_lda_75cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_lda_75cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_lda_75cts_cosine <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_lda_75cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_lda_75cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_lda_75cts <- do.call(cbind, lapply(seq(ncol(truth_theta)), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_lda_75cts) <- colnames(truth_theta)

```

## SL 9 ct 135 genes no neuronal

```{r}

# breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_theta <- sl_k9_135genes_noNeuro_theta
colnames(breg_theta) <- sub("\\.", " ", colnames(breg_theta))

breg_gt_theta <- as.matrix(simFN7_9ct_135genes$gtSpotTopics)
# fix column names so they match
colnames(breg_gt_theta) <- sub("\\-", " ", colnames(breg_gt_theta)) # for neuronal subtypes with "I-39" for example

# add in neuronal cts to predicted theta matrix
breg_theta <- cbind(breg_theta, rep(0,nrow(breg_theta)), rep(0,nrow(breg_theta)))
colnames(breg_theta)[8:9] <- c("Excitatory", "Inhibitory")

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "Actual")
p_raw <- data.frame(predict_theta, group = "Deconvolved")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  labs(title = "SPOTlight missing neuronals deconvolved pixel proportions versus reference",
       x = "Cell-type", y = "pixel proportions") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        axis.text.y=element_text(size = 15),
        # axis.ticks=element_blank(),
        axis.title.x=element_text(size=15),
        axis.title.y=element_text(size=15),
        panel.background=element_blank()
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-B-spotlight_noNeuro_pixel_proportions-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)
# -----------------------------------------

# make sure the rows are the same, too
# truth_theta <- truth_theta[rownames(predict_theta),]

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_sl_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_sl_noNeur_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_sl_noNeur_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_sl_noNeur_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_sl_noNeur_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_sl_noNeur_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# for cts:
raw_RMSE_sl_noNeur_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_sl_noNeur_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # because all 0's for neuronal, returns NAs. Convert to 0
# predict_theta[is.na(predict_theta)] <- 0
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_sl_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_sl_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_sl_noNeur_8cts) <- colnames(truth_theta)

```

## RCTD 9 ct 135 genes no neuronal

```{r}

# breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_theta <- rctd_9ct_135genes_noNeuro_theta
colnames(breg_theta) <- sub("\\.", " ", colnames(breg_theta))

breg_gt_theta <- as.matrix(simFN7_9ct_135genes$gtSpotTopics)
# fix column names so they match
colnames(breg_gt_theta) <- sub("\\-", " ", colnames(breg_gt_theta)) # for neuronal subtypes with "I-39" for example

# add in neuronal cts to predicted theta matrix
breg_theta <- cbind(breg_theta, rep(0,nrow(breg_theta)), rep(0,nrow(breg_theta)))
colnames(breg_theta)[8:9] <- c("Excitatory", "Inhibitory")

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# RCTD has 3070 spots. 2 were dropped during deconvolution

# -----------------------------------------
t_raw <- data.frame(truth_theta, group = "Actual")
p_raw <- data.frame(predict_theta, group = "Deconvolved")
dat <- rbind(t_raw, p_raw)

ggplot(data = reshape2::melt(dat), aes(x = reorder(variable, -value), y = value, color = group)) +
  # geom_boxplot() +
  geom_point(position=position_jitterdodge(0.1), cex=0.01) +
  # geom_jitter(aes(x = variable, y = value, color = group), position=position_jitter(0.1), cex=0.1) +
  # geom_jitter(data = reshape2::melt(truth_theta), aes(x = Var2, y = value), position=position_jitter(0.1), cex=0.1) +
  # scale_y_continuous(breaks = seq(0,max(predict_theta),1)) +
  labs(title = "RCTD without neuronals deconvolved pixel proportions versus reference",
       x = "Cell-type", y = "pixel proportions") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 15),
        # panel.grid = element_blank(),
        # axis.line=element_blank(),
        # axis.text.x=element_blank(),
        axis.text.y=element_text(size = 15),
        # axis.ticks=element_blank(),
        axis.title.x=element_text(size=15),
        axis.title.y=element_text(size=15),
        panel.background=element_blank()
        )
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-B-rctd_noNeuro_pixel_proportions-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)
# -----------------------------------------

# RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots)
  raw_RMSE_rctd_noNeur_8cts_spots <- c(raw_RMSE_rctd_noNeur_8cts_spots, rep(NA, toFill))
}

# RMSE for each ct. Unadjusted proportions
# return matrix where each column is the rmse for predicting a ct across the spots
raw_RMSE_rctd_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  mltools::rmse(preds = predict, actuals = actual)
}))
colnames(raw_RMSE_rctd_noNeur_8cts) <- colnames(truth_theta)

# ---------------------------------------------
# normalize each RMSE computes for each cell type by dividing by sd
raw_RMSE_rctd_noNeur_8cts_nrmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  # so a RMSE for each ct
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  rmse <- mltools::rmse(preds = predict, actuals = actual)
  nrmse <- rmse/sd(actual)
  nrmse
}))
colnames(raw_RMSE_rctd_noNeur_8cts_nrmse) <- colnames(truth_theta)

# ---------------------------------------------
# # If you want to compute the RMSE for each pixel, then each difference ( yp - yt) will need to be adjusted to the same scale.
# # such that for example, the 90 - 100 = 10 on a 1 to 100 scale vs 0.9 - 1.0 = 0.1 on a 0 to 1.0 scale end up being the same 
# # contribution to the RMSE. Possible solution: 10/100 = 0.1; 0.1/1.0 = 0.1. So divide each difference by the max of the respective scale.
# # But could be outliers, so maybe divide by something else, like 75% quartile? Median or Mean?
# # Let's do mean because for some cts, the 25%, 75%, median, min, are 0 wrt the truth for rare cts. Mean is at least positive non-zero as long as ct present in one pixel. Sd might also be a viable option. 

adjDiffRMSE <- function(preds, actuals, adj){
  # take difference of each predict and truth ct proportion, but then adjust
  # each difference by the mean truth proportion (this is the new piece)
  squared_sums <- sum(((actuals - preds)/adj)^2)
  mse <- squared_sums/length(actuals)
  rmse <- sqrt(mse)
  return(rmse)
}

adj <- apply(truth_theta, 2, sd)
# Adjusted RMSE for each spot. Unadjusted ct proportions
raw_RMSE_rctd_noNeur_8cts_spots_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  adjDiffRMSE(preds = predict, actuals = actual, adj = adj)
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots_adj)
  raw_RMSE_rctd_noNeur_8cts_spots_adj <- c(raw_RMSE_rctd_noNeur_8cts_spots_adj, rep(NA, toFill))
}

# ---------------------------------------------
# # Another idea: compute the cosine similarity of each predicted and truth pixel vector. Each vector must sum to 1. So deviations in proportions of cell types would shift the directionality of the predicted vector, right?

# for pixels:
raw_RMSE_rctd_noNeur_8cts_spots_cosine <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  # for each spot, compute RMSE based on proportions across cts
  # so a RMSE for each spots based on all the cts
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))

# because missing spots for some reason, fill in by adding NAs
if (length(raw_RMSE_rctd_noNeur_8cts_spots_cosine) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(raw_RMSE_rctd_noNeur_8cts_spots_cosine)
  raw_RMSE_rctd_noNeur_8cts_spots_cosine <- c(raw_RMSE_rctd_noNeur_8cts_spots_cosine, rep(NA, toFill))
}

# for cts:
raw_RMSE_rctd_noNeur_8cts_cosine <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  # for each ct, compare proportions across all the spots
  actual <- as.vector(truth_theta[,ct])
  predict <- as.vector(predict_theta[,ct])
  m <- cbind(predict, actual)
  lsa::cosine(m)["actual", "predict"]
}))
colnames(raw_RMSE_rctd_noNeur_8cts_cosine) <- colnames(truth_theta)

# ---------------------------------------------
# # scale the ct proportions by dividing each by its sd
# truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
# predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))
# 
# # because all 0's for neuronal, returns NAs. Convert to 0
# predict_theta[is.na(predict_theta)] <- 0
# 
# # RMSE for each spot. Unadjusted ct proportions
# scaled_RMSE_rctd_noNeur_8cts_spots <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
#   # for each spot, compute RMSE based on proportions across cts
#   # so a RMSE for each spots based on all the cts
#   actual <- as.vector(truth_theta[i,])
#   predict <- as.vector(predict_theta[i,])
#   mltools::rmse(preds = predict, actuals = actual)
# }))
# 
# # because missing spots for some reason, fill in by adding NAs
# if (length(scaled_RMSE_rctd_noNeur_8cts_spots) < dim(breg_gt_theta)[1]){
#   toFill <- dim(breg_gt_theta)[1] - length(scaled_RMSE_rctd_noNeur_8cts_spots)
#   scaled_RMSE_rctd_noNeur_8cts_spots <- c(scaled_RMSE_rctd_noNeur_8cts_spots, rep(NA, toFill))
# }
# 
# # RMSE for each ct. Unadjusted proportions
# # return matrix where each column is the rmse for predicting a ct across the spots
# scaled_RMSE_rctd_noNeur_8cts <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
#   # for each ct, compare proportions across all the spots
#   # so a RMSE for each ct
#   mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
# }))
# colnames(scaled_RMSE_rctd_noNeur_8cts) <- colnames(truth_theta)

```

## ----------------------------------
## Compare across spots

Spots:
raw_RMSE_sl_8cts_spots
raw_RMSE_rctd_8cts_spots
raw_RMSE_lda_8cts_spots
raw_RMSE_sl_noNeur_8cts_spots
raw_RMSE_rctd_noNeur_8cts_spots

raw_RMSE_sl_75cts_spots
raw_RMSE_rctd_75cts_spots
raw_RMSE_lda_75cts_spots
raw_RMSE_sl_noNeur_8cts_spots
raw_RMSE_rctd_noNeur_8cts_spots

scaled_RMSE_sl_8cts_spots
scaled_RMSE_rctd_8cts_spots
scaled_RMSE_lda_8cts_spots
scaled_RMSE_sl_noNeur_8cts_spots
scaled_RMSE_rctd_noNeur_8cts_spots

scaled_RMSE_sl_75cts_spots
scaled_RMSE_rctd_75cts_spots
scaled_RMSE_lda_75cts_spots
scaled_RMSE_sl_noNeur_8cts_spots
scaled_RMSE_rctd_noNeur_8cts_spots

### 9 ct 135 genes

```{r}

raw_8cts <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots),
                        "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
summary(raw_8cts)
write.csv(summary(raw_8cts), paste0(fig_path, "rmse_raw_8cts.csv"))

raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots)
                        )

ggplot(data = reshape2::melt(raw_8cts),
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none")
# ggplot2::ggsave(filename = paste0("1_100um_9cts_135genes_RMSE_lda_sl_rctd.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                        "SPOTlight\nmissing neuronals" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD\nmissing neuronals" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))

dat <- reshape2::melt(raw_8cts)

dat$variable <- factor(dat$variable)
levels(dat$variable) <- c('STdeconvolve', 'SPOTlight\nmissing neuronals', 'RCTD\nmissing neuronals')

ggplot(data = dat,
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none")
# ggplot2::ggsave(filename = paste0("1_100um_9cts_135genes_RMSE_lda_sl_rctd_noNeuros.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)


raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
                       "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots),
                        "SPOTlight\nmissing neuronals" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD\nmissing neuronals" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))

dat <- reshape2::melt(raw_8cts)

dat$variable <- factor(dat$variable)
levels(dat$variable) <- c('STdeconvolve', 'SPOTlight', 'RCTD', 'SPOTlight\nmissing neuronals', 'RCTD\nmissing neuronals')

ggplot(data = dat,
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 15),
        axis.text.y = element_text(size=15),
        # strip.text = element_text(size=15),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=15, face=NULL),
        legend.position = "none")
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S5-A-rmse_across_pixels-100um_k9_ct9_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

# -----------------------------------------------------------------------------

# raw_8cts_adj <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_adj),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# summary(raw_8cts_adj)
# write.csv(summary(raw_8cts_adj), paste0(fig_path, "rmse_raw_8cts_adj.csv"))
# 
# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_adj)
#                         )
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots; sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)
# 
# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_8cts_cosine <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_cosine),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# summary(raw_8cts_cosine)
# write.csv(summary(raw_8cts_cosine), paste0(fig_path, "rmse_raw_8cts_cosine.csv"))
# 
# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_8cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_8cts_spots_cosine)
#                         )
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots; cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)
# 
# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

```

### 76

```{r}

raw_75cts <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots),
                        "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots),
                        "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
                        "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
summary(raw_75cts)
write.csv(summary(raw_75cts), paste0(fig_path, "rmse_raw_75cts.csv"))

raw_75cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots),
                        "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots),
                        "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots)
                        )

ggplot(data = reshape2::melt(raw_75cts),
       aes(x = variable, y = value, fill = variable)) +
  # geom_boxplot(outlier.shape=NA) +
  # geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) +
  ggplot2::geom_violin(trim=TRUE, fill="gray") +
  ggplot2::geom_boxplot(width=0.1, outlier.shape=NA, fill="white") +
  labs(title = "Deconvolution accuracy across simulated MERFISH pixels\n100 micron pixels, 76 cell-types",
       x = "Method", y = "RMSE") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=10),
        legend.position = "none")
ggplot2::ggsave(filename = paste0("1_100um_76cts_135genes_RMSE_lda_sl_rctd.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 300)

# raw_8cts <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots))
# 
# ggplot(data = reshape2::melt(raw_8cts),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots",
#        x = "Method", y = "RMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_75cts_adj <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_adj),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# summary(raw_75cts_adj)
# write.csv(summary(raw_75cts_adj), paste0(fig_path, "rmse_raw_75cts_adj.csv"))
# 
# raw_75cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_adj),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_adj),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_adj)
#                         )
# 
# ggplot(data = reshape2::melt(raw_75cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-subtype predictions in FN7 spots; sd adj",
#        x = "Method", y = "NRMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# raw_8cts_adj <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_adj),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_adj),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_adj))
# 
# ggplot(data = reshape2::melt(raw_8cts_adj),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, sd adj",
#        x = "Method", y = "RMSE") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# -----------------------------------------------------------------------------

# raw_75cts_cosine <- data.frame("SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_cosine),
#                         "STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# summary(raw_75cts_cosine)
# write.csv(summary(raw_75cts_cosine), paste0(fig_path, "rmse_raw_75cts_cosine.csv"))
# 
# raw_75cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_75cts_spots_cosine),
#                         "SPOTlight" = as.vector(raw_RMSE_sl_75cts_spots_cosine),
#                         "RCTD" = as.vector(raw_RMSE_rctd_75cts_spots_cosine)
#                         )
# 
# ggplot(data = reshape2::melt(raw_75cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-subtype predictions in FN7 spots; cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

# raw_8cts_cosine <- data.frame("STdeconvolve" = as.vector(raw_RMSE_lda_8cts_spots_cosine),
#                         "SPOTlight noNeuro" = as.vector(raw_RMSE_sl_noNeur_8cts_spots_cosine),
#                         "RCTD noNeuro" = as.vector(raw_RMSE_rctd_noNeur_8cts_spots_cosine))
# 
# ggplot(data = reshape2::melt(raw_8cts_cosine),
#        aes(x = variable, y = value, fill = variable)) +
#   geom_boxplot(outlier.shape=NA) +
#   geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
#   labs(title = "MERFISH cell-type predictions in FN7 spots, cosine",
#        x = "Method", y = "Cosine Similarity") +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# # ggsave(filename = "Fig_2-RMSEraw-mjr-cts.pdf",
# #        device = "pdf",
# #        path = fig_path,
# #        scale = 1.5,
# #        width = 5,
# #        height = 4,
# #        units = c("in"),
# #        dpi = 600)

```

rmse differ between 8 and 75 because proportions of the 75 cts are much smaller

but comparing cell-type to cell-type should normalize before comparing

## ----------------------------------
## Compare across cell types

cts:
raw_RMSE_sl_8cts
raw_RMSE_rctd_8cts
raw_RMSE_lda_8cts
raw_RMSE_sl_noNeur_8cts
raw_RMSE_rctd_noNeur_8cts

raw_RMSE_sl_75cts
raw_RMSE_rctd_75cts
raw_RMSE_lda_75cts
raw_RMSE_sl_noNeur_8cts
raw_RMSE_rctd_noNeur_8cts

scaled_RMSE_sl_8cts
scaled_RMSE_rctd_8cts
scaled_RMSE_lda_8cts
scaled_RMSE_sl_noNeur_8cts
scaled_RMSE_rctd_noNeur_8cts

scaled_RMSE_sl_75cts
scaled_RMSE_rctd_75cts
scaled_RMSE_lda_75cts
scaled_RMSE_sl_noNeur_8cts
scaled_RMSE_rctd_noNeur_8cts

### 9 ct 135 genes


change colnames of the celltype table to match the changes made previously
```{r}

colnames(FN7_cellTypeTable) <- sub("\\-", " ", colnames(FN7_cellTypeTable))

```


#### raw rmse

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion, # overall proportion in ground truth dataset
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary <- do.call("rbind", list(raw_RMSE_sl_8cts_df,
                                                  raw_RMSE_rctd_8cts_df,
                                                  raw_RMSE_lda_8cts_df,
                                                  raw_RMSE_sl_noNeur_8cts_df,
                                                  raw_RMSE_rctd_noNeur_8cts_df))

```

#### raw NRMSE

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary_nrmse <- do.call("rbind", list(raw_RMSE_sl_8cts_df_nrmse,
                                                  raw_RMSE_rctd_8cts_df_nrmse,
                                                  raw_RMSE_lda_8cts_df_nrmse,
                                                  raw_RMSE_sl_noNeur_8cts_df_nrmse,
                                                  raw_RMSE_rctd_noNeur_8cts_df_nrmse))

```

#### Cosine

```{r}

# for each cell type rmse across spots, build a dataframe that has the rmse as well as other info for the cell type.
# idea is to combine dataframes for each methods returned rmse for a cell type and then visualize
# the relationship between RMSE and cell type proportion. Compare across methods, cell types, other info, etc.

l_eachCt <- raw_RMSE_sl_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_lda_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_sl_noNeur_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight missing neuronals", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_sl_noNeur_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_noNeur_8cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD missing neuronals", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_9ct_135genes$gtSpotTopics, 2, sd)[cts]

raw_RMSE_rctd_noNeur_8cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)



# now combine them all:
k8_raw_ct_rmse_summary_cosine <- do.call("rbind", list(raw_RMSE_sl_8cts_df_cosine,
                                                  raw_RMSE_rctd_8cts_df_cosine,
                                                  raw_RMSE_lda_8cts_df_cosine,
                                                  raw_RMSE_sl_noNeur_8cts_df_cosine,
                                                  raw_RMSE_rctd_noNeur_8cts_df_cosine))

```

### 76

change colnames of the celltype table to match the changes made previously
```{r}

colnames(FN7_neuro_cellTypeTable) <- sub("\\-", " ", colnames(FN7_neuro_cellTypeTable))

gt <- simFN7_neuro_9ct_135genes$gtSpotTopics
colnames(gt) <- sub("\\-", " ", colnames(gt))
```

#### raw rmse

```{r}

l_eachCt <- raw_RMSE_sl_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_sl_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_rctd_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts
cts <- labels(l_eachCt)[[2]]
cts <- sub("\\-", " ", cts)
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Raw", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_lda_75cts_df <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary <- do.call("rbind", list(raw_RMSE_sl_75cts_df,
                                                  raw_RMSE_rctd_75cts_df,
                                                  raw_RMSE_lda_75cts_df))

```

#### raw NRMSE

```{r}

l_eachCt <- raw_RMSE_sl_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_sl_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_rctd_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts_nrmse
cts <- labels(l_eachCt)[[2]]
cts <- sub("\\-", " ", cts)
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("NRMSE", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_lda_75cts_df_nrmse <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary_nrmse <- do.call("rbind", list(raw_RMSE_sl_75cts_df_nrmse,
                                                  raw_RMSE_rctd_75cts_df_nrmse,
                                                  raw_RMSE_lda_75cts_df_nrmse))

```

#### Cosine

```{r}

l_eachCt <- raw_RMSE_sl_75cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_sl_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_rctd_75cts_cosine
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_rctd_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

l_eachCt <- raw_RMSE_lda_75cts_cosine
cts <- labels(l_eachCt)[[2]]
cts <- sub("\\-", " ", cts)
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("STdeconvolve", length(cts))
rmse_type <- rep("Cosine", length(cts))
# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])
# max proportion in a spot
spot_max <- apply(gt, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(gt, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(gt, 2, sd)[cts]

raw_RMSE_lda_75cts_df_cosine <- data.frame("Cell type" = cts,
                             "RMSE" = rmses,
                             # "Bregma" = breg,
                             "RMSE kind" = rmse_type,
                             "Method" = tool,
                             "Proportion" = proportion,
                             "Max spot proportion" = spot_max,
                             "Median spot proportion" = spot_median,
                             "Spot proportion std" = spot_sd)

# now combine them all:
k75_raw_ct_rmse_summary_cosine <- do.call("rbind", list(raw_RMSE_sl_75cts_df_cosine,
                                                  raw_RMSE_rctd_75cts_df_cosine,
                                                  raw_RMSE_lda_75cts_df_cosine))

```

### visualize

k8_raw_ct_rmse_summary
k8_scaled_ct_rmse_summary
k75_raw_ct_rmse_summary
k75_scaled_ct_rmse_summary

```{r, fig.height=4, fig.width=10}

ggplot(data = k8_raw_ct_rmse_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 9 cell-type predictions by method",
       x = "Method", y = "RMSE")

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 9 cell-type predictions by method",
       x = "Method", y = "NRMSE")

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 9 cell-type predictions by method",
       x = "Method", y = "Cosine Similarity")

```

The RMSE above is the proportion for each cell type. In general could compare ct to ct but note that for some cts that have lower proportions overall like OD and pericytes, the RMSE not really comparable because it will be lower as their proportion is lower.

Microglia is the one major CT where LDA has some trouble compared to the other methods. LDA does better for Excitatory than other methods. Removal of Neuronal cells causes RCTD to struggle with Astrocytes. SPOTlight also has trouble with Microglia.

```{r, fig.height=16, fig.width=10}

ggplot(data = k75_raw_ct_rmse_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "RMSE")

ggplot(data = k75_raw_ct_rmse_summary_nrmse, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "NRMSE")

ggplot(data = k75_raw_ct_rmse_summary_cosine, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH all cell-types and -subtypes predictions by method",
       x = "Method", y = "Cosine Similarity")

```

Looking closer, SPOTlight also does worse with ODs. LDA does well for Inhibatory subtypes - sometimes better than RCTD and SPOTlight


Proportion = overall proportion in ground truth dataset

#### 9 cell-types each method

```{r, fig.height=6, fig.width=12}

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 9 cell-types", y = "Normalized RMSE",
       x = "proportion in ground truth dataset") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_9cts_135genes_NRMSE_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = k8_raw_ct_rmse_summary_nrmse, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 9 cell-types", y = "Normalized RMSE",
       x = "Pixel proportion std") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_9cts_135genes_NRMSE_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

## ----------------------------------------------------------------

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 9 cell-types", y = "Cosine Similarity",
       x = "proportion in ground truth dataset") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_9cts_135genes_Cosine_vs_proportion.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = k8_raw_ct_rmse_summary_cosine, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=3) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 13),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 9 cell-types", y = "Cosine Similarity",
       x = "Pixel proportion std") +
  guides(color=guide_legend(title="Cell-types"))
ggplot2::ggsave(filename = paste0("2_100um_9cts_135genes_Cosine_vs_std.png"),
         device = "png",
         path = fig_path,
         scale = 1.5,
         width = 7,
         height = 4,
         units = c("in"),
         dpi = 300)

```

STdeconvolve and SPOTlight in general do worse for cts at overall lower proportions.

```{r, fig.height=6, fig.width=16}

ggplot(data = k75_raw_ct_rmse_summary, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "RMSE")

ggplot(data = k75_scaled_ct_rmse_summary, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "Scaled RMSE")

ggplot(data = k75_raw_ct_rmse_summary_nrmse, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "NRMSE")

ggplot(data = k75_raw_ct_rmse_summary_cosine, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point() +
  facet_wrap(~Method) +
  theme_classic() +
  labs(title = "MERFISH all cell-type and -subtype predictions by method", y = "Cosine Similarity")

```

```{r}

k75_raw_ct_rmse_summary_nrmse[k75_raw_ct_rmse_summary_nrmse$Cell.type != "I-39",]

```

#### 76 cell-types each method

# Hide all of the text labels.
  dat$selectedLabels1 <- ""
  # Let's just label these top items.
  ix_label <- seq(15)
  dat$selectedLabels1[ix_label] <- dat$genes[ix_label]
  
  # dat$selectedLabels2 <- ""
  # # Let's label these bottom items
  # ix_label <- tail(seq(length(log2fc)), 5)
  # dat$selectedLabels2[ix_label] <- dat$genes[ix_label]
  
  p2 <- ggplot(data = dat) +
    geom_col(aes(x = order, y = values, fill = " ")) +
    scale_fill_manual(values = transparentCol("darkgray", percent = 70)) +
    labs(title = paste0("Deconvolved cell-type ", celltype, " transcriptional profile"),
         x = "Gene expression rank", y = "log2FC Normalized and scaled expression") +
    # coord_cartesian(clip = "off") +
    ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels1), size = 3, 
                    min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 2.5, direction = "both", hjust = "left",
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
    # ggrepel::geom_text_repel(data = dat, mapping = aes(x = order, y = values, label = selectedLabels2), size = 5, 
    #                 min.segment.length = 0.01, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
    #                 # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
    #                 nudge_x = -10, direction = "y", hjust = "right",
    #                 # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    # ) +
    theme_classic() +
    

```{r}

dat %>% arrange(Method, -RMSE)

```


```{r, fig.height=4, fig.width=12}

# only 1 I-39 cell in ref. Inflates the NRMSE. Remove
dat <- k75_raw_ct_rmse_summary_nrmse[k75_raw_ct_rmse_summary_nrmse$Cell.type != "I 39",]

dat$selectedLabels <- ""
ix_label <- which(dat$Cell.type %in% c("Pericytes", "Ependymal", "Astrocyte", "OD Mature"))
dat$selectedLabels[ix_label] <- dat$Cell.type[ix_label]

## RCTD largest RMSE
dat$selectedLabels[135] <- "I 32"
## SPOTlight largest RMSE
dat$selectedLabels[19] <- "E 25"
dat$selectedLabels[49] <- "I 21"
## STdeconvolve largest RMSE
dat$selectedLabels[207] <- "E 25"
dat$selectedLabels[187] <- "I 32"



ggplot(data = dat, aes(x = Proportion, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  ggrepel::geom_text_repel(data = dat, mapping = aes(x = Proportion, y = RMSE, label = selectedLabels), size = 3, 
                    min.segment.length = 1.5, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 0.03, direction = "both", hjust = "left", nudge_y = 2
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 76 cell-types", y = "Normalized RMSE",
       x = "proportion of ground truth dataset") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S14-A-nrmse_v_proportion-100um_76cts_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

ggplot(data = dat, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
  geom_point(size=1) +
  ggrepel::geom_text_repel(data = dat, mapping = aes(x = Spot.proportion.std, y = RMSE, label = selectedLabels), size = 3, 
                    min.segment.length = 1.5, seed = 42, box.padding = 0.1, max.overlaps = Inf, point.padding = 0.01,
                    # fill = "white", xlim = c(-Inf, Inf), ylim = c(-Inf, Inf), 
                    nudge_x = 0.03, direction = "both", hjust = "left", nudge_y = 2
                    # segment.curvature = -0.1, segment.ncp = 3, segment.angle = 20)
    ) +
  facet_wrap(~Method) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 0, size = 10),
        axis.text.y=element_text(size=15),
        strip.text = element_text(size=15),
        # axis.title.x = element_text(size=15),
        # axis.title.y = element_text(size=15),
        axis.title=element_text(size=15),
        plot.title = element_text(size=18, face=NULL)) +
  labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 76 cell-types", y = "Normalized RMSE",
       x = "pixel proportion std") +
  guides(color=guide_legend(title="Cell-types", ncol = 6))
ggplot2::ggsave(filename = paste0("Supplemental_Figure_S14-A-nrmse_v_sd-100um_76cts_135genes.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 8.5,
         height = 4,
         units = c("in"),
         dpi = 300)

## ----------------------------------------------------------------

# dat <- k75_raw_ct_rmse_summary_cosine[k75_raw_ct_rmse_summary_cosine$Cell.type != "I-39",]
# 
# ggplot(data = dat, aes(x = Proportion, y = RMSE, color = Cell.type)) +
#   geom_point(size=1) +
#   facet_wrap(~Method) +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 0, size = 10),
#         axis.text.y=element_text(size=15),
#         strip.text = element_text(size=15),
#         # axis.title.x = element_text(size=15),
#         # axis.title.y = element_text(size=15),
#         axis.title=element_text(size=15),
#         plot.title = element_text(size=18, face=NULL)) +
#   labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 76 cell-types", y = "Cosine Similarity",
#        x = "proportion of ground truth dataset") +
#   guides(color=guide_legend(title="Cell-types", ncol = 6))
# ggplot2::ggsave(filename = paste0("2_100um_76cts_135genes_Cosine_vs_proportion.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 8.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)
# 
# ggplot(data = dat, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type)) +
#   geom_point(size=1) +
#   facet_wrap(~Method) +
#   theme_classic() +
#   theme(axis.text.x = element_text(angle = 0, size = 10),
#         axis.text.y=element_text(size=15),
#         strip.text = element_text(size=15),
#         # axis.title.x = element_text(size=15),
#         # axis.title.y = element_text(size=15),
#         axis.title=element_text(size=15),
#         plot.title = element_text(size=18, face=NULL)) +
#   labs(title = "Deconvolution accuracy of each cell-type\n100 micron pixels, 76 cell-types", y = "Cosine Similarity",
#        x = "pixel proportion std") +
#   guides(color=guide_legend(title="Cell-types", ncol = 6))
# ggplot2::ggsave(filename = paste0("2_100um_76cts_135genes_Cosine_vs_std.png"),
#          device = "png",
#          path = fig_path,
#          scale = 1.5,
#          width = 8.5,
#          height = 4,
#          units = c("in"),
#          dpi = 300)

```


In general the trend is that at higher proportions each method has an easier time deconvolving cell types. But for rare neuronal subtypes, it is highly variable depending on subtype. Might be because the MERFISH genes were marker genes so in theory should be able to ID the subtypes. Of course some are probably similar and thus become more difficult to ID.



























