---
title: "Figure1_proof_of_concept"
author: "Brendan F. Miller"
date: "3/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# MERFISH mPOA

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mpoa_merfish_clean.RData")
# has `annot.table`, `counts`, and `features` objects

# annot.table: table of the individual cells and data like coordinates, cell types, bregma, animal
# features: has cells and additional features. Also dataset they belong to
# counts: gene counts of cell in annot.table for 130 merfish genes profiled

# unique(features$dataset_name)
#  [1] "170908_FN3_2_M22_M26"    "170917_MN1_1pp_M22_M26" 
#  [3] "170919_FN4_1_M22_M26"    "170921_FN4_2_M22_M26"   
#  [5] "170923_FN4_1pp_M22_M26"  "170925_MN2_1p_M22_M26"  
#  [7] "171021_FN7_2_M22_M26"    "171023_FN7_1_M22_M26"   
#  [9] "171024_MN5_2p_M22_M26"   "171027_MN5_1p_M22_M26"  
# [11] "171104_MN6_2_M22_M26"    "171112_MN8_2pppp"       
# [13] "171114_MN8_M22_M26_2pp"  "171208_MN9_2ppp_M22_M26"
# [15] "171118_BD3_1pp"          "171119_BD5_1pp"         
# [17] "171121_BD5_1"            "171123_BD5_2p"          
# [19] "171124_BD6_2ppp"         "171126_BD6_1pppp"       
# [21] "171128_BD7_1ppp"         "171129_BD7_1ppp_actual" 
# [23] "171201_BD_2ppp"          "171203_BD8_1pp"         
# [25] "171210_BD9_1pp"          "171211_BD9_2ppp_M22_M26"
# [27] "171214_BD10_2_M22_M26"   "171216_BD11_1_M22_M26"  
# [29] "171217_BD11_2_M22_M26"   "171219_BD12_1p_M22_M26" 
# [31] "171221_BD12_2p_M22_M26"  "171223_BD13_2p_M22_M26" 

```

Simulate ST spots for each bregma slice for a given MERFISH experiment data set

171021_FN7_2_M22_M26

```{r}

# select cells that are part of given data set:
selected_cells <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26')]

spatial_position_and_class <- annot.table[selected_cells,
                                          c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]

# remove rows with NA
spatial_position_and_class <- na.omit(spatial_position_and_class) 

```

```{r}

# reduce set of major cell class labels. Convert OD types to "OD" and
# "Endothelial types to "Endothelial"
spatial_position_and_class[grep(pattern = "OD",
                                x = spatial_position_and_class$Cell_class),]$Cell_class <- "OD"

spatial_position_and_class[grep(pattern = "Endothelial",
                                x = spatial_position_and_class$Cell_class),]$Cell_class <- "Endothelial"

# number of cells in the experiment across bregmas
dim(spatial_position_and_class)
# [1] 36329     5

# gene counts for individual cells
bregmaCellsGexp <- counts[rownames(spatial_position_and_class),]

# remove "Blanks" from data
bregmaCellsGexp <- bregmaCellsGexp[,!grepl("Blank", colnames(bregmaCellsGexp))]

```

```{r}

# to expand to neuronal subtypes, make a secondary vector of "Cell_class" where
# "Excitatory and "Inhibitory" are replaces with the respective "Neuron_cluster_ID"

Cell_class_major <- spatial_position_and_class$Cell_class

Cell_class_with_neuronal <- unlist(lapply(rownames(spatial_position_and_class), function(cell){
  class <- spatial_position_and_class[cell,]$Cell_class
  neuron <- spatial_position_and_class[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

length(Cell_class_with_neuronal)

```

The `buildBregmaCorpus` output contains a "gtCtGenes" ground truth cell type - gene expression matrix, but this is built by combining cells of the same Cell_class in the given bregma (and therefore may also be missing reference for cell types not present).

Let's also make a reference using all the cells across the bregmas.

```{r}

cellTypes <- spatial_position_and_class$Cell_class
cells <- rownames(spatial_position_and_class)

mat <- bregmaCellsGexp[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtGenes <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtGenes <- gtCtGenes[,!grepl("Blank", colnames(gtCtGenes))]
gtCtGenes <- gtCtGenes/rowSums(gtCtGenes)

dim(gtCtGenes)

```

```{r}

# simulate spots for each bregma and contain in a hash table
FN7_2_M22_M26 <- simulateBregmaSpots(spatial_position_and_class,
                                          counts = bregmaCellsGexp,
                                          patch_size = 100)

# now simulate but use all the neural types as well
spatial_position_and_class$Cell_class <- Cell_class_with_neuronal
FN7_2_M22_M26_neuro <- simulateBregmaSpots(spatial_position_and_class,
                                          counts = bregmaCellsGexp,
                                          patch_size = 100)

```

Let's also make a reference for all of the cell types including the neuronal ones

```{r}

cellTypes <- spatial_position_and_class$Cell_class
cells <- rownames(spatial_position_and_class)

mat <- bregmaCellsGexp[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtNeuronalGenes <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtNeuronalGenes <- gtCtNeuronalGenes[,!grepl("Blank", colnames(gtCtNeuronalGenes))]
gtCtNeuronalGenes <- gtCtNeuronalGenes/rowSums(gtCtNeuronalGenes)

dim(gtCtNeuronalGenes)

```

Construct corpuses using the simulations with the 9 major cell classes, or expanded to all of the neuronal subtypes

```{r}

simBregmas <- lapply(keys(FN7_2_M22_M26), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_2_M22_M26, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmas) <- keys(FN7_2_M22_M26)

simBregmas_neuro <- lapply(keys(FN7_2_M22_M26_neuro), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_2_M22_M26_neuro, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmas_neuro) <- keys(FN7_2_M22_M26_neuro)

```

Recall that the `$gtSpotTopics` are of primary interest to compare the fitted models to for each bregma. The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches.


When comparing to reference-dependent methods, could use a single scRNAseq reference made from all of the individual cells in `bregmaCellsGexp`. Or for each bregma, can make a reference based on the individual cells that were present in the spots. So that the models are restricted to the identical data that the LDA is presented,

```{r}

# "scRNAseq" reference using all the cells:
bregmaFullSeur <- CreateSeuratObject(counts = t(bregmaCellsGexp), project = "bregmaFull scRNAseq Ref")

# add cell class labels to the meta.data for assigning clusters later
bregmaFullSeur[["Major_class"]] <- Cell_class_major
bregmaFullSeur[["All_classes"]] <- Cell_class_with_neuronal

```

```{r}

# if using a "scRNAseq" reference for a given bregma in order to restrict to the same data as LDA:

# vectors of the class labels for the cells in the bregma patches:
breg_Cell_class_major <- simBregmas$`-0.04`$annotDf$Cell_class
breg_Cell_class_with_neuronal <- unlist(lapply(rownames(simBregmas$`-0.04`$annotDf), function(cell){
  class <- simBregmas$`-0.04`$annotDf[cell,]$Cell_class
  neuron <- simBregmas$`-0.04`$annotDf[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

# cells in the bregma patches:
breg04_patch_cells <- rownames(simBregmas$`-0.04`$annotDf)

# the gene counts for the bregma patch cells
breg04_scRNAseq <- FN7_2_M22_M26[["-0.04"]]$cellGexp[breg04_patch_cells,]

# "scRNAseq" reference using all the cells:
bregma04Seur <- CreateSeuratObject(counts = t(breg04_scRNAseq), project = "bregma scRNAseq Ref")

# add cell class labels to the meta.data for assigning clusters later
bregma04Seur[["Major_class"]] <- breg_Cell_class_major
bregma04Seur[["All_classes"]] <- breg_Cell_class_with_neuronal

```

# Entire Animal (FN7)

171021_FN7_2_M22_M26 (anterior) and 171023_FN7_1_M22_M26 (posterior)

```{r}

# select cells that are part of given data set:
selected_cells_FN7 <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26', "171023_FN7_1_M22_M26")]

spatial_position_and_class_FN7 <- annot.table[selected_cells_FN7,
                                          c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]

# remove rows with NA
spatial_position_and_class_FN7 <- na.omit(spatial_position_and_class_FN7) 

```

```{r}

# reduce set of major cell class labels. Convert OD types to "OD" and
# "Endothelial types to "Endothelial"
spatial_position_and_class_FN7[grep(pattern = "OD",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "OD"

spatial_position_and_class_FN7[grep(pattern = "Endothelial",
                                x = spatial_position_and_class_FN7$Cell_class),]$Cell_class <- "Endothelial"

# Remove Ambiguous cell type:
spatial_position_and_class_FN7 <- spatial_position_and_class_FN7[which(!spatial_position_and_class_FN7$Cell_class == "Ambiguous"),]

dim(spatial_position_and_class_FN7)
# [1] 59651     5

# gene counts for individual cells
bregmaCellsGexpFN7 <- counts[rownames(spatial_position_and_class_FN7),]

# remove "Blanks" from data
bregmaCellsGexpFN7 <- bregmaCellsGexpFN7[,!grepl("Blank", colnames(bregmaCellsGexpFN7))]

```

```{r}

# to expand to neuronal subtypes, make a secondary vector of "Cell_class" where
# "Excitatory and "Inhibitory" are replaces with the respective "Neuron_cluster_ID"

Cell_class_major_FN7 <- spatial_position_and_class_FN7$Cell_class

Cell_class_with_neuronal_FN7 <- unlist(lapply(rownames(spatial_position_and_class_FN7), function(cell){
  class <- spatial_position_and_class_FN7[cell,]$Cell_class
  neuron <- spatial_position_and_class_FN7[cell,]$Neuron_cluster_ID
  if (neuron != ""){
    i <- neuron
  } else {
    i <- class
  }
  i
}))

length(Cell_class_with_neuronal_FN7)

```

The `buildBregmaCorpus` output contains a "gtCtGenes" ground truth cell type - gene expression matrix, but this is built by combining cells of the same Cell_class in the given bregma (and therefore may also be missing reference for cell types not present).

Let's also make a reference using all the cells across the bregmas.

```{r}

cellTypesFN7 <- spatial_position_and_class_FN7$Cell_class
cellsFN7 <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cellsFN7,]
mm <- model.matrix(~ 0 + factor(cellTypesFN7))
colnames(mm) <- levels(factor(cellTypesFN7))
gtCtGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtGenes <- gtCtGenes[,!grepl("Blank", colnames(gtCtGenes))]
gtCtGenesFN7 <- gtCtGenesFN7/rowSums(gtCtGenesFN7)

dim(gtCtGenesFN7)

```

```{r}

# spatial_position_and_class_FN7$EachBregma <- spatial_position_and_class_FN7$Bregma
# spatial_position_and_class_FN7$Bregma <- spatial_position_and_class_FN7$EachBregma

```

The function looks at the "Bregma" colummn so make these entries all the same in order to combine

```{r}

# simulate spots for each bregma and contain in a hash table
FN7 <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 100)

# now simulate but use all the neural types as well
spatial_position_and_class_FN7$Cell_class <- Cell_class_with_neuronal_FN7
FN7_neuro <- simulateBregmaSpots(spatial_position_and_class_FN7,
                                          counts = bregmaCellsGexpFN7,
                                          patch_size = 100)

```

Let's also make a reference for all of the cell types including the neuronal ones

```{r}

cellTypes <- spatial_position_and_class_FN7$Cell_class
cells <- rownames(spatial_position_and_class_FN7)

mat <- bregmaCellsGexpFN7[cells,]
mm <- model.matrix(~ 0 + factor(cellTypes))
colnames(mm) <- levels(factor(cellTypes))
gtCtNeuronalGenesFN7 <- t(t(as.matrix(mat)) %*% mm)
# remove "Blanks" from data:
# gtCtNeuronalGenes <- gtCtNeuronalGenes[,!grepl("Blank", colnames(gtCtNeuronalGenes))]
gtCtNeuronalGenesFN7 <- gtCtNeuronalGenesFN7/rowSums(gtCtNeuronalGenesFN7)

dim(gtCtNeuronalGenesFN7)

```

Construct corpuses using the simulations with the 9 major cell classes, or expanded to all of the neuronal subtypes

```{r}

simBregmasFN7 <- lapply(keys(FN7), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7) <- keys(FN7)

simBregmasFN7_neuro <- lapply(keys(FN7_neuro), function(ix){
  bregma <- buildBregmaCorpus(hashTable = FN7_neuro, 
                                bregmaID = ix)
  print(bregma$sim)
  print(dim(bregma$gtSpotTopics))
  print(dim(bregma$gtCtGenes))
  bregma
})
names(simBregmasFN7_neuro) <- keys(FN7_neuro)

```

Recall that the `$gtSpotTopics` are of primary interest to compare the fitted models to for each bregma. The `$gtCtGenes` for these corpuses are based only using the cells that were in the given bregma and in simulated patches.


Combine simulated bregmas in the `simBregma` lists to make a single corpus for all bregmas to train a single model.
The `gtSpotTopics` can be combined as well for a ground truth reference, but each `gtCtGenes` is built using just the cells in each given bregma. So instead use the `gtCtGenesFN7` or `gtCtNeuronalGenesFN7`, which were average gexp for cell types across all cells.

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7 <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- as.matrix(simBregmasFN7[[ix]]$sim)
  m
})))
sim_N7

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7 <- lapply(names(simBregmasFN7), function(ix){
  simBregmasFN7[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7) <- names(simBregmasFN7)
gtSpotTopics_N7 <- data.table::rbindlist(gtSpotTopics_N7, fill = TRUE)
dim(gtSpotTopics_N7)
gtSpotTopics_N7 <- as.matrix(gtSpotTopics_N7)
rownames(gtSpotTopics_N7) <- rownames(sim_N7)
gtSpotTopics_N7[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7[is.na(gtSpotTopics_N7)] <- 0
gtSpotTopics_N7[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7)
cellCounts_N7[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7 <- do.call(rbind, lapply(names(simBregmasFN7), function(ix){
  m <- simBregmasFN7[[ix]]$annotDf
  m
}))
dim(annotDf_N7)
annotDf_N7[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7 <- list(sim = sim_N7,
               gtSpotTopics = gtSpotTopics_N7,
               gtCtGenes = gtCtGenesFN7,
               cellCounts = cellCounts_N7,
               # classColors = classColors,
               annotDf = annotDf_N7)

```

```{r}

# 1. sim
# combine the sim slam matrices to make the corpus for all spots across all bregmas
sim_N7_neuro <- slam::as.simple_triplet_matrix(do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- as.matrix(simBregmasFN7_neuro[[ix]]$sim)
  m
})))
sim_N7_neuro

# 2. gtSpotTopics
# each gtSpotTopics ref can have different numbers of cell types that are present in each bregma,
# at least for the neuro. So need a way to combine and have all 75 columns,
# and set 0 for patches that do not have any of one ct
gtSpotTopics_N7_neuro <- lapply(names(simBregmasFN7_neuro), function(ix){
  simBregmasFN7_neuro[[ix]]$gtSpotTopics
})
names(gtSpotTopics_N7_neuro) <- names(simBregmasFN7_neuro)
gtSpotTopics_N7_neuro <- data.table::rbindlist(gtSpotTopics_N7_neuro, fill = TRUE)
dim(gtSpotTopics_N7_neuro)
gtSpotTopics_N7_neuro <- as.matrix(gtSpotTopics_N7_neuro)
rownames(gtSpotTopics_N7_neuro) <- rownames(sim_N7_neuro)
gtSpotTopics_N7_neuro[1:10,]

# Cts not present in a bregma but columns added here have NA values
# replace NAs with 0's
gtSpotTopics_N7_neuro[is.na(gtSpotTopics_N7_neuro)] <- 0
gtSpotTopics_N7_neuro[1:10,]

# 3. gtCtGenes
# the `gtCtGenes` is the beta of the average gene expression for each cell cluster,
# in this case using all of cells across the bregma in the animal
dim(gtCtNeuronalGenesFN7)

# 4. cellCounts
# counts of cells in each simulated spot, but also has spot coordinates for easy plotting
cellCounts_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$cellCounts
  m
}))
dim(cellCounts_N7_neuro)
cellCounts_N7_neuro[1:10,]

# 5. annotDf
# recall this is meta data data frame includes information for only the cells that were kept in simulated spots
annotDf_N7_neuro <- do.call(rbind, lapply(names(simBregmasFN7_neuro), function(ix){
  m <- simBregmasFN7_neuro[[ix]]$annotDf
  m
}))
dim(annotDf_N7_neuro)
annotDf_N7_neuro[1:10,]


# construct the list similar to the output of `buildBregmaCorpus()`
simFN7_neuro <- list(sim = sim_N7_neuro,
               gtSpotTopics = gtSpotTopics_N7_neuro,
               gtCtGenes = gtCtNeuronalGenesFN7,
               cellCounts = cellCounts_N7_neuro,
               # classColors = classColors,
               annotDf = annotDf_N7_neuro)

```

When comparing to reference-dependent methods, could use a single scRNAseq reference made from all of the individual cells in `bregmaCellsGexp`. Or for each bregma, can make a reference based on the individual cells that were present in the spots. So that the models are restricted to the identical data that the LDA is presented,

```{r}

dim(bregmaCellsGexpFN7)

# for equal comparison, use the same cells that were kept in the simulated spots
bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simFN7$annotDf),]
dim(bregmaCellsGexpFN7_filt)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur <- CreateSeuratObject(counts = t(bregmaCellsGexpFN7_filt), project = "bregmaFull scRNAseq Ref")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur[["Major_class"]] <- simFN7$annotDf$Cell_class
bregmaFN7FullSeur[["All_classes"]] <- simFN7_neuro$annotDf$Cell_class

```

# MOB

Using the mOB from MERIGNUE and the 12 Stahl et al mOB replicates (13 total data sets), find a common set of genes to use in the corpus for each replicate so that they can be compared equally

```{r}

data(mOB) # from `MERIGNUE`
cd <- mOB$counts # 15928 genes   262 spots

```

```{r}

# list of either the mob data sets or paths to the data for inputs into `preprocess`

mob_paths <- list()
mob_paths[[1]] <- t(cd) # preprocess input needs to be spot x genes

# paths to Stahl data:
p <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/"
stahlMobDatPaths <- list.files(path = p, pattern = "*MOB_count_matrix-1.tsv", full.names = FALSE)
# add to the list
i <- 1
while(i < length(stahlMobDatPaths) + 1){
  mob_paths[[i+1]] <- paste0(p, stahlMobDatPaths[i])
  i <- i + 1
}

```

```{r}

mobRepGenes <- lapply(mob_paths, function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = FALSE,
                   selected.genes = NA,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 100,
                   min.lib.size = 100,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.25, # increase due to filtering by intersection of reps
                   gam.k = 5)
  colnames(dat$corpus)
})

commonMobGenes <- Reduce(intersect, mobRepGenes)
length(commonMobGenes)

```

Now construct corpuses for each mob dataset using the common set of mob genes

```{r}

# first do the Stahl data because can get positional information from the spot IDs
mobCorpus <- lapply(mob_paths[2:13], function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = TRUE,
                   selected.genes = commonMobGenes,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 100,
                   min.lib.size = 100,
                   ODgenes = FALSE,
                   od.genes.alpha = 0.05, # ODgenes ignored; so is this
                   gam.k = 5) # ODgenes ignored; so is this
  dat
})

names(mobCorpus) <- unlist(strsplit(stahlMobDatPaths, "_MOB_count_matrix-1.tsv"))

```

```{r}

# now do the MERINGUE mob. Positions added in separately
mobCorpus[["mob"]] <- preprocess(mob_paths[[1]],
                                 alignFile = NA,
                                 extractPos = FALSE,
                                 selected.genes = commonMobGenes,
                                 nTopGenes = NA,
                                 genes.to.remove = NA,
                                 perc.spots = NA,
                                 min.reads = 100,
                                 min.lib.size = 100,
                                 ODgenes = FALSE,
                                 od.genes.alpha = 0.05, # ODgenes ignored; so is this
                                 gam.k = 5) # ODgenes ignored; so is this

# positions already included in `mOB$pos` but make sure only use the filtered positions in the corpus
mobCorpus[["mob"]]$pos <- mOB$pos[rownames(mobCorpus[["mob"]]$corpus), ]

```

## MOB scRNAseq ref

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

mob_se_wt <- mob_se[,wt_cells]

meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

```

Construct proxy "beta" by combining gene expression of cells of same cell types

```{r}

mobWtCellClusters <- meta.data.wt$ClusterName
names(mobWtCellClusters) <- meta.data.wt$X

mobWtCellProxyBeta <- model.matrix(~ 0 + as.factor(mobWtCellClusters))

rownames(mobWtCellProxyBeta) <- names(mobWtCellClusters)

# fix names
colnames(mobWtCellProxyBeta) <- unlist(lapply(colnames(mobWtCellProxyBeta), function(x) {
  unlist(strsplit(x, ")"))[2]
}))

mobWtCellProxyBeta <- t(as.matrix(mob_se_wt) %*% mobWtCellProxyBeta)

mobWtCellProxyBeta <- mobWtCellProxyBeta/rowSums(mobWtCellProxyBeta)

dim(mobWtCellProxyBeta)

```

## raw counts

```{r}

# mob raw counts data
# mob_se_raw <- read.table("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_6_runs.raw.dge.csv", sep = ",", header = TRUE, row.names = 1)

# mob_se_wt_raw <- as.sparse(mob_se_raw[,wt_cells])

# mob_se_wt_raw_obj <- CreateSeuratObject(counts = mob_se_wt_raw, project = "mob scRNAseq raw")

# mob_se_wt_raw_obj[["perc.mito"]] <- meta.data.wt$percent.mito

# genes per cell > 200 (keep cells with more than 200 genes detected) as per paper methods
# turns out they are all above 200
# mob_se_wt_raw_obj_filt <- subset(mob_se_wt_raw_obj, subset = (nFeature_RNA >= 200))

# scale and log-normalize and regress on percent mito and number of molecules per cell
# to remove batch effects as per paper methods
# mob_se_wt_raw_obj_sct <- SCTransform(mob_se_wt_raw_obj_filt, vars.to.regress = c("perc.mito", "nCount_RNA"))

```

The SCT data is definitely log transformed but also likely other transformations as well. Probably not recommended to to log10^mat for example. Also, the SCT processed data I generated is different from that of the supplied processed data. They probably did other transformations too

```{r}

# mob_se_wt_obj@assays$RNA@counts


# some genes dropped and some counts for genes adjusted after SCT
# x <- mob_se_wt_raw_obj@assays$RNA@counts
# y <- mob_se_wt_raw_obj_sct@assays$SCT@counts
# plot(rowSums(x[rownames(y),]), rowSums(y))
# 
# # data scaled differently - looks like log transformed
# x <- mob_se_wt_raw_obj@assays$RNA@counts
# y <- mob_se_wt_raw_obj_sct@assays$SCT@data
# plot(rowSums(x[rownames(y),]), rowSums(y))
# 
# # same scaling trend for the processed scRNAseq data provided. also log but different from mine
# x <- mob_se_wt_raw_obj@assays$RNA@counts
# y <- mob_se_wt_obj@assays$RNA@counts
# plot(rowSums(x[rownames(y),]), rowSums(y))
# 
# # the two are close, but some differences in the overall scaling between the provided processed data 
# # and the data after processing myself. Not sure what.
# x <- mob_se_wt_obj@assays$RNA@counts
# y <- mob_se_wt_raw_obj_sct@assays$SCT@data
# plot(rowSums(x[rownames(y),]), rowSums(y))

```

save the raw data
```{r}

# save(mob_se_wt_raw_obj_sct, file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_raw_to_seurat_SCTassay.RData")

# save(mob_se_raw, file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_raw_sparseMatrix.RData")

```

Take the raw counts, select just the WT cells, then filter for poor genes and cells. Use the raw counts to build the proxy matrix for testing the correspondance between beta values

Also, as it happens, RCTD should be untransformed count level data anyways. SPOTlight takes SCTransformed data, which is the processed scRNAseq data

### load data

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_raw_sparseMatrix.RData")
# mob_se_raw

# mob_se_wt_raw <- as.sparse(mob_se_raw[,wt_cells])
# 18560 17709

# mob_se_wt_raw_obj <- CreateSeuratObject(counts = mob_se_wt_raw, project = "mob scRNAseq raw")
# An object of class Seurat 
# 18560 features across 17709 samples within 1 assay 
# Active assay: RNA (18560 features, 0 variable features)

# for comparison:
# mob_se_wt_obj
# An object of class Seurat 
# 18560 features across 17709 samples within 1 assay 
# Active assay: RNA (18560 features, 0 variable features)

```

```{r}

mobWtCellClusters <- meta.data.wt$ClusterName
names(mobWtCellClusters) <- meta.data.wt$X

mobWtCellProxyBetaRaw <- model.matrix(~ 0 + as.factor(mobWtCellClusters))

rownames(mobWtCellProxyBetaRaw) <- names(mobWtCellClusters)

# fix names
colnames(mobWtCellProxyBetaRaw) <- unlist(lapply(colnames(mobWtCellProxyBetaRaw), function(x) {
  unlist(strsplit(x, ")"))[2]
}))

mobWtCellProxyBetaRaw <- t(as.matrix(mob_se_wt_raw) %*% mobWtCellProxyBetaRaw)

mobWtCellProxyBetaRaw <- mobWtCellProxyBetaRaw/rowSums(mobWtCellProxyBetaRaw)

dim(mobWtCellProxyBetaRaw)

```

```{r}

plot(mobWtCellProxyBetaRaw, mobWtCellProxyBeta)

```


# =========================

# Figure 1

```{r}

fig_path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/raw_figures/"

```


# A - Merfish mPOA (-0.04)

Show the individual cells in the bregma colored by the major cell class and overlay the simulated spot boundaries

```{r}

breg <- simBregmas$`-0.04`

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank())
ggsave(filename = filename = "Fig1_A-1_breg04_mjrcts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "black") +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank())
ggsave(filename = "Fig1_A-2_breg04_mjrcts_patches.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

# for all neuronal cell types 
# 72 types now so legend and assigned colors gets messy
breg <- simBregmas_neuro$`-0.04`

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        legend.position = "none")
ggsave(filename = "Fig1_A-3_breg04_neurocts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

ggplot() +
  geom_point(data = breg$annotDf,
             aes(x = Centroid_X, y = Centroid_Y, color = Cell_class)) +
  scale_fill_manual(values = breg$classColors) +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "black") +
  theme(
        #panel.background = element_rect(fill = "white"),
        panel.grid = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        legend.position = "none")
ggsave(filename = "Fig1_A-4_breg04_neurocts_patches.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

# B - LDA results

Fit LDA models

```{r}

# fit models to a range of K's that include 9 (for 8-9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

# FN7 full animal

same corpus for `simFN7` and `simFN7_neuro` so can use either for model fitting

```{r}

pdf(file = paste0(fig_path, "Fig1_B-1_FN7_lda_fit.pdf"))
FN7_LDAs <- fitLDA(counts = simFN7$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

Could LDA be trained on one bregma and others used to measure perplexity? Cross-fold validation like procedure?

## k = 8 major cts (no ambiguous)

```{r}

FN7_K8 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs, opt = 8),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(8)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7), function(ix){
  
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  
  m <- FN7_K8$theta[spots,]
  p <- simFN7$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  
  set.seed(8)
  
  m <- simFN7$gtSpotTopics[spots,] # The ground truth proportions for 9 major cts
  p <- simFN7$cellCounts[spots, c("x", "y")] # the positions of sim spots for the bregma -0.04
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=randomcoloR::distinctColorPalette(ncol(m)),
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  ggsave(filename = paste0("Fig1_B-3_FN7_gt_8_mjrcts_", ix, ".pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
})

```

## theta correlation

FN7 full fitted with k=8 major cell types (ambiguous removed)

```{r}

thetaCorMtx <- getCorrMtx(m1 = FN7_K8$theta,
                           m2 = as.matrix(simFN7$gtSpotTopics),
                           type = "t")

pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## beta correlation

```{r}

betaCorMtx <- getCorrMtx(m1 = FN7_K8$beta,
                         m2 = as.matrix(simFN7$gtCtGenes), # gt made from cells in bregma
                         type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## k = 75 all neuronal cts

```{r}

FN7_K75 <- buildLDAobject(LDAmodel = optimalModel(FN7_LDAs, opt = "min"),
                      deepSplit = 2, # collapsed more to reduce number of clusters to 15
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(75)

```

### individual topics

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7_neuro), function(ix){
  
  spots <- rownames(simBregmasFN7_neuro[[ix]]$cellCounts)

  m <- FN7_K75$theta[spots,] # theta for the k=75 fitted LDA for bregma -0.04
  p <- simFN7_neuro$cellCounts[spots,c("x", "y")] # the positions of sim spots for the bregma -0.04
  
  # Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
  # in every spot. It might be worth removing topics from specific spots if they are below a certain proportion
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.01, # many more topics so make lines very thin
               showLegend = FALSE,
               plotTitle = paste("FN7 k=75 topics", ix))
  ggsave(filename = paste0("Fig1_B-2_FN7_k75_individual_topics_", ix, "_predict.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)
  
  
  set.seed(8)
  
  m <- simFN7_neuro$gtSpotTopics[spots,] # The ground truth proportions for the actual 72 of 75 present cts in bregma
  p <- simFN7_neuro$cellCounts[spots,c("x", "y")] # the positions of sim spots for the bregma -0.04
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=randomcoloR::distinctColorPalette(ncol(m)),
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.01,
               showLegend = FALSE,
               plotTitle = paste("Ground truth proportions 75 cts", ix))
  ggsave(filename = paste0("Fig1_B-3_FN7_gt_75neurocts_", ix, ".pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)

})

```

Because so many topics, collapse the individual topics into topic clusters to better visualize and assess

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(ncol(FN7_K75$thetaCombn))

```

### topic clusters

```{r}

lapply(names(simBregmasFN7_neuro), function(ix){
  
  spots <- rownames(simBregmasFN7_neuro[[ix]]$cellCounts)

  m <- FN7_K75$thetaCombn[spots,] # theta of the combined topic clusters for the k=75 fitted LDA for bregma -0.04
  p <- simFN7_neuro$cellCounts[spots,c("x", "y")] # the positions of sim spots for the bregma -0.04
  
  # Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
  # in every spot. It might be worth removing topics from specific spots if they are below a certain proportion
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.01, # many more topics so make lines very thin
               showLegend = FALSE,
               plotTitle = paste("FN7 k=75 topic-clusters", ix))
  ggsave(filename = paste0("Fig1_B-2_breg04_k75_clusters_", ix, "_predict.pdf"),
         device = "pdf",
         path = fig_path,
         scale = 1.5,
         width = 5,
         height = 4,
         units = c("in"),
         dpi = 600)

})

```

Lets visualize each topic cluster separately but also observe the proportions of the individual topics that make up each cluster. For example, a topic cluster clearly captures the ependymal cells, but there is no single individual topic that captures this. Instead, the LDA appears to capture additional transcriptionally distinct subtypes of the ependymal cells.

```{r}

lapply(names(simBregmasFN7_neuro), function(ix){
  
  spots <- rownames(simBregmasFN7_neuro[[ix]]$cellCounts)

  m <- FN7_K75$theta[spots,] # theta for the k=75 fitted LDA for bregma -0.04
  p <- simFN7_neuro$cellCounts[spots,c("x", "y")] # the positions of sim spots for the bregma -0.04
  
  vizTopicClusters(theta = m,
                   pos = p,
                   clusters = FN7_K75$cols, # factor for the 75 topics where the levels are the color of assigned cluster
                   sharedCol = FALSE, # so that each topic in a cluster is colored as a shade of the cluster color
                   groups = NA,
                   group_cols = NA,
                   r = 40,
                   lwd = 0.5,
                   showLegend = TRUE,
                   plotTitle = ix)
})

```

Break down even more but just looking at specific individual clusters

```{r}

# m <- FN7_K75$theta[,c(22,23,32,41,46,60)] # theta for the k=9 fitted LDA for bregma -0.04
# p <- simFN7_neuro$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04
# 
# cc <- as.factor(rainbow(ncol(m)))
# names(cc) <- colnames(m)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc,
#                  sharedCol = TRUE,
#                  groups = NA,
#                  group_cols = NA,
#                  r = 40,
#                  lwd = 0.5,
#                  showLegend = TRUE,
#                  plotTitle = NA)

```

## theta correlation

FN7 full fitted with k=8 major cell types (ambiguous removed)

```{r}

thetaCorMtx <- getCorrMtx(m1 = FN7_K75$theta,
                           m2 = as.matrix(simFN7_neuro$gtSpotTopics),
                           type = "t")

pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k75_neuro_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k75_neuro_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

```{r}

betaCorMtx <- getCorrMtx(m1 = FN7_K75$beta,
                         m2 = as.matrix(simFN7_neuro$gtCtGenes), # gt made from cells in bregma
                         type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k75_neuro_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k75_neuro_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

# ** C - Example ependymal

## FN7

# --------------------------------------
# -0.04

Recall that `simBregmas$`-0.04`$sim` and `simBregmas_neuro$`-0.04`$sim` have the same corpus, but the assigned ground truths constructed in "buildBregmaCorpus" differ because one used the 9 major cts and the other used major plus extended neuros.

So can use either "simBregmas" or "simBregmas_neuro" input corpuses to fit.

```{r}

start_time <- Sys.time()

pdf(file = paste0(fig_path, "Fig1_B-1_breg04_mjrcts_lda_fit.pdf"))
bregma04_LDAs <- fitLDA(counts = simBregmas$`-0.04`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

Get beta, theta matrices and clusters of topics for model assessment and visualization

## k = 9 major cts

```{r}

bregma04_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(9)

```

```{r}

m <- bregma04_k9$theta # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.5,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_B-2_breg04_k9_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


set.seed(1)

m <- simBregmas$`-0.04`$gtSpotTopics # The ground truth proportions for 9 major cts
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=randomcoloR::distinctColorPalette(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.5,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_B-3_breg04_gt_mjrcts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Individual topics visualized separately

```{r}

m <- bregma04_k9$theta # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

cc <- as.factor(colspace)
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## theta correlation

bregma -0.04 fitted with k=9 vs gt 9 major cts

```{r}

thetaCor_breg04_k9_vs_gt <- getCorrMtx(m1 = bregma04_k9$theta,
                                       m2 = as.matrix(simBregmas$`-0.04`$gtSpotTopics),
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_B-4_breg04_k9_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCor_breg04_k9_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-4_breg04_k9_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_breg04_k9_vs_gt)
gplots::heatmap.2(x = thetaCor_breg04_k9_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## beta correlation

bregma -0.04 fitted with k=9 vs gt 9 major cts

```{r}

betaCor_breg04_k9_vs_gt <- getCorrMtx(m1 = bregma04_k9$beta,
                                       m2 = as.matrix(simBregmas$`-0.04`$gtCtGenes), # gt made from cells in bregma
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_breg04_k9_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_breg04_k9_vs_gt)
gplots::heatmap.2(x = betaCor_breg04_k9_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

Compare with global gt for all of the cells

```{r}

betaCor_breg04_k9_vs_globalgt <- getCorrMtx(m1 = bregma04_k9$beta,
                                       m2 = as.matrix(gtCtGenes), # the global beta from all bregma cells in `bregmaCellsGexp` (36329)
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_globalGt_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_breg04_k9_vs_globalgt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-5_breg04_k9_mjrcts_globalGt_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_breg04_k9_vs_globalgt)
gplots::heatmap.2(x = betaCor_breg04_k9_vs_globalgt[pairs$rowix, pairs$colsix],
                  Rowv = NA,
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
dev.off()

```

## k = 75 all neuronal cts

```{r}

bregma04_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = "min"),
                      deepSplit = 2, # collapsed more to reduce number of clusters to 17
                      colorScheme = "rainbow")

```

## viz predictions

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(75)

```

### individual topics

```{r}

m <- bregma04_k75$theta # theta for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

# Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
# in every spot. It might be worth removing topics from specific spots if they are below a certain proportion

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01, # many more topics so make lines very thin
             showLegend = FALSE,
             plotTitle = "bregma -0.04 k=75 topics")
ggsave(filename = "Fig1_B-2_breg04_k75_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


set.seed(1)

m <- simBregmas_neuro$`-0.04`$gtSpotTopics # The ground truth proportions for the actual 72 of 75 present cts in bregma
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=randomcoloR::distinctColorPalette(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01,
             showLegend = FALSE,
             plotTitle = "Ground truth proportions 75 cts")
ggsave(filename = "Fig1_B-3_breg04_gt_75neurocts.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Because so many topics, collapse the individual topics into topic clusters to better visualize and assess

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(ncol(bregma04_k75$thetaCombn))

```

### topic clusters

```{r}

m <- bregma04_k75$thetaCombn # theta of the combined topic clusters for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

# Note: all topics are plotted regardless of proportion. So even topics at very residuals small amounts are plotted
# in every spot. It might be worth removing topics from specific spots if they are below a certain proportion

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=colspace,
             groups = NA,
             group_cols = NA,
             r = 40,
             lwd = 0.01, # many more topics so make lines very thin
             showLegend = FALSE,
             plotTitle = "bregma -0.04 k=75 topic-clusters")
ggsave(filename = "Fig1_B-2_breg04_k75_clusters_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Lets visualize each topic cluster separately but also observe the proportions of the individual topics that make up each cluster. For example, a topic cluster clearly captures the ependymal cells, but there is no single individual topic that captures this. Instead, the LDA appears to capture additional transcriptionally distinct subtypes of the ependymal cells.

```{r}

m <- bregma04_k75$theta # theta for the k=75 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = bregma04_k75$cols, # factor for the 75 topics where the levels are the color of assigned cluster
                 sharedCol = FALSE, # so that each topic in a cluster is colored as a shade of the cluster color
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

Break down even more but just looking at specific individual clusters

```{r}

m <- bregma04_k75$theta[,c(22,23,32,41,46,60)] # theta for the k=9 fitted LDA for bregma -0.04
p <- simBregmas_neuro$`-0.04`$cellCounts[,c("x", "y")] # the positions of sim spots for the bregma -0.04

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 40,
                 lwd = 0.5,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# C - Example ependymal

# bregma -0.04 k=9 mjr cts

```{r}

# Topic 7 highly correlated with ependymal cells
topic7ependymalTopGenes <- head(bregma04_k9$beta[7,order(bregma04_k9$beta[7,], decreasing = TRUE)], n=10)
topic7ependymalTopGenes

```

Visualize genes:

```{r}

# input df for `vizGeneCounts`
df <- bregmaCellsGexp[,labels(topic7ependymalTopGenes)]
df <- merge(as.data.frame(spatial_position_and_class[,c("Centroid_X", "Centroid_Y")]), as.data.frame(df), by=0)
colnames(df)[which(names(df) == "Centroid_X")] <- "x"
colnames(df)[which(names(df) == "Centroid_Y")] <- "y"
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Mlc1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Mlc1",
              showLegend = TRUE)
ggsave(filename = "Fig1_C-1_breg04_k9_ependy_gexp_Mlc1.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Cd24a",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cd24a",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Aqp4",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Aqp4",
              showLegend = TRUE)

```

# bregma -0.04 k=75 neuro cts

Above, it was observed that the ependymal cells are captured by the topic cluster of the following topics:
F0FF00 : 22 23 32 41 46 60

When the topics are visualized separately, the individual topics appear to capture additional transcriptionally distinct subpopulations of the ependymal cells.

Let's visualize the top genes for the cluster in general, and also for the individual topics

```{r}

bregma04_k75$clusters

```

Note that topics "22 23 32 41 46 60" are part of cluster `4`

```{r}

breg04_k75_ependymalTopGenes_tclust <- head(bregma04_k75$betaCombn[4,order(bregma04_k75$betaCombn[4,], decreasing = TRUE)], n=10)
breg04_k75_ependymalTopGenes_tclust

```

The genes for the overall cluster are very similar ro what was found with k=9. So representative of ependymal cells overall.

But what about the individual topics in the cluster?

```{r}

print("Topic 22")
head(bregma04_k75$beta[22,order(bregma04_k75$beta[22,], decreasing = TRUE)], n=10)

print("Topic 23")
head(bregma04_k75$beta[23,order(bregma04_k75$beta[23,], decreasing = TRUE)], n=10)

print("Topic 32")
head(bregma04_k75$beta[32,order(bregma04_k75$beta[32,], decreasing = TRUE)], n=10)

print("Topic 41")
head(bregma04_k75$beta[41,order(bregma04_k75$beta[41,], decreasing = TRUE)], n=10)

print("Topic 46")
head(bregma04_k75$beta[46,order(bregma04_k75$beta[46,], decreasing = TRUE)], n=10)

print("Topic 60")
head(bregma04_k75$beta[60,order(bregma04_k75$beta[60,], decreasing = TRUE)], n=10)


```

Again, Mlc1 is a top gene for all of them. Cd24a also top marker.  

```{r}

genes <- c("Mlc1", "Cd24a", "Aqp4", "Cd24a", "Cxcl14", "Sema4d", "Ndrg1")

# input df for `vizGeneCounts`
df <- bregmaCellsGexp[,genes]
df <- merge(as.data.frame(spatial_position_and_class[,c("Centroid_X", "Centroid_Y")]), as.data.frame(df), by=0)
colnames(df)[which(names(df) == "Centroid_X")] <- "x"
colnames(df)[which(names(df) == "Centroid_Y")] <- "y"
rownames(df) <- df$Row.names

```

Topic 32 appears to be very specific at the bottom of the ependymal layer. It is the strongest expression wrt Mlc1 compared to the other topics and also has "Cd24a", "Sema4d" and "Ndrg1"

It's possible that this topic is picking up more of an "artifact" for bregma -0.04 specifically as Mcl1 is particularly high in this region compared to other bregma slices. However, the possibility remains that this is a distinct subpopulation for this particular slice in space.

```{r}

vizGeneCounts(df = df,
              gene = "Mlc1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Mlc1",
              showLegend = TRUE)
# ggsave(filename = "Fig1_C-2_breg04_k75_ependy_gexp_Slco1a4.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

vizGeneCounts(df = df,
              gene = "Cd24a",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cd24a",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Sema4d",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Sema4d",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Ndrg1",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Ndrg1",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Cxcl14",
              groups = NA,
              group_cols = NA,
              size = 0.5, stroke = 0.01,
              plotTitle = "Cxcl14",
              showLegend = TRUE)

```

# --------------------------------------
# D - MOB 

Original Txn clusters

```{r, mob-qc, fig.width=8, fig.height=3}

# Remove poor datasets and genes
mob_counts <- MERINGUE::cleanCounts(counts = mOB$counts, # from mOB data set
                      min.reads = 100, 
                      min.lib.size = 100, 
                      plot=TRUE,
                      verbose=TRUE)
mob_pos <- mOB$pos[colnames(mob_counts),]

# CPM normalize
mob_cpm <- MERINGUE::normalizeCounts(counts = mob_counts, 
                       log=FALSE,
                       verbose=TRUE)

```

```{r}

# Dimensionality reduction by PCA on log10 CPM expression values
pcs.info <- prcomp(t(log10(as.matrix(mob_cpm)+1)), center=TRUE)
nPcs <- 5
pcs <- pcs.info$x[,1:nPcs]

# 2D embedding by tSNE
emb <- Rtsne::Rtsne(pcs,
             is_distance=FALSE,
             perplexity=30,
             num_threads=1,
             verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)

# Graph-based cluster detection
k <- 30
com <- getClusters(pcs, k, weight=TRUE)

# Manually annotate identified clusters with cell-types
mob_annot <- as.character(com); names(mob_annot) <- names(com)
mob_annot[com==4] <- '1: Granule Cell Layer'
mob_annot[com==1] <- '2: Mitral Cell Layer'
mob_annot[com==3] <- '3: Outer Plexiform Layer'
mob_annot[com==2] <- '4: Glomerular Layer'
mob_annot[com==5] <- '5: Olfactory Nerve Layer'
mob_annot <- as.factor(mob_annot)

# Plot
par(mfrow=c(2,2), mar=rep(1,4))
plotEmbedding(emb, groups=mob_annot, 
              show.legend=TRUE, xlab=NA, ylab=NA,
              verbose=FALSE)
plotEmbedding(mob_pos, groups=mob_annot, 
              cex=1, xlab=NA, ylab=NA,
              verbose=FALSE)

```

# E - LDA results

Fit LDA models

```{r}

# fit models to a range of K's that include 5 (5 original txn clusters) and
# 37 and 38 (for the cts in the scRNAseq refs; 38 originally but SL doesn't find and Meis2 so dropped)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, 37, 38, seq(from = 15, to = 75, by = 10))

```

Recall that `simBregmas$`-0.04`$sim` and `simBregmas_neuro$`-0.04`$sim` have the same corpus, but the assigned ground truths constructed in "buildBregmaCorpus" differ because one used the 9 major cts and the other used major plus extended neuros.

So can use either "simBregmas" or "simBregmas_neuro" input corpuses to fit.

# mob (meringue data)

```{r}

pdf(file = paste0(fig_path, "Fig1_D-1_mob_lda_fit.pdf"))
mob_LDAs <- fitLDA(counts = mobCorpus$mob$slm,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

## k = 15 kOpt2 kneed

```{r}

mob_k15 <- buildLDAobject(LDAmodel = optimalModel(mob_LDAs, opt = "kneed"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(15)

```

```{r}

m <- mob_k15$theta # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

### topic clusters

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(6)

```

```{r}

m <- mob_k15$thetaCombn # theta for 6 topic clusters of the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_E-2_mob_k15_clusters_predict.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- mob_k15$theta
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

```{r}

m <- mob_k15$thetaCombn
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k15$clustCols,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

Check out the individual topics that make up each cluster

```{r}

m <- mob_k15$theta
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k15$cols,
                 sharedCol = FALSE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## theta correlation

See which topics correlate with the 5 cell layer annotations based on txn clustering

```{r}

# proxy theta for the txn clusters
mobProxyTheta <- model.matrix(~ 0 + mob_annot)
rownames(mobProxyTheta) <- names(mob_annot)

# fix names
colnames(mobProxyTheta) <- unlist(lapply(colnames(mobProxyTheta), function(x) {
  unlist(strsplit(x, ": "))[2]
}))

mobProxyTheta <- as.data.frame.matrix(mobProxyTheta)

```

```{r}

thetaCor_mob_k15_vs_gt <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k15$theta,
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCor_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_mob_k15_vs_gt)
gplots::heatmap.2(x = thetaCor_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
dev.off()

```

Topic cluster theta correlations

```{r}

thetaCor_combined_mob_k15_vs_gt <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k15$thetaCombn,
                                       type = "t")

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor.pdf"))
gplots::heatmap.2(x = thetaCor_combined_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCor_combined_mob_k15_vs_gt)
gplots::heatmap.2(x = thetaCor_combined_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
dev.off()

```

## beta correlation

Correlate to a mob scRNAseq reference to see if certain topics also correlate with known cell types.

```{r}

betaCor_mob_k15_vs_gt <- getCorrMtx(m1 = mob_k15$beta,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor.pdf"))
gplots::heatmap.2(x = betaCor_mob_k15_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_mob_k15_vs_gt)
gplots::heatmap.2(x = betaCor_mob_k15_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

```

```{r}

betaCor_mob_k15_combined_vs_gt <- getCorrMtx(m1 = mob_k15$betaCombn,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined.pdf"))
gplots::heatmap.2(x = betaCor_mob_k15_combined_vs_gt,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCor_mob_k15_combined_vs_gt)
gplots::heatmap.2(x = betaCor_mob_k15_combined_vs_gt[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
dev.off()

```

# F - cell layer example

Can start to annotate topics based on where they are spatially and how they correlate with known cell types. Viz marker genes and also orthogonal validation with ISH data.

Topic 4 beta had one of the highest gene expression correlations with the mobProxyBeta from the scRNAseq data set and correlated with the "Mes1" cluster. Topic 4 also was predicted to be correlated at least moderately with the Glomerular layer

```{r}

sortedGenes <- order(mob_k15$beta[4,], decreasing = TRUE)
mob_k15$beta[4,sortedGenes][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,labels(mob_k15$beta[4,sortedGenes][1:10])]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Ptgds",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Ptgds",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Ptgds.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Apod",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Apod",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Apod.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Fabp7",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Fabp7",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-1_mob_k15_cpm_gexp_Fabp7.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Igf2",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Igf2",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Dcn",
              groups = NA,
              group_cols = NA,
              size = 7, stroke = 0.01,
              plotTitle = "Dcn",
              showLegend = TRUE)

```

Next, consider the Granule cell layer (central txn cell layer). Topic clusters 1 and 6 actually seem to cover this area. And within these, additional individual topics.

```{r}

m <- mob_k15$thetaCombn # theta for 6 topic clusters of the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = as.character(mobProxyTheta$`Granule Cell Layer`),
             group_cols = c("0" = "white", "1" = "black"),
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.8,
             showLegend = TRUE,
             plotTitle = NA)
ggsave(filename = "Fig1_F-2_mob_k15_clusters_granule.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

The topic clusters can be broken down into individual topics 3, 5 (cluster 6) and 9, 10, 12 (cluster 1) are present 

```{r}

print("topic cluster 6")
mob_k15$betaCombn[6,order(mob_k15$betaCombn[6,], decreasing = TRUE)][1:10]

print("topic cluster 1")
mob_k15$betaCombn[1,order(mob_k15$betaCombn[1,], decreasing = TRUE)][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,c("Tubb2b", "Atp1b1")]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Tubb2b",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Tubb2b",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_clust6_granule_Tubb2b.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Atp1b1",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Atp1b1",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_clust1_granule_Atp1b1.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Top gene of each topic seems to capture even more "layers" of the granule cell layer

Even within topic cluster 6, the individual topics break down even more:

```{r}

print("topic cluster 6, topic 3")
mob_k15$beta[3,order(mob_k15$beta[3,], decreasing = TRUE)][1:10]

print("topic cluster 6, topic 5")
mob_k15$beta[5,order(mob_k15$beta[5,], decreasing = TRUE)][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,c("Nrgn", "Penk", "Nrep", "Tubb2b")]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Nrgn",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Nrgn",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic3_granule_Nrgn.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Penk",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Penk",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic3_granule_Penk.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Nrep",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Nrep",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic5_granule_Nrep.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

vizGeneCounts(df = df,
              gene = "Tubb2b",
              groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              group_cols = c("0" = "white", "1" = "white"),
              size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Tubb2b",
              showLegend = TRUE)
ggsave(filename = "Fig1_F-3_mob_k15_topic5_granule_Tubb2b.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

Nrep and Tubb2b particularly correspond to that very central region.

Any cell types that may be expressing these genes?

# =========================

# Fig 2: MERFISH Full Animal FN7

# RMSE

# build seurat reference

Both Spotlight (SL) and RCTD require a Seurat object of gene counts for individual cells and meta data assigning these cells to clusters.

Combine cells from all of the bregmas to use as the reference. Have one reference with the 9 major cell classes and a second one that expands the cell types to the 75 types that include the neuronal types.

```{r}

# have already built this above. In the meta.data there is a column for major cell classes and another for all 75

bregmaFN7FullSeur

```

# SL 8 Major Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur) <- bregmaFN7FullSeur@meta.data$Major_class

levels(bregmaFN7FullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

# FindAllMarkers will find markers differentially expressed in each identity group by comparing
# it to all of the others - you don't have to manually define anything.
# Note that markers may bleed over between closely-related groups - they are not forced to be specific to only one group

bregmaFN7FullSeur_markers8cts <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Finally, lets train the model 

Note here that the training only keeps genes that are also in the spatial data that will be deconvolved. So it is important that the ST data used here will be what is deconvolved later. Otherwise during one of the NNMF steps during deconvolution, the *entire environment will actually crash!* Unless if one carefully filters for shared genes beforehand if a different ST object is used with the same trained SL model. Otherwise retrain for each new ST dataset to deconvolve.

However, here, at least for the MERFISH data, the same 125 genes are used for all simulated ST datasets so this should not be an issue. (For mOB ST sets, this will be)

```{r}

set.seed(888)

SL_bregmaFN7FullSeur8cts_fit <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur,
  counts_spatial = t(as.matrix(simFN7$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFN7FullSeur_markers8cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

## Collect RMSE

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
SL_bregmaFN7FullSeur8cts_spotsRMSE <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

length(SL_bregmaFN7FullSeur8cts_spotsRMSE)
head(SL_bregmaFN7FullSeur8cts_spotsRMSE)

```

Unit of RMSE same as the dependent variable. SO it is same as proportion/sd
So a "good range" also depends on what you are looking at. A RMSE of 1000 may be good or bad depending on the units...

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting a ct across the spots
SL_bregmaFN7FullSeur8cts_ctRMSE <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  
  # in order to compare cts to cts, normalize the rmse
  # because the scale of the values affects the rmse
  # bigger values return larger rmse than smaller values
  # this is why the rare neuronal cts also return lower
  # rmse that looking that the higher proportion cts across spots
  # nrmse_func(obs = truth_theta[,ct], pred = predict_theta[,ct], type = "mean")
  
}))
colnames(SL_bregmaFN7FullSeur8cts_ctRMSE) <- colnames(truth_theta)
SL_bregmaFN7FullSeur8cts_ctRMSE

```

# SL 75 Neuronal Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur) <- bregmaFN7FullSeur@meta.data$All_classes

levels(bregmaFN7FullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFN7FullSeur_markers75neurocts <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Some types do not have assigned marker genes. I wonder how this will affect the subsequent model training

Now fit:

```{r}

set.seed(888)

SL_bregmaFN7FullSeur75neurocts_fit <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur,
  counts_spatial = t(as.matrix(simFN7_neuro$sim)), # actually same sim as "simFN7". Just that the gt refs differ
  clust_vr = "All_classes", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFN7FullSeur_markers75neurocts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

## Collect RMSE

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- SL_bregmaFN7FullSeur75neurocts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur75neurocts_fit[[2]])-1]
# fix column names so they match the gt
colnames(breg_theta) <- sub("\\.", "-", colnames(breg_theta))
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
SL_bregmaFN7FullSeur75neurocts_spotsRMSE <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

length(SL_bregmaFN7FullSeur75neurocts_spotsRMSE)
head(SL_bregmaFN7FullSeur75neurocts_spotsRMSE)

```

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- SL_bregmaFN7FullSeur75neurocts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur75neurocts_fit[[2]])-1]
# fix column names so they match the gt
colnames(breg_theta) <- sub("\\.", "-", colnames(breg_theta))
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting a ct across the spots
SL_bregmaFN7FullSeur75neurocts_ctRMSE <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(SL_bregmaFN7FullSeur75neurocts_ctRMSE) <- colnames(truth_theta)
SL_bregmaFN7FullSeur75neurocts_ctRMSE

```

# RCTD 8 Major Cts Train

The input reference and data to be deconvolved need to be placed into directories, labeled a special way, and have specific columns in the files. 

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_ref/"

ref <- bregmaFN7FullSeur

meta_ref <- ref@meta.data[,c("Major_class", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/FN7/"
d <- simFN7

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

```

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

FN7

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7 <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_fit <- RCTD::run.RCTD(RCTD_FN7, doublet_mode = TRUE)

RCTD_FN7_results <- RCTD_FN7_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_results_norm <-  sweep(RCTD_FN7_results$weights, 1, rowSums(RCTD_FN7_results$weights), '/')

```

## Collect RMSE

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- RCTD_FN7_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
RCTD_bregmaFN7FullSeur8cts_spotsRMSE <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
# because missing spots for some reason, fill in by adding NAs
if (length(RCTD_bregmaFN7FullSeur8cts_spotsRMSE) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(RCTD_bregmaFN7FullSeur8cts_spotsRMSE)
  RCTD_bregmaFN7FullSeur8cts_spotsRMSE <- c(RCTD_bregmaFN7FullSeur8cts_spotsRMSE, rep(NA, toFill))
}
length(RCTD_bregmaFN7FullSeur8cts_spotsRMSE)
head(RCTD_bregmaFN7FullSeur8cts_spotsRMSE)


```

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- RCTD_FN7_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse fpr predicting a ct across the spots
RCTD_bregmaFN7FullSeur8cts_ctRMSE <- do.call(cbind, lapply(colnames(breg_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(RCTD_bregmaFN7FullSeur8cts_ctRMSE) <- colnames(breg_theta)
RCTD_bregmaFN7FullSeur8cts_ctRMSE

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

# RCTD 75 Neuronal Cts Train

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_neuro_ref/"

ref <- bregmaFN7FullSeur

meta_ref <- ref@meta.data[,c("All_classes", "nCount_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$All_classes),
                         Name = unique(ref@meta.data$All_classes)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

same as 8cts

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_neuro_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

FN7

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7_neuro <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_neuro_fit <- RCTD::run.RCTD(RCTD_FN7_neuro, doublet_mode = TRUE)

RCTD_FN7_neuro_results <- RCTD_FN7_neuro_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_neuro_results_norm <-  sweep(RCTD_FN7_neuro_results$weights, 1, rowSums(RCTD_FN7_neuro_results$weights), '/')

```

## Collect RMSE

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- RCTD_FN7_neuro_results_norm
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
# because missing spots for some reason, fill in by adding NAs
if (length(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE)
  RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE <- c(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE, rep(NA, toFill))
}
length(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE)
head(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE)


```

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- RCTD_FN7_neuro_results_norm
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse fpr predicting a ct across the spots
RCTD_bregmaFN7FullSeur75neurocts_ctRMSE <- do.call(cbind, lapply(colnames(breg_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(RCTD_bregmaFN7FullSeur75neurocts_ctRMSE) <- colnames(breg_theta)
RCTD_bregmaFN7FullSeur75neurocts_ctRMSE

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

# LDA 8 Major Cts Train

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- FN7_K8$theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                    m2 = breg_gt_theta,
                                    type = "t"))
# reorder the predicted topics to match their paired cell type
# rows are spots and columns are topics
# `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
predict_theta <- breg_theta[,theta_pairs$rowix]
# the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
truth_theta <- breg_gt_theta[,theta_pairs$colsix]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
LDA_bregmaFN7FullSeur8cts_spotsRMSE <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
length(LDA_bregmaFN7FullSeur8cts_spotsRMSE)
head(LDA_bregmaFN7FullSeur8cts_spotsRMSE)

```

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- FN7_K8$theta
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_gt_theta,
                                    m2 = breg_theta,
                                    type = "t"))

# for a given bregma, pair up predicted topics with cell types present
predict_theta <- breg_theta[,theta_pairs$colsix]
truth_theta <- breg_gt_theta[,theta_pairs$rowix]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting each ct across spots
LDA_bregmaFN7FullSeur8cts_ctRMSE <- do.call(cbind, lapply(seq(theta_pairs$rowix), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(LDA_bregmaFN7FullSeur8cts_ctRMSE) <- colnames(truth_theta)
LDA_bregmaFN7FullSeur8cts_ctRMSE

```

# LDA 75 Neuronal Cts Train

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

breg_theta <- FN7_K75$theta
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                    m2 = breg_gt_theta,
                                    type = "t"))
# reorder the predicted topics to match their paired cell type
# rows are spots and columns are topics
# `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
predict_theta <- breg_theta[,theta_pairs$rowix]
# the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
truth_theta <- breg_gt_theta[,theta_pairs$colsix]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
LDA_bregmaFN7FullSeur75neurocts_spotsRMSE <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
length(LDA_bregmaFN7FullSeur75neurocts_spotsRMSE)
head(LDA_bregmaFN7FullSeur75neurocts_spotsRMSE)

```

### ------------------
### ** scale dependence **

WARNING: RMSE depends on the actual values

the rmse scales with the values themselves...

so maybe for comparing each spot with all cts, this is ok because each value in the vector for a spot is wrt a different cell type and its like taking the "average". Although I feel that certain cts would then be weigthing the overall RMSE differently. Like the cts at higher abundances would contribute more to the RMSE. And relative larger deviations for the low abundance cts would actually have less of an effect on the overall RMSE.

When comparing a RMSE across all spots for a given CT, you can compare each method this way wrt a singe ct. But you can't compare ct to ct for each method. THis is why low abundance cts are lower RMSEs.

Should find a way to normalize all the actual and predicted proportions across cell types.

```{r}


# scale-dependent:
x_scale <- truth_theta
y_scale <- predict_theta
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)

x_scale <- 2*truth_theta
y_scale <- 2*predict_theta
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)

x_scale <- 0.5*truth_theta
y_scale <- 0.5*predict_theta
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)

# try seeing if scaling prevents this (here, just dividing by sd)
x_scale <- truth_theta
y_scale <- predict_theta
x_scale <- scale(x_scale, center = FALSE, scale = apply(x_scale, 2, sd, na.rm = TRUE))
y_scale <- scale(y_scale, center = FALSE, scale = apply(y_scale, 2, sd, na.rm = TRUE))
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)

x_scale <- 2*truth_theta
y_scale <- 2*predict_theta
x_scale <- scale(x_scale, center = FALSE, scale = apply(x_scale, 2, sd, na.rm = TRUE))
y_scale <- scale(y_scale, center = FALSE, scale = apply(y_scale, 2, sd, na.rm = TRUE))
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)

x_scale <- 0.5*truth_theta
y_scale <- 0.5*predict_theta
x_scale <- scale(x_scale, center = FALSE, scale = apply(x_scale, 2, sd, na.rm = TRUE))
y_scale <- scale(y_scale, center = FALSE, scale = apply(y_scale, 2, sd, na.rm = TRUE))
x <- x_scale[,"Ependymal"]
y <- y_scale[,23]
mltools::rmse(preds = y, actuals = x)


```

### ------------------


Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- FN7_K75$theta
breg_gt_theta <- as.matrix(simFN7_neuro$gtSpotTopics)

# get pairs of topics and ground truth cell types that correlate best
theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_gt_theta,
                                    m2 = breg_theta,
                                    type = "t"))

# for a given bregma, pair up predicted topics with cell types present
predict_theta <- breg_theta[,theta_pairs$colsix]
truth_theta <- breg_gt_theta[,theta_pairs$rowix]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting each ct across spots
LDA_bregmaFN7FullSeur75neurocts_ctRMSE <- do.call(cbind, lapply(seq(theta_pairs$rowix), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(LDA_bregmaFN7FullSeur75neurocts_ctRMSE) <- colnames(truth_theta)
LDA_bregmaFN7FullSeur75neurocts_ctRMSE

```

# A - RMSE Compare

## 8 major cts

```{r}

rmse_FN7_allCts_8cts <- data.frame(SPOTlight = as.vector(SL_bregmaFN7FullSeur8cts_spotsRMSE),
                                    RCTD = as.vector(RCTD_bregmaFN7FullSeur8cts_spotsRMSE),
                                    STdeconvolve = as.vector(LDA_bregmaFN7FullSeur8cts_spotsRMSE))

my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STdeconvolve"), c("RCTD", "STdeconvolve") )

ggplot(data = reshape2::melt(rmse_FN7_allCts_8cts),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot(outlier.shape=NA) +
  geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
  # stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
  #                    label.y = c(0.50, 0.535, 0.582)) +
  labs(title = "MERFISH 8 major cell type predictions across FN7 spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
    theme_classic()
# ggsave(filename = "Fig2_A-1_RMSE_9cts_allBregma_spots.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)


```

```{r}

# spot IDs
FN7_spotIDs <- unlist(lapply(keys(FN7), function(ix){
  # table to df
  rownames(FN7[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_cellTypeTable <- lapply(keys(FN7), function(ix){
  # table to df
  as.data.frame.matrix(FN7[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_cellTypeTable <- data.table::rbindlist(FN7_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_cellTypeTable[is.na(FN7_cellTypeTable)] <- 0

# spot IDs as row names
FN7_cellTypeTable <- as.matrix(FN7_cellTypeTable)
rownames(FN7_cellTypeTable) <- FN7_spotIDs

```

```{r}

l_eachCt <- SL_bregmaFN7FullSeur8cts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

SL_8cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- RCTD_bregmaFN7FullSeur8cts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

RCTD_8cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- LDA_bregmaFN7FullSeur8cts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("LDA", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

LDA_8cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

# now combine them all:
FN7_k8_eachCT_summary <- do.call("rbind", list(SL_8cts_rmse_df,
                                           RCTD_8cts_rmse_df,
                                           LDA_8cts_rmse_df))

```

```{r}

ggplot(data = FN7_k8_eachCT_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 8 cell type predictions across FN7",
       x = "Method", y = "RMSE")
# ggsave(filename = "Fig2_A-3_RMSE_9cts_allBregmas_eachCt.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

```{r}

ggplot(data = FN7_k8_eachCT_summary, aes(x = Proportion, y = RMSE, color = Method, shape = Cell.type)) +
  geom_point() +
  scale_shape_manual(values = seq(8))

ggplot(data = FN7_k8_eachCT_summary, aes(x = Max.spot.proportion, y = RMSE, color = Method, shape = Cell.type)) +
  geom_point() +
  scale_shape_manual(values = seq(8))

ggplot(data = FN7_k8_eachCT_summary, aes(x = Spot.proportion.std, y = RMSE, color = Method, shape = Cell.type)) +
  geom_point() +
  scale_shape_manual(values = seq(8))

```

Distributions of spot proportions for each cell type

```{r}

lapply(unique(FN7_k8_eachCT_summary$Cell.type), function(ct){
  hist(round(simFN7$gtSpotTopics[,ct], digits = 2), breaks = 100, main = ct, xlab = "spot proportion")
  
})

```

for each cell type, ignore spots that have proportion of 0

```{r}

lapply(unique(FN7_k8_eachCT_summary$Cell.type), function(ct){
  vals <- round(simFN7$gtSpotTopics[,ct], digits = 2)
  nonZero <- vals[which(vals > 0)]
  print(cat(ct, "non-zero:", length(nonZero), "out of", length(vals), "\n"))
  
  hist(nonZero, breaks = 100, main = ct, xlab = "spot proportion")
  
})

```

## 75 neuronal cts

```{r}

rmse_FN7_allCts_75neurocts <- data.frame(SPOTlight = as.vector(SL_bregmaFN7FullSeur75neurocts_spotsRMSE),
                                    RCTD = as.vector(RCTD_bregmaFN7FullSeur75neurocts_spotsRMSE),
                                    STdeconvolve = as.vector(LDA_bregmaFN7FullSeur75neurocts_spotsRMSE))

my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STdeconvolve"), c("RCTD", "STdeconvolve") )

ggplot(data = reshape2::melt(rmse_FN7_allCts_75neurocts),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot(outlier.shape=NA) +
  geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
  # stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
  #                    label.y = c(0.2, 0.22, 0.24)) +
  labs(title = "MERFISH 75 neuro cell type predictions across FN7 spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
    theme_classic()
# ggsave(filename = "Fig2_A-1_RMSE_9cts_allBregma_spots.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)


```

```{r}

# spot IDs
FN7_neuro_spotIDs <- unlist(lapply(keys(FN7_neuro), function(ix){
  # table to df
  rownames(FN7_neuro[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_neuro_cellTypeTable <- lapply(keys(FN7_neuro), function(ix){
  # table to df
  as.data.frame.matrix(FN7_neuro[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_neuro_cellTypeTable <- data.table::rbindlist(FN7_neuro_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_neuro_cellTypeTable[is.na(FN7_neuro_cellTypeTable)] <- 0

# spot IDs as row names
FN7_neuro_cellTypeTable <- as.matrix(FN7_neuro_cellTypeTable)
rownames(FN7_neuro_cellTypeTable) <- FN7_neuro_spotIDs

```

```{r}

l_eachCt <- SL_bregmaFN7FullSeur75neurocts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight", length(cts))

# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

SL_75cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- RCTD_bregmaFN7FullSeur75neurocts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD", length(cts))

# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

RCTD_75cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- LDA_bregmaFN7FullSeur75neurocts_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("LDA", length(cts))

# total ct proportions
tot_p <- colSums(FN7_neuro_cellTypeTable)/sum(colSums(FN7_neuro_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# max proportion in a spot
spot_max <- apply(simFN7_neuro$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7_neuro$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7_neuro$gtSpotTopics, 2, sd)[cts]

LDA_75cts_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

# now combine them all:
FN7_k75_eachCT_summary <- do.call("rbind", list(SL_75cts_rmse_df,
                                           RCTD_75cts_rmse_df,
                                           LDA_75cts_rmse_df))

```

```{r, fig.height=12, fig.width=8}

ggplot(data = FN7_k75_eachCT_summary, aes(x = Method, y = RMSE)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type, ncol = 6) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 75 cell type predictions across FN7",
       x = "Method", y = "RMSE")
# ggsave(filename = "Fig2_A-3_RMSE_9cts_allBregmas_eachCt.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

```{r, fig.height=6, fig.width=12}

ggplot(data = FN7_k75_eachCT_summary, aes(x = Proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point() +
  theme_classic()

ggplot(data = FN7_k75_eachCT_summary, aes(x = Max.spot.proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point() +
  theme_classic()

ggplot(data = FN7_k75_eachCT_summary, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point() +
  theme_classic()

```

Distributions of spot proportions for each cell type

```{r}

lapply(unique(FN7_k75_eachCT_summary$Cell.type), function(ct){
  hist(round(simFN7_neuro$gtSpotTopics[,ct], digits = 2), breaks = 100, main = ct, xlab = "spot proportion")
  
})

```

for each cell type, ignore spots that have proportion of 0

```{r}

lapply(unique(FN7_k75_eachCT_summary$Cell.type), function(ct){
  vals <- round(simFN7_neuro$gtSpotTopics[,ct], digits = 2)
  nonZero <- vals[which(vals > 0)]
  print(cat(ct, "non-zero:", length(nonZero), "out of", length(vals), "\n"))
  
  hist(nonZero, breaks = 100, main = ct, xlab = "spot proportion")
  
})

```

# B - Correlations between GT

## theta 8 cts

### LDA

```{r}

thetaCorMtx <- getCorrMtx(m1 = FN7_K8$theta,
                           m2 = as.matrix(simFN7$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k8_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k8_thetaCor_paired_gt_cors, breaks = 10)
mean(lda_k8_thetaCor_paired_gt_cors)
sd(lda_k8_thetaCor_paired_gt_cors)

```

### SL

```{r}

m1 <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = as.matrix(simFN7$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_k8_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_k8_thetaCor_paired_gt_cors, breaks = 10)
mean(sl_k8_thetaCor_paired_gt_cors)
sd(sl_k8_thetaCor_paired_gt_cors)

```

### RCTD

```{r}

m1 <- as.matrix(RCTD_FN7_results_norm)
# strangely, spots missing
# make sure the rows are the same, too
m2 <- as.matrix(simFN7$gtSpotTopics)[rownames(m1),]
  
thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_k8_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_k8_thetaCor_paired_gt_cors, breaks = 10)
mean(rctd_k8_thetaCor_paired_gt_cors)
sd(rctd_k8_thetaCor_paired_gt_cors)

```

## beta 8 cts

### LDA

```{r}

betaCorMtx <- getCorrMtx(m1 = FN7_K8$beta,
                         m2 = as.matrix(simFN7$gtCtGenes), # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k8_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k8_betaCor_paired_gt_cors, breaks = 10)
mean(lda_k8_betaCor_paired_gt_cors)
sd(lda_k8_betaCor_paired_gt_cors)

```

### SL

```{r}

SL_bregmaFN7FullSeur8cts_predict <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur8cts_fit[[1]],
                                                  stCounts = t(as.matrix(simFN7$sim)))

```


```{r}

betaCorMtx <- getCorrMtx(m1 = SL_bregmaFN7FullSeur8cts_predict$betaCt,
                         m2 = as.matrix(simFN7$gtCtGenes), # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_k8_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_k8_betaCor_paired_gt_cors, breaks = 10)
mean(sl_k8_betaCor_paired_gt_cors)
sd(sl_k8_betaCor_paired_gt_cors)

```

### RCTD

No beta matrix as far as I can tell

## theta 75 neuro cts

### LDA

```{r}

thetaCorMtx <- getCorrMtx(m1 = FN7_K75$theta,
                           m2 = as.matrix(simFN7_neuro$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k75_neuro_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k75_neuro_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k75_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k75_thetaCor_paired_gt_cors, breaks = 10)
mean(lda_k75_thetaCor_paired_gt_cors)
sd(lda_k75_thetaCor_paired_gt_cors)

```

### SL

```{r}

m1 <- SL_bregmaFN7FullSeur75neurocts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur75neurocts_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7_neuro$gtSpotTopics))

thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = as.matrix(simFN7_neuro$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k75_neuro_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k75_neuro_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_k75_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_k75_thetaCor_paired_gt_cors, breaks = 10)
mean(sl_k75_thetaCor_paired_gt_cors)
sd(sl_k75_thetaCor_paired_gt_cors)

```

### RCTD

```{r}

m1 <- as.matrix(RCTD_FN7_neuro_results_norm)
# strangely, spots missing
# make sure the rows are the same, too
m2 <- as.matrix(simFN7_neuro$gtSpotTopics)[rownames(m1),]
  
thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k75_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k75_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_k75_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_k75_thetaCor_paired_gt_cors, breaks = 10)
mean(rctd_k75_thetaCor_paired_gt_cors)
sd(rctd_k75_thetaCor_paired_gt_cors)

```

## beta 75 neuro cts

### LDA

```{r}

betaCorMtx <- getCorrMtx(m1 = FN7_K75$beta,
                         m2 = as.matrix(simFN7_neuro$gtCtGenes), # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k75_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k75_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k75_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k75_betaCor_paired_gt_cors, breaks = 10)
mean(lda_k75_betaCor_paired_gt_cors)
sd(lda_k75_betaCor_paired_gt_cors)

```

### SL

```{r}

SL_bregmaFN7FullSeur75neurocts_predict <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur75neurocts_fit[[1]],
                                                  stCounts = t(as.matrix(simFN7_neuro$sim)))

```


```{r}

betaCorMtx <- getCorrMtx(m1 = SL_bregmaFN7FullSeur75neurocts_predict$betaCt,
                         m2 = as.matrix(simFN7_neuro$gtCtGenes), # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k75_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k75_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_k75_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_k75_betaCor_paired_gt_cors, breaks = 10)
mean(sl_k75_betaCor_paired_gt_cors)
sd(sl_k75_betaCor_paired_gt_cors)

```

# C - Remove CT from MERFISH

Recompute the RMSE and correlations

# Remove Excitatory and Inhibitory

```{r}

# dim(bregmaCellsGexpFN7)
# 
# # for equal comparison, use the same cells that were kept in the simulated spots
# bregmaCellsGexpFN7_filt <- bregmaCellsGexpFN7[rownames(simFN7$annotDf),]
dim(bregmaCellsGexpFN7_filt)

# remove neuronal cells
simFN7_nonNeuroCells <- simFN7$annotDf[which(!simFN7$annotDf$Cell_class %in% c("Excitatory", "Inhibitory")),]
bregmaCellsGexpFN7_noNeuro <- bregmaCellsGexpFN7_filt[rownames(simFN7_nonNeuroCells),]
dim(bregmaCellsGexpFN7_noNeuro)

# "scRNAseq" reference using all the cells:
bregmaFN7FullSeur_noNeuro <- CreateSeuratObject(counts = t(bregmaCellsGexpFN7_noNeuro), project = "bregmaFull scRNAseq no neuro Ref")

# add cell class labels to the meta.data for assigning clusters later
bregmaFN7FullSeur_noNeuro[["Major_class"]] <- simFN7_nonNeuroCells$Cell_class

```

```{r}

# have already built this above. In the meta.data there is a column for major cell classes and another for all 75

bregmaFN7FullSeur_noNeuro

```

## SL 

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFN7FullSeur_noNeuro) <- bregmaFN7FullSeur_noNeuro@meta.data$Major_class

levels(bregmaFN7FullSeur_noNeuro@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFN7FullSeur_noNeuro_markers <- Seurat::FindAllMarkers(object = bregmaFN7FullSeur_noNeuro,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

```{r}

set.seed(888)

SL_bregmaFN7FullSeur_noNeuro_fit <- spotlight_deconvolution(
  se_sc = bregmaFN7FullSeur_noNeuro,
  counts_spatial = t(as.matrix(simFN7$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFN7FullSeur_noNeuro_markers, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

### Collect RMSE

RMSE for each spot

```{r}

breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
SL_noNeuro_spotsRMSE <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

length(SL_noNeuro_spotsRMSE)
head(SL_noNeuro_spotsRMSE)

```

Normalize the truth proportions back to 1 (because proportions still based on presence of neuro cts there and RMSE computed based on difference between truth and predcited values)

```{r}

breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# normalize truth_theta
truth_theta <- truth_theta/rowSums(truth_theta)

# note that some spots that had only neuronal cts beforehand had all 0's after
# filtering. So their values after normalizing are NAs. replace with 0's
truth_theta[is.na(truth_theta)] <- 0

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
SL_noNeuro_spotsRMSE_adj <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))

length(SL_noNeuro_spotsRMSE_adj)
head(SL_noNeuro_spotsRMSE_adj)

```

Each cell type across all spots

```{r}

breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting a ct across the spots
SL_noNeuro_ctRMSE <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(SL_noNeuro_ctRMSE) <- colnames(truth_theta)
SL_noNeuro_ctRMSE

```

```{r}

breg_theta <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# normalize truth_theta
truth_theta <- truth_theta/rowSums(truth_theta)

# note that some spots that had only neuronal cts beforehand had all 0's after
# filtering. So their values after normalizing are NAs. replace with 0's
truth_theta[is.na(truth_theta)] <- 0

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse for predicting a ct across the spots
SL_noNeuro_ctRMSE_adj <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = as.vector(truth_theta[,ct]))
}))
colnames(SL_noNeuro_ctRMSE_adj) <- colnames(truth_theta)
SL_noNeuro_ctRMSE_adj

```

## RCTD

### reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_noNeuro_ref/"

ref <- bregmaFN7FullSeur_noNeuro

meta_ref <- ref@meta.data[,c("Major_class", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

### data sets

same full simFN7$sim as before

### fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFullFN7_noNeuro_ref/"
FN7_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

FN7

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/FN7/"
RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_FN7_noNeuro <- RCTD::create.RCTD(RCTDspatial,
                        FN7_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_FN7_noNeuro_fit <- RCTD::run.RCTD(RCTD_FN7_noNeuro, doublet_mode = TRUE)

RCTD_FN7_noNeuro_results <- RCTD_FN7_noNeuro_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_FN7_noNeuro_results_norm <-  sweep(RCTD_FN7_noNeuro_results$weights, 1, rowSums(RCTD_FN7_noNeuro_results$weights), '/')

```

### Collect RMSE

RMSE for each spot

```{r}

breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
RCTD_noNeuro_spotsRMSE <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
# because missing spots for some reason, fill in by adding NAs
if (length(RCTD_noNeuro_spotsRMSE) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(RCTD_noNeuro_spotsRMSE)
  RCTD_noNeuro_spotsRMSE <- c(RCTD_noNeuro_spotsRMSE, rep(NA, toFill))
}
length(RCTD_noNeuro_spotsRMSE)
head(RCTD_noNeuro_spotsRMSE)

```

normalize the truth-theta to account for no neuronal cts

```{r}

breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# normalize truth_theta
truth_theta <- truth_theta/rowSums(truth_theta)

# note that some spots that had only neuronal cts beforehand had all 0's after
# filtering. So their values after normalizing are NAs. replace with 0's
truth_theta[is.na(truth_theta)] <- 0

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
RCTD_noNeuro_spotsRMSE_adj <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
  actual <- as.vector(truth_theta[i,])
  predict <- as.vector(predict_theta[i,])
  mltools::rmse(preds = predict, actuals = actual)
}))
# because missing spots for some reason, fill in by adding NAs
if (length(RCTD_noNeuro_spotsRMSE_adj) < dim(breg_gt_theta)[1]){
  toFill <- dim(breg_gt_theta)[1] - length(RCTD_noNeuro_spotsRMSE_adj)
  RCTD_noNeuro_spotsRMSE_adj <- c(RCTD_noNeuro_spotsRMSE_adj, rep(NA, toFill))
}
length(RCTD_noNeuro_spotsRMSE_adj)
head(RCTD_noNeuro_spotsRMSE_adj)

```

Each cell type separately for each deconvolved bregma

```{r}

breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse fpr predicting a ct across the spots
RCTD_noNeuro_ctRMSE <- do.call(cbind, lapply(colnames(breg_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(RCTD_noNeuro_ctRMSE) <- colnames(breg_theta)
RCTD_noNeuro_ctRMSE

```

```{r}

breg_theta <- RCTD_FN7_noNeuro_results_norm
breg_gt_theta <- as.matrix(simFN7$gtSpotTopics)

# make sure columns in each theta in same order
shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
truth_theta <- breg_gt_theta[,shared_cts]
predict_theta <- breg_theta[,shared_cts]

print(dim(predict_theta))
print(dim(truth_theta))

# strangely, w spots missing
# make sure the rows are the same, too
truth_theta <- truth_theta[rownames(predict_theta),]

# normalize truth_theta
truth_theta <- truth_theta/rowSums(truth_theta)

# note that some spots that had only neuronal cts beforehand had all 0's after
# filtering. So their values after normalizing are NAs. replace with 0's
truth_theta[is.na(truth_theta)] <- 0

# scale the ct columns by dividing each by sd
truth_theta <- scale(truth_theta, center = FALSE, scale = apply(truth_theta, 2, sd, na.rm = TRUE))
predict_theta <- scale(predict_theta, center = FALSE, scale = apply(predict_theta, 2, sd, na.rm = TRUE))

# return matrix where each column is the rmse fpr predicting a ct across the spots
RCTD_noNeuro_ctRMSE_adj <- do.call(cbind, lapply(colnames(breg_theta), function(ct){
  mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
}))
colnames(RCTD_noNeuro_ctRMSE_adj) <- colnames(breg_theta)
RCTD_noNeuro_ctRMSE_adj

```

# 1. RMSE Compare

```{r}

rmse_FN7_noNeuro <- data.frame(SPOTlight = as.vector(SL_bregmaFN7FullSeur8cts_spotsRMSE),
                                RCTD = as.vector(RCTD_bregmaFN7FullSeur8cts_spotsRMSE),
                                STdeconvolve = as.vector(LDA_bregmaFN7FullSeur8cts_spotsRMSE),
                                "SPOTlight noNeuro" = as.vector(SL_noNeuro_spotsRMSE),
                                "RCTD noNeuro" = as.vector(RCTD_noNeuro_spotsRMSE))

# my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STdeconvolve"), c("RCTD", "STdeconvolve") )

ggplot(data = reshape2::melt(rmse_FN7_noNeuro),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot(outlier.shape=NA) +
  geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
  # stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
  #                    label.y = c(0.50, 0.535, 0.582)) +
  labs(title = "MERFISH major cell type predictions across FN7 spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# ggsave(filename = "Fig2_A-1_RMSE_9cts_allBregma_spots.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)


# with rmse based on adjusted truth proportions:
rmse_FN7_noNeuro <- data.frame(SPOTlight = as.vector(SL_bregmaFN7FullSeur8cts_spotsRMSE),
                                RCTD = as.vector(RCTD_bregmaFN7FullSeur8cts_spotsRMSE),
                                STdeconvolve = as.vector(LDA_bregmaFN7FullSeur8cts_spotsRMSE),
                                "SPOTlight noNeuro" = as.vector(SL_noNeuro_spotsRMSE_adj),
                                "RCTD noNeuro" = as.vector(RCTD_noNeuro_spotsRMSE_adj))

# my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STdeconvolve"), c("RCTD", "STdeconvolve") )

ggplot(data = reshape2::melt(rmse_FN7_noNeuro),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot(outlier.shape=NA) +
  geom_point(position = position_jitterdodge(), alpha = 0.3, size = 0.1) + 
  # stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
  #                    label.y = c(0.50, 0.535, 0.582)) +
  labs(title = "MERFISH major cell type predictions across FN7 spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# ggsave(filename = "Fig2_A-1_RMSE_9cts_allBregma_spots.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)


```

```{r}

# spot IDs
FN7_spotIDs <- unlist(lapply(keys(FN7), function(ix){
  # table to df
  rownames(FN7[[ix]]$cellTypeTable)
}))

# combine all the cellTypeTables of each bregma in FN7 (counts of each cell type in each spot)
FN7_cellTypeTable <- lapply(keys(FN7), function(ix){
  # table to df
  as.data.frame.matrix(FN7[[ix]]$cellTypeTable)
})
# combine into single df, and because some bregmas may be missing cell types,
# use rbindlist to keep all columns and add NAs to spots for cell types
# they are missing
FN7_cellTypeTable <- data.table::rbindlist(FN7_cellTypeTable, fill = TRUE)

# replace NAs with 0s
FN7_cellTypeTable[is.na(FN7_cellTypeTable)] <- 0

# spot IDs as row names
FN7_cellTypeTable <- as.matrix(FN7_cellTypeTable)
rownames(FN7_cellTypeTable) <- FN7_spotIDs

# adjusted proportions of ground truth if neuronal cts removed
FN7_cellTypeTable_noNeuro <- FN7_cellTypeTable[,which(!colnames(FN7_cellTypeTable) %in% c("Excitatory", "Inhibitory"))]

```

```{r}

l_eachCt <- SL_noNeuro_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight noNeuro", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# adjusted proportions of ground truth if neuronal cts removed
tot_p_adj <- colSums(FN7_cellTypeTable_noNeuro)/sum(colSums(FN7_cellTypeTable_noNeuro))
proportion_adj <- as.vector(tot_p_adj[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

SL_noNeuro_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 # "Proportion adj" = proportion_adj,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- RCTD_noNeuro_ctRMSE
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD noNeuro", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# adjusted proportions of ground truth if neuronal cts removed
tot_p_adj <- colSums(FN7_cellTypeTable_noNeuro)/sum(colSums(FN7_cellTypeTable_noNeuro))
proportion_adj <- as.vector(tot_p_adj[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

RCTD_noNeuro_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion,
                 # "Proportion adj" = proportion_adj,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- SL_noNeuro_ctRMSE_adj
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("SPOTlight noNeuro adj", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# adjusted proportions of ground truth if neuronal cts removed
tot_p_adj <- colSums(FN7_cellTypeTable_noNeuro)/sum(colSums(FN7_cellTypeTable_noNeuro))
proportion_adj <- as.vector(tot_p_adj[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

SL_noNeuro_adj_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion_adj,
                 # "Proportion adj" = proportion_adj,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

l_eachCt <- RCTD_noNeuro_ctRMSE_adj
cts <- labels(l_eachCt)[[2]]
rmses <- as.vector(l_eachCt)
# breg <- rep(ix, length(cts))
tool <- rep("RCTD noNeuro adj", length(cts))

# total ct proportions
tot_p <- colSums(FN7_cellTypeTable)/sum(colSums(FN7_cellTypeTable))
proportion <- as.vector(tot_p[cts])

# adjusted proportions of ground truth if neuronal cts removed
tot_p_adj <- colSums(FN7_cellTypeTable_noNeuro)/sum(colSums(FN7_cellTypeTable_noNeuro))
proportion_adj <- as.vector(tot_p_adj[cts])

# max proportion in a spot
spot_max <- apply(simFN7$gtSpotTopics, 2, max)[cts]
# median proportion in a spot
spot_median <- apply(simFN7$gtSpotTopics, 2, median)[cts]
# sd proportion in a spot
spot_sd <- apply(simFN7$gtSpotTopics, 2, sd)[cts]

RCTD_noNeuro_adj_rmse_df <- data.frame("Cell type" = cts,
                 "RMSE" = rmses,
                 # "Bregma" = breg,
                 "Method" = tool,
                 "Proportion" = proportion_adj,
                 # "Proportion adj" = proportion_adj,
                 "Max spot proportion" = spot_max,
                 "Median spot proportion" = spot_median,
                 "Spot proportion std" = spot_sd)

# now combine them all:
FN7_noNeuro_eachCT_summary <- do.call("rbind", list(SL_8cts_rmse_df,
                                           RCTD_8cts_rmse_df,
                                           LDA_8cts_rmse_df,
                                           SL_noNeuro_rmse_df,
                                           SL_noNeuro_adj_rmse_df,
                                           RCTD_noNeuro_rmse_df,
                                           RCTD_noNeuro_adj_rmse_df))

```

The "adjustments" are RMSE based on ground truth porportions renormalized to 1 after removal of neuronal cts
The noNeuro are the RMSEs based on the original gt cell type proportions

```{r}

ggplot(data = FN7_noNeuro_eachCT_summary, aes(x = Method, y = RMSE, color = Method)) +
  # geom_boxplot(position = position_dodge(1)) +
  # geom_point(position = position_jitterdodge()) +
  geom_point() +
  facet_wrap(~Cell.type) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH cell type predictions across FN7",
       x = "Method", y = "RMSE")
# ggsave(filename = "Fig2_A-3_RMSE_9cts_allBregmas_eachCt.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

```{r}

ggplot(data = FN7_noNeuro_eachCT_summary, aes(x = Proportion, y = RMSE, color = Method, shape = Cell.type)) +
  geom_point() +
  scale_shape_manual(values = seq(8))

```

proportions for the noNeuro are the original gt proportions, and the proportions used for the adj ones are the renormalized proportions of the gt. Otherwise they would be the same as the original proportions. 

# 2. Correlations between GT

## theta

## SL

```{r}

m1 <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = as.matrix(simFN7$gtSpotTopics),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_thetaCor_paired_gt_cors)
sd(sl_noNeuro_thetaCor_paired_gt_cors)

```

```{r}

m1 <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

# just consider cts that were in reference
m2 <- as.matrix(simFN7$gtSpotTopics)[,colnames(m1)]

thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_thetaCor_paired_gt_cors)
sd(sl_noNeuro_thetaCor_paired_gt_cors)

```

```{r}

m1 <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

# just consider cts that were in reference
m2 <- as.matrix(simFN7$gtSpotTopics)[,colnames(m1)]

# normalize proportions
m2 <- m2/rowSums(m2)
m2[is.na(m2)] <- 0

thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_SL_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_thetaCor_paired_gt_cors)
sd(sl_noNeuro_thetaCor_paired_gt_cors)

```

It seems that microglia are being reassigned as inhibitory and exhitatory cells.
And the proportions of the other cells are pretty good. I actually don't think I should adjust the proportions of the ground truth for comparison. Because the other cell types correlate pretty well with their respective cts. It's just the microglia in this case. If I adjust the correlations get worse.

## RCTD

```{r}

m1 <- as.matrix(RCTD_FN7_noNeuro_results_norm)
# strangely, spots missing
# make sure the rows are the same, too
m2 <- as.matrix(simFN7$gtSpotTopics)[rownames(m1),]
  
thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(rctd_noNeuro_thetaCor_paired_gt_cors)
sd(rctd_noNeuro_thetaCor_paired_gt_cors)

```

Just consider cell types that were in reference

```{r}

m1 <- as.matrix(RCTD_FN7_noNeuro_results_norm)
# strangely, spots missing
# make sure the rows are the same, too
m2 <- as.matrix(simFN7$gtSpotTopics)[rownames(m1),colnames(m1)]
  
thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(rctd_noNeuro_thetaCor_paired_gt_cors)
sd(rctd_noNeuro_thetaCor_paired_gt_cors)

```

now normalize the gt proportions

```{r}

m1 <- as.matrix(RCTD_FN7_noNeuro_results_norm)
# strangely, spots missing
# make sure the rows are the same, too
m2 <- as.matrix(simFN7$gtSpotTopics)[rownames(m1),colnames(m1)]

# normalize proportions
m2 <- m2/rowSums(m2)
m2[is.na(m2)] <- 0
  
thetaCorMtx <- getCorrMtx(m1 = m1,
                           m2 = m2,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_RCTD_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_noNeuro_thetaCor_paired_gt_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_noNeuro_thetaCor_paired_gt_cors, breaks = 10)
mean(rctd_noNeuro_thetaCor_paired_gt_cors)
sd(rctd_noNeuro_thetaCor_paired_gt_cors)

```

Astrocytes are getting assigned to inhibitory and excitatory cells. Again, adjusting the proportions makes the correlations slightly worse. So it does decent job of predicting actual cell types but just has astrocytes getting assigned in place of excitatory and inhibatory

## beta

## SL

```{r}

SL_bregmaFN7FullSeur_noNeuro_predict <- SPOTlightPredict(nmfRef = SL_bregmaFN7FullSeur_noNeuro_fit[[1]],
                                                  stCounts = t(as.matrix(simFN7$sim)))

```

```{r}

betaCorMtx <- getCorrMtx(m1 = SL_bregmaFN7FullSeur_noNeuro_predict$betaCt,
                         m2 = as.matrix(simFN7$gtCtGenes), # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_betaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_betaCor_paired_gt_cors)
sd(sl_noNeuro_betaCor_paired_gt_cors)

```

```{r}

m1 <-  SL_bregmaFN7FullSeur_noNeuro_predict$betaCt

betaCorMtx <- getCorrMtx(m1 = m1,
                         m2 = as.matrix(simFN7$gtCtGenes)[,colnames(m1)], # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_betaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_betaCor_paired_gt_cors)
sd(sl_noNeuro_betaCor_paired_gt_cors)

```

```{r}

m1 <-  SL_bregmaFN7FullSeur_noNeuro_predict$betaCt
m2 <- SL_bregmaFN7FullSeur8cts_predict$betaCt

betaCorMtx <- getCorrMtx(m1 = m1,
                         m2 = m2, # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_betaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_betaCor_paired_gt_cors)
sd(sl_noNeuro_betaCor_paired_gt_cors)

```

```{r}

m1 <-  SL_bregmaFN7FullSeur_noNeuro_predict$betaTopics
m2 <- SL_bregmaFN7FullSeur8cts_predict$betaTopics

betaCorMtx <- getCorrMtx(m1 = m1,
                         m2 = m2, # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_SL_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
sl_noNeuro_betaCor_paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(sl_noNeuro_betaCor_paired_gt_cors, breaks = 10)
mean(sl_noNeuro_betaCor_paired_gt_cors)
sd(sl_noNeuro_betaCor_paired_gt_cors)

```

Again, shows that the microglia marker genes also very similar to neuronal markers and why it was also being assigned to those cell types in spots

# 3. Visualize

## SL

### 8 cts

```{r}

m1 <- SL_bregmaFN7FullSeur8cts_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur8cts_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(8)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7), function(ix){
  
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  
  m <- m1[spots,]
  p <- simFN7$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})
  
```

### no neural 6 cts

```{r}

m1 <- SL_bregmaFN7FullSeur_noNeuro_fit[[2]][,1:ncol(SL_bregmaFN7FullSeur_noNeuro_fit[[2]])-1]
rownames(m1) <- rownames(as.matrix(simFN7$gtSpotTopics))

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(6)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7), function(ix){
  
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  
  m <- m1[spots,]
  p <- simFN7$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})
  
```

## RCTD

### 8 cts

```{r}

m1 <- RCTD_FN7_results_norm

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(8)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7), function(ix){
  
  # RCTD missing some spots after deconvolve, 
  # so make sure same spots used
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  spots <- rownames(m1)[which(rownames(m1) %in% spots)]
  
  m <- m1[spots,]
  p <- simFN7$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})
  
```

### no neural 6 cts

```{r}

m1 <- RCTD_FN7_noNeuro_results_norm

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(6)

```

```{r}

# plot each bregma separately
lapply(names(simBregmasFN7), function(ix){
  
  # RCTD missing some spots after deconvolve, 
  # so make sure same spots used
  spots <- rownames(simBregmasFN7[[ix]]$cellCounts)
  spots <- rownames(m1)[which(rownames(m1) %in% spots)]
  
  m <- m1[spots,]
  p <- simFN7$cellCounts[spots, c("x", "y")]
  
  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=colspace,
               groups = NA,
               group_cols = NA,
               r = 40,
               lwd = 0.5,
               showLegend = TRUE,
               plotTitle = ix)
  # ggsave(filename = paste0("Fig1_B-2_FN7_k8_", ix, "_predict.pdf"),
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})
  
```

# =========================
# IGNORE
# Figure 2

lda k equal to other methods

merfish assess all cell types - which cell types do methods struggle most with? rare ones?

have merfish "scRNAseq" ref that you can use to assess what happens when a ct is removed for SL and RCTD

consider mob scRNAseq ref as gt and compute correlation. best matched and do RMSE?


beta probabilty versus actual gene counts...scatter plot of predicted beta vs actual cell type gene counts

there is that Interactive correlation heatmap might be useful here.

For example, the W vs the scRNAseq gene exp correlation. I did this at some point. Revisit the correlations by seeing the individual genes. Does transforming gene counts make them correlate better with beta/W?


# RMSE with MERFISH

# build seurat reference

Both Spotlight (SL) and RCTD require a Seurat object of gene counts for individual cells and meta data assigning these cells to clusters.

Combine cells from all of the bregmas to use as the reference. Have one reference with the 9 major cell classes and a second one that expands the cell types to the 75 types that include the neuronal types.

```{r}

# have already built this above. In the meta.data there is a column for major cell classes and another for all 75

bregmaFullSeur

```

# SL 9 Major Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFullSeur) <- bregmaFullSeur@meta.data$Major_class

levels(bregmaFullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFullSeur_markers9cts <- Seurat::FindAllMarkers(object = bregmaFullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Finally, lets train the model 

Note here that the training only keeps genes that are also in the spatial data that will be deconvolved. So it is important that the ST data used here will be what is deconvolved later. Otherwise during one of the NNMF steps during deconvolution, the *entire environment will actually crash!* Unless if one carefully filters for shared genes beforehand if a different ST object is used with the same trained SL model. Otherwise retrain for each new ST dataset to deconvolve.

However, here, at least for the MERFISH data, the same 125 genes are used for all simulated ST datasets so this should not be an issue. (For mOB ST sets, this will be)

```{r}

set.seed(888)

SL_bregmaFull9cts_04fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.04`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

really fast...makes me think that the number of genes is the real determinant of time and not really number of cells. Esp since it downsamples cells anyways.

Repeat for all the bregmas:

```{r}

set.seed(888)

SL_bregmaFull9cts_09fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.09`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_14fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.14`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_19fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.19`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_24fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.24`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

```{r}

set.seed(888)

SL_bregmaFull9cts_29fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas$`-0.29`$sim)),
  clust_vr = "Major_class", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers9cts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

## Collect RMSE

```{r}

fittedBregmas_SL_k9 <- list("-0.04" = SL_bregmaFull9cts_04fit[[2]][,1:ncol(SL_bregmaFull9cts_04fit[[2]])-1],
                         "-0.09" = SL_bregmaFull9cts_09fit[[2]][,1:ncol(SL_bregmaFull9cts_09fit[[2]])-1],
                         "-0.14" = SL_bregmaFull9cts_14fit[[2]][,1:ncol(SL_bregmaFull9cts_14fit[[2]])-1],
                         "-0.19" = SL_bregmaFull9cts_19fit[[2]][,1:ncol(SL_bregmaFull9cts_19fit[[2]])-1],
                         "-0.24" = SL_bregmaFull9cts_24fit[[2]][,1:ncol(SL_bregmaFull9cts_24fit[[2]])-1],
                         "-0.29" = SL_bregmaFull9cts_29fit[[2]][,1:ncol(SL_bregmaFull9cts_29fit[[2]])-1])

```

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

bregIds <- names(fittedBregmas_SL_k9)
sl_rmse_k9_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_SL_k9[[id]]
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  spot_rmse <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  spot_rmse
}))

colnames(sl_rmse_k9_allCts) <- bregIds

```

Each cell type separately for each deconvolved bregma

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_SL_k9)

sl_rmse_k9_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_SL_k9[[id]]
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # return matrix where each column is the rmse fpr predicting a ct across the spots
  breg_rmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(truth_theta)
  breg_rmse
})
names(sl_rmse_k9_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

# SL 75 Neuronal Cts Train

Lets train SL using the 9 Major cell classes

```{r}

# Set the known clusters as the "active.indent"
Seurat::Idents(object = bregmaFullSeur) <- bregmaFullSeur@meta.data$All_classes

levels(bregmaFullSeur@active.ident)

```

Now, lets get the marker genes for each of these major cells types (aka cell clusters)

```{r}

bregmaFullSeur_markers75neuocts <- Seurat::FindAllMarkers(object = bregmaFullSeur,
                                              assay = "RNA",
                                              slot = "data", # counts or data are identical in this case
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

Some types do not have assigned marker genes. I wonder how this will affect the subsequent model training

Now fit:

```{r}

set.seed(888)

SL_bregmaFull75neurocts_04fit <- spotlight_deconvolution(
  se_sc = bregmaFullSeur,
  counts_spatial = t(as.matrix(simBregmas_neuro$`-0.04`$sim)), # actually same sim as "simBregmas". Just that the gt refs differ
  clust_vr = "All_classes", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = bregmaFullSeur_markers75neuocts, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 0, # Only 125 total genes so no need to get highly variable genes on top of this
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
  )

# note that this wrapper also performs the down sampling of the data. Is this fair? Uses 100 cells of each of the classes. But could use more.

```

The number of clusters or cells types also makes a major contribution to time.
Same genes (125) but 75 cts instead of 9 and significantly slower...

Now fit the remaining

So, because all corpuses have the same genes, I should be able to use the same fitted model to deconvolve all of them. If there were different genes then there is a risk that the W and ST data set may not match wrt genes and the nnls step would crash.

To this point, looking at the W and H matrices of the NMF object for the `SL_bregmaFull9cts_` objects, they are the same for each instance of training SPOTlight.

Training is by far the slowest part. So to speed things up, wrote a wrapper function that performs the subsequent steps in SPOTlight after training the NMF model (and in turn, also extracts additional potentially useful information)

```{r}

SL_bregmaFull75neurocts_09fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.09`$sim)))

SL_bregmaFull75neurocts_14fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.14`$sim)))

SL_bregmaFull75neurocts_19fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.19`$sim)))

SL_bregmaFull75neurocts_24fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.24`$sim)))

SL_bregmaFull75neurocts_29fit <- SPOTlightPredict(nmfRef = SL_bregmaFull75neurocts_04fit[[1]],
                                                  stCounts = t(as.matrix(simBregmas_neuro$`-0.29`$sim)))

```

## Collect RMSE

```{r}

fittedBregmas_SL_k75 <- list("-0.04" = SL_bregmaFull75neurocts_04fit[[2]][,1:ncol(SL_bregmaFull75neurocts_04fit[[2]])-1],
                         "-0.09" = SL_bregmaFull75neurocts_09fit$thetaCt,
                         "-0.14" = SL_bregmaFull75neurocts_14fit$thetaCt,
                         "-0.19" = SL_bregmaFull75neurocts_19fit$thetaCt,
                         "-0.24" = SL_bregmaFull75neurocts_24fit$thetaCt,
                         "-0.29" = SL_bregmaFull75neurocts_29fit$thetaCt)

```

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

bregIds <- names(fittedBregmas_SL_k75)
sl_rmse_k75_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_SL_k75[[id]]
  # fix column names so they match the gt
  colnames(breg_theta) <- sub("\\.", "-", colnames(breg_theta))
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  spot_rmse <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  spot_rmse
}))

colnames(sl_rmse_k75_allCts) <- bregIds

```

Each cell type separately for each deconvolved bregma

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_SL_k75)

sl_rmse_k75_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_SL_k75[[id]]
  # fix column names so they match the gt
  colnames(breg_theta) <- sub("\\.", "-", colnames(breg_theta))
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # return matrix where each column is the rmse fpr predicting a ct across the spots
  breg_rmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(truth_theta)
  breg_rmse
})
names(sl_rmse_k75_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matrix
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```


# RCTD 9 Major Cts Train

The input reference and data to be deconvolved need to be placed into directories, labeled a special way, and have specific columns in the files. 

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_ref/"

ref <- bregmaFullSeur

meta_ref <- ref@meta.data[,c("Major_class", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$Major_class),
                         Name = unique(ref@meta.data$Major_class)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
d <- simBregmas$`-0.04`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma09/"
d <- simBregmas$`-0.09`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma14/"
d <- simBregmas$`-0.14`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma19/"
d <- simBregmas$`-0.19`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma24/"
d <- simBregmas$`-0.24`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma29/"
d <- simBregmas$`-0.29`

x <- as.data.frame(t(as.matrix(d$sim)))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "MappedDGEForR.csv"))

beads <- d$cellCounts[,c("x", "y")]
colnames(beads) <- c("xcoord", "ycoord")
beads$barcodes <- rownames(beads)
beads <- beads[,c("barcodes", "xcoord", "ycoord")]
write.table(x=beads,
            sep = ",",
            row.names = FALSE,
            file=paste0(p, "BeadLocationsForR.csv"))

```

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_ref/"
bregmaFull_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

bregma -0.04

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
bregma04_RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_bregma04 <- RCTD::create.RCTD(bregma04_RCTDspatial,
                        bregmaFull_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_bregma04_fit <- RCTD::run.RCTD(RCTD_bregma04, doublet_mode = TRUE)

RCTD_bregma04_results <- RCTD_bregma04_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_bregma04_results_norm <-  sweep(RCTD_bregma04_results$weights, 1, rowSums(RCTD_bregma04_results$weights), '/')

```

Do the rest of the bregmas

```{r}

set.seed(888)

rctd_ref <- bregmaFull_RCTD_ref
# bregmas <- c("bregma09", "bregma14", "bregma19", "bregma24", "bregma29")
# bregmas <- c("-0.09", "-0.14", "-0.19", "-0.24", "-0.29")
p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/"

rctd_thetas <- lapply(bregmas, function(breg){
  datadir <- paste0(p, breg, "/")
  
  spatial <- RCTD::read.SpatialRNA(datadir)
  rctd <- RCTD::create.RCTD(spatial,
                        rctd_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)
  
  rctd_fit <- RCTD::run.RCTD(rctd, doublet_mode = TRUE)
  
  results <- rctd_fit@results
  # normalize the cell type proportions to sum to 1.
  norm <-  sweep(results$weights, 1, rowSums(results$weights), '/')
  norm
})
names(rctd_thetas) <- bregmas

```

## Collect RMSE

```{r}

# update names
names(rctd_thetas) <- c("-0.09", "-0.14", "-0.19", "-0.24", "-0.29")
# add the -0.04
rctd_thetas[["-0.04"]] <- RCTD_bregma04_results_norm

```

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

bregIds <- names(fittedBregmas_SL_k9)
rctd_rmse_k9_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- as.matrix(rctd_thetas[[id]])
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # strangely, because missing a spot (row) in rctd -0.09,
  # make sure the rows are the same, too
  truth_theta <- truth_theta[rownames(predict_theta),]
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  spot_rmse <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  # because -0.09 is missing a spot for some reason, fill in by adding NAs
  if (length(spot_rmse) < 256){
    toFill <- 256 - length(spot_rmse)
    spot_rmse <- c(spot_rmse, rep(NA, toFill))
  }
  spot_rmse
  print(spot_rmse)
}))

colnames(rctd_rmse_k9_allCts) <- bregIds

```

*weird* -0.09 from the rctd predictions in missing a spot...

Each cell type separately for each deconvolved bregma

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_SL_k9)

rctd_rmse_k9_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- as.matrix(rctd_thetas[[id]])
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  predict_theta <- breg_theta
  truth_theta <- breg_gt_theta[,colnames(breg_theta)]
  
  # strangely, because missing a spot (row) in rctd -0.09,
  # make sure the rows are the same, too
  truth_theta <- truth_theta[rownames(predict_theta),]
  
  # return matrix where each column is the rmse fpr predicting a ct across the spots
  breg_rmse <- do.call(cbind, lapply(colnames(breg_theta), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(breg_theta)
  breg_rmse
})
names(rctd_rmse_k9_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

# RCTD 75 Neuronal Cts Train

## reference

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_75cts_ref/"

ref <- bregmaFullSeur

meta_ref <- ref@meta.data[,c("All_classes", "nFeature_RNA")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$All_classes),
                         Name = unique(ref@meta.data$All_classes)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

## data sets

Same as what was used for RCTD 9 Cts

## fit

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregmaFull_75cts_ref/"
bregmaFull_75cts_RCTD_ref <- RCTD::dgeToSeurat(refdir)

```

bregma -0.04

```{r}

set.seed(888)

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/bregma04/"
bregma04_RCTDspatial <- RCTD::read.SpatialRNA(datadir)

RCTD_bregma04_75ct <- RCTD::create.RCTD(bregma04_RCTDspatial,
                        bregmaFull_75cts_RCTD_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)

RCTD_bregma04_75ct_fit <- RCTD::run.RCTD(RCTD_bregma04_75ct, doublet_mode = TRUE)

RCTD_bregma04_75ct_results <- RCTD_bregma04_75ct_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_bregma04_75ct_results_norm <-  sweep(RCTD_bregma04_75ct_results$weights, 1, rowSums(RCTD_bregma04_75ct_results$weights), '/')

```

although 75 cts in ref, only 72 reported here. Maybe 3 cell types not detected at all and dropped

Do the rest of the bregmas

```{r}

set.seed(888)

rctd_ref <- bregmaFull_75cts_RCTD_ref
# bregmas <- c("bregma09", "bregma14", "bregma19", "bregma24", "bregma29")
# bregmas <- c("-0.09", "-0.14", "-0.19", "-0.24", "-0.29")
p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/bregma_datasets/"

rctd_thetas_75cts <- lapply(bregmas, function(breg){
  datadir <- paste0(p, breg, "/")
  
  spatial <- RCTD::read.SpatialRNA(datadir)
  rctd <- RCTD::create.RCTD(spatial,
                        rctd_ref,
                        max_cores = 7,
                        CELL_MIN_INSTANCE = 1)
  
  rctd_fit <- RCTD::run.RCTD(rctd, doublet_mode = TRUE)
  
  results <- rctd_fit@results
  # normalize the cell type proportions to sum to 1.
  norm <-  sweep(results$weights, 1, rowSums(results$weights), '/')
  norm
})
names(rctd_thetas_75cts) <- bregmas

```

## Collect RMSE

```{r}

# update names
names(rctd_thetas_75cts) <- c("-0.09", "-0.14", "-0.19", "-0.24", "-0.29")
# add the -0.04
rctd_thetas_75cts[["-0.04"]] <- RCTD_bregma04_75ct_results_norm

```

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

bregIds <- names(fittedBregmas_SL_k9)
rctd_rmse_k75_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- as.matrix(rctd_thetas_75cts[[id]])
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # strangely, because missing a spot (row) in rctd -0.09,
  # make sure the rows are the same, too
  truth_theta <- truth_theta[rownames(predict_theta),]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  spot_rmse <- unlist(lapply(seq(dim(predict_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  
  # because -0.09 is missing a spot for some reason, fill in by adding NAs
  if (length(spot_rmse) < 256){
    toFill <- 256 - length(spot_rmse)
    spot_rmse <- c(spot_rmse, rep(NA, toFill))
  }
  spot_rmse
  print(spot_rmse)
}))

colnames(rctd_rmse_k75_allCts) <- bregIds

```

*weird* -0.09 from the rctd predictions in missing a spot...

Each cell type separately for each deconvolved bregma

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_SL_k9)

rctd_rmse_k75_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- as.matrix(rctd_thetas_75cts[[id]])
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # make sure columns in each theta in same order
  shared_cts <- intersect(colnames(breg_theta), colnames(breg_gt_theta))
  truth_theta <- breg_gt_theta[,shared_cts]
  predict_theta <- breg_theta[,shared_cts]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # strangely, because missing a spot (row) in rctd -0.09,
  # make sure the rows are the same, too
  truth_theta <- truth_theta[rownames(predict_theta),]
  
  print(dim(predict_theta))
  print(dim(truth_theta))
  
  # return matrix where each column is the rmse fpr predicting a ct across the spots
  breg_rmse <- do.call(cbind, lapply(colnames(truth_theta), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(truth_theta)
  breg_rmse
})
names(rctd_rmse_k75_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

# LDA train additional Bregmas

```{r}

# fit models to a range of K's that include 9 (for 9 major cell types) and
# 75 (for all the cell types including neuronal)
ks <- seq(from = 2, to = 10, by = 1)
ks <- c(ks, seq(from = 15, to = 75, by = 10))

```

```{r}

pdf(file = paste0(fig_path, "Fig1_B-1_breg09_mjrcts_lda_fit.pdf"))
bregma09_LDAs <- fitLDA(counts = simBregmas$`-0.09`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg14_mjrcts_lda_fit.pdf"))
bregma14_LDAs <- fitLDA(counts = simBregmas$`-0.14`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg19_mjrcts_lda_fit.pdf"))
bregma19_LDAs <- fitLDA(counts = simBregmas$`-0.19`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg24_mjrcts_lda_fit.pdf"))
bregma24_LDAs <- fitLDA(counts = simBregmas$`-0.24`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

pdf(file = paste0(fig_path, "Fig1_B-1_breg29_mjrcts_lda_fit.pdf"))
bregma29_LDAs <- fitLDA(counts = simBregmas$`-0.29`$sim,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

## Collect RMSE

Use either K=9 or K=75 trained models to be comparable with SL and RCTD

## K = 9 major cts

```{r}

# bregma04_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = 9),
#                       deepSplit = 4,
#                       colorScheme = "rainbow")

bregma09_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma09_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

bregma14_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma14_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

bregma19_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma19_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

bregma24_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma24_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

bregma29_k9 <- buildLDAobject(LDAmodel = optimalModel(bregma29_LDAs, opt = 9),
                      deepSplit = 4,
                      colorScheme = "rainbow")

fittedBregmas_k9 <- list("-0.04" = bregma04_k9,
                         "-0.09" = bregma09_k9,
                         "-0.14" = bregma14_k9,
                         "-0.19" = bregma19_k9,
                         "-0.24" = bregma24_k9,
                         "-0.29" = bregma29_k9)


```

RMSE for each spot based on prediction of the 9 major cell classes

```{r}

bregIds <- names(fittedBregmas_k9)
lda_rmse_k9_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_k9[[id]]$theta
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # get pairs of topics and ground truth cell types that correlate best
  theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_theta,
                                      m2 = breg_gt_theta,
                                      type = "t"))
  # reorder the predicted topics to match their paired cell type
  # rows are spots and columns are topics
  # `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
  predict_theta <- breg_theta[,theta_pairs$rowix]
  # the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
  truth_theta <- breg_gt_theta[,theta_pairs$colsix]
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  lda_spot_rmse <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  lda_spot_rmse
}))

colnames(lda_rmse_k9_allCts) <- bregIds

```

Now try computing RMSE wrt each cell type separately

Note that for the ground truth theta matrices, at least for the 75 neuronal cts, not every one has all 75 cts. So for the correlation matrix the ground truths should be switched with the predicted theta to be the number of rows (because cannot have more rows than columns for the lsat pairing.)

Additionally, for the list, should have each entry be a bregma, and the matrix will be the rmse for each spot where each cell type present in reference is a column

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_k9)

lda_rmse_k9_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_k9[[id]]$theta
  breg_gt_theta <- as.matrix(simBregmas[[id]]$gtSpotTopics)
  
  # get pairs of topics and ground truth cell types that correlate best
  theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_gt_theta,
                                      m2 = breg_theta,
                                      type = "t"))
  
  # for a given bregma, pair up predicted topics with cell types present
  predict_theta <- breg_theta[,theta_pairs$colsix]
  truth_theta <- breg_gt_theta[,theta_pairs$rowix]
  
  # return matrix where each column is the rmse fpr predicting each ct across spots
  breg_rmse <- do.call(cbind, lapply(seq(theta_pairs$rowix), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(truth_theta)
  breg_rmse
})
names(lda_rmse_k9_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

## K = 75 neuronal cts

```{r}

# bregma04_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs, opt = "min"),
#                       deepSplit = 2, # collapsed more to reduce number of clusters to 17
#                       colorScheme = "rainbow")

bregma09_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma09_LDAs, opt = 75),
                      deepSplit = 2,
                      colorScheme = "rainbow")

bregma14_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma14_LDAs, opt = 75),
                      deepSplit = 2,
                      colorScheme = "rainbow")

bregma19_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma19_LDAs, opt = 75),
                      deepSplit = 2,
                      colorScheme = "rainbow")

bregma24_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma24_LDAs, opt = 75),
                      deepSplit = 2,
                      colorScheme = "rainbow")

bregma29_k75 <- buildLDAobject(LDAmodel = optimalModel(bregma29_LDAs, opt = 75),
                      deepSplit = 2,
                      colorScheme = "rainbow")

fittedBregmas_k75 <- list("-0.04" = bregma04_k75,
                         "-0.09" = bregma09_k75,
                         "-0.14" = bregma14_k75,
                         "-0.19" = bregma19_k75,
                         "-0.24" = bregma24_k75,
                         "-0.29" = bregma29_k75)


```

```{r}

bregIds <- names(fittedBregmas_k75)
lda_rmse_k75_allCts <- do.call(cbind, lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_k75[[id]]$theta
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # get pairs of topics and ground truth cell types that correlate best
  theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_gt_theta, # rows
                                      m2 = breg_theta, # cols
                                      type = "t"))
  # reorder the predicted topics to match their paired cell type
  # rows are spots and columns are topics
  # `pairs$rowix` are the new paired indices of the rows in the corrMtx. Here, the rows are the predicted topics
  predict_theta <- breg_theta[,theta_pairs$colsix]
  # the `pairs$rowix` are the new paired indices of the columns in the corrMtx. Here, the cols are the cell types
  truth_theta <- breg_gt_theta[,theta_pairs$rowix]
  
  # for each spot, compute the RMSE wrt predicting proportions of the 9 cell types
  lda_spot_rmse <- unlist(lapply(seq(dim(truth_theta)[1]), function(i){
    actual <- as.vector(truth_theta[i,])
    predict <- as.vector(predict_theta[i,])
    mltools::rmse(preds = predict, actuals = actual)
  }))
  lda_spot_rmse
}))

colnames(lda_rmse_k75_allCts) <- bregIds

```

Each cell type separately

```{r}

# list where each entry is the rmse values of a given model trained on a bregma for predicting each cell type

bregIds <- names(fittedBregmas_k75)

lda_rmse_k75_eachCt <- lapply(bregIds, function(id){
  
  breg_theta <- fittedBregmas_k75[[id]]$theta
  breg_gt_theta <- as.matrix(simBregmas_neuro[[id]]$gtSpotTopics)
  
  # get pairs of topics and ground truth cell types that correlate best
  theta_pairs <- lsatPairs(getCorrMtx(m1 = breg_gt_theta, # rows
                                      m2 = breg_theta, # cols
                                      type = "t"))
  
  # for a given bregma, pair up predicted topics with cell types present
  predict_theta <- breg_theta[,theta_pairs$colsix]
  truth_theta <- breg_gt_theta[,theta_pairs$rowix]
  
  # return matrix where each column is the rmse fpr predicting each ct across spots
  breg_rmse <- do.call(cbind, lapply(seq(theta_pairs$rowix), function(ct){
    mltools::rmse(preds = predict_theta[,ct], actuals = truth_theta[,ct])
  }))
  colnames(breg_rmse) <- colnames(truth_theta)
  breg_rmse
})
names(lda_rmse_k75_eachCt) <- bregIds

# because all 9 cts are present essentially this list could be converted to a matric
# where each row is a bregma (because all columns are the same)

# but for the 75 cts, because the same cell types are not necessarily present in
# all the bregmas, the row lengths and columns will differ so can't combine as easily.

```

It's interesting the RMSE are really low for the neuronal cts. Maybe its because they are rare and the proportions are low to begin with and these low values naturally result in lower rmse?? So the important comparison is wrt the other methods

# ---------

# A - RMSE compare

Each spot, all bregmas, 9 cts

```{r}

rmse_allBregmas_allCts_9cts <- data.frame(SPOTlight = as.vector(sl_rmse_k9_allCts),
                                          RCTD = as.vector(rctd_rmse_k9_allCts),
                                          STDeconvolve = as.vector(lda_rmse_k9_allCts))

my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STDeconvolve"), c("RCTD", "STDeconvolve") )

ggplot(data = reshape2::melt(rmse_allBregmas_allCts_9cts),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  geom_point(position = position_jitterdodge(), alpha = 0.3) + 
  stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
                     label.y = c(0.35, 0.375, 0.41)) +
  labs(title = "MERFISH 9 major cell type predictions across all bregma spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
    theme_classic()
ggsave(filename = "Fig2_A-1_RMSE_9cts_allBregma_spots.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


```

Each spot, all bregmas, 75 cts

```{r}

rmse_allBregmas_allCts_75cts <- data.frame(SPOTlight = as.vector(sl_rmse_k75_allCts),
                                          RCTD = as.vector(rctd_rmse_k75_allCts),
                                          STDeconvolve = as.vector(lda_rmse_k75_allCts))

my_comparisons <- list( c("SPOTlight", "RCTD"), c("SPOTlight", "STDeconvolve"), c("RCTD", "STDeconvolve") )

ggplot(data = reshape2::melt(rmse_allBregmas_allCts_75cts),
       aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  geom_point(position = position_jitterdodge(), alpha = 0.3) + 
  stat_compare_means(comparisons = my_comparisons, method = "wilcox.test", 
                     label.y = c(0.18, 0.20, 0.22)) +
  labs(title = "MERFISH 75 cell type predictions across all bregma spots",
       x = "Method", y = "RMSE") +
  # theme(
  #     #panel.background = element_rect(fill = "white"),
  #     # panel.grid = element_blank(),
  #     # axis.line=element_blank(),
  #     # axis.text.x=element_blank(),
  #     # axis.text.y=element_blank(),
  #     # axis.ticks=element_blank(),
  #     # axis.title.x=element_blank(),
  #     # axis.title.y=element_blank(),
  #     panel.background=element_blank())
    theme_classic()
ggsave(filename = "Fig2_A-2_RMSE_75cts_allBregma_spots.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)


```

Instead, can I compute RMSE for deconvolving each cell type instead of all cell types across the spots. Identify which cell types are easy and which are hard for the models to predict

```{r}

# use rbind and do call to append matrices vertically as if you were adding new rows
# but same columns

# the matrices to be added will be contructed from the vectors in the "_eachCt" lists
# matrices will have the following columns:
# "cell type", "method", "RMSE", "bregma", "total ct proportion", "median spot proportion"

# combining the matrices in this way will create a "long-form matrix" for use with ggplot
# to visualize relationships between cell types, their proportions, and the ability of each
# method to detect them

l_eachCt <- sl_rmse_k9_eachCt
sl_k9_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("SPOTlight", length(cts))
  
  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])
  
  # max proportion in a spot
  spot_max <- apply(simBregmas[[ix]]$gtSpotTopics, 2, max)
  # max proportion in a spot
  spot_median <- apply(simBregmas[[ix]]$gtSpotTopics, 2, median)
  # max proportion in a spot
  spot_sd <- apply(simBregmas[[ix]]$gtSpotTopics, 2, sd)
  
  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

l_eachCt <- rctd_rmse_k9_eachCt
rctd_k9_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("RCTD", length(cts))
  
  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])
  
  # max proportion in a spot
  spot_max <- apply(simBregmas[[ix]]$gtSpotTopics, 2, max)
  # max proportion in a spot
  spot_median <- apply(simBregmas[[ix]]$gtSpotTopics, 2, median)
  # max proportion in a spot
  spot_sd <- apply(simBregmas[[ix]]$gtSpotTopics, 2, sd)
  
  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

l_eachCt <- lda_rmse_k9_eachCt
lda_k9_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("STDeconvolve", length(cts))
  
  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])
  
  # max proportion in a spot
  spot_max <- apply(simBregmas[[ix]]$gtSpotTopics, 2, max)
  # max proportion in a spot
  spot_median <- apply(simBregmas[[ix]]$gtSpotTopics, 2, median)
  # max proportion in a spot
  spot_sd <- apply(simBregmas[[ix]]$gtSpotTopics, 2, sd)
  
  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

# now combine them all:
k9_eachCT_summary <- do.call("rbind", list(sl_k9_eachCT_summary,
                                           rctd_k9_eachCT_summary,
                                           lda_k9_eachCT_summary))

```

```{r}

ggplot(data = k9_eachCT_summary, aes(x = Method, y = RMSE, fill = Method)) +
  geom_boxplot(position = position_dodge(1)) +
  geom_point(position = position_jitterdodge()) +
  facet_wrap(~Cell.type) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 9 cell type predictions across all bregmas",
       x = "Method", y = "RMSE")
ggsave(filename = "Fig2_A-3_RMSE_9cts_allBregmas_eachCt.pdf",
       device = "pdf",
       path = fig_path,
       scale = 1.5,
       width = 5,
       height = 4,
       units = c("in"),
       dpi = 600)

```

```{r}

ggplot(data = k9_eachCT_summary, aes(x = Proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

ggplot(data = k9_eachCT_summary, aes(x = Max.spot.proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

ggplot(data = k9_eachCT_summary, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

```

```{r}

# use rbind and do call to append matrices vertically as if you were adding new rows
# but same columns

# the matrices to be added will be contructed from the vectors in the "_eachCt" lists
# matrices will have the following columns:
# "cell type", "method", "RMSE", "bregma", "total ct proportion", "median spot proportion"

# combining the matrices in this way will create a "long-form matrix" for use with ggplot
# to visualize relationships between cell types, their proportions, and the ability of each
# method to detect them

l_eachCt <- sl_rmse_k75_eachCt
sl_k75_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("SPOTlight", length(cts))

  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])

  # max proportion in a spot
  spot_max <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, max)[cts]
  # max proportion in a spot
  spot_median <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, median)[cts]
  # max proportion in a spot
  spot_sd <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, sd)[cts]

  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

l_eachCt <- rctd_rmse_k75_eachCt
rctd_k75_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("RCTD", length(cts))
  
  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])
  
  # max proportion in a spot
  spot_max <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, max)[cts]
  # max proportion in a spot
  spot_median <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, median)[cts]
  # max proportion in a spot
  spot_sd <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, sd)[cts]
  
  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

l_eachCt <- lda_rmse_k75_eachCt
lda_k75_eachCT_summary <- do.call(rbind, lapply(names(l_eachCt), function(ix){
  cts <- labels(l_eachCt[[ix]])[[2]]
  rmses <- as.vector(l_eachCt[[ix]])
  breg <- rep(ix, length(cts))
  tool <- rep("STDeconvolve", length(cts))
  
  # total ct proportions
  tot_p <- colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable)/sum(colSums(FN7_2_M22_M26_neuro[[ix]]$cellTypeTable))
  proportion <- as.vector(tot_p[cts])
  
  # max proportion in a spot
  spot_max <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, max)[cts]
  # max proportion in a spot
  spot_median <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, median)[cts]
  # max proportion in a spot
  spot_sd <- apply(simBregmas_neuro[[ix]]$gtSpotTopics, 2, sd)[cts]
  
  df <- data.frame("Cell type" = cts,
                   "RMSE" = rmses,
                   "Bregma" = breg,
                   "Method" = tool,
                   "Proportion" = proportion,
                   "Max spot proportion" = spot_max,
                   "Median spot proportion" = spot_median,
                   "Spot proportion std" = spot_sd)
  # as.matrix(df)
  df
}))

# now combine them all:
k75_eachCT_summary <- do.call("rbind", list(sl_k75_eachCT_summary,
                                           rctd_k75_eachCT_summary,
                                           lda_k75_eachCT_summary))

```

```{r, fig.height=16, fig.width=8}

ggplot(data = k75_eachCT_summary, aes(x = Method, y = RMSE, fill = Method)) +
  geom_boxplot(position = position_dodge(1)) +
  geom_point(position = position_jitterdodge()) +
  facet_wrap(~Cell.type, nrow = 10) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "MERFISH 75 cell type predictions across all bregmas",
       x = "Method", y = "RMSE")
# ggsave(filename = "Fig2_A-3_RMSE_9cts_allBregmas_eachCt.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

```{r fig.height=8, fig.width=12}

ggplot(data = k75_eachCT_summary, aes(x = Proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

ggplot(data = k75_eachCT_summary, aes(x = Max.spot.proportion, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

ggplot(data = k75_eachCT_summary, aes(x = Spot.proportion.std, y = RMSE, color = Cell.type, shape = Method)) +
  geom_point()

```

```{r}

sl_rmse_k9_allCts
sl_rmse_k9_eachCt
sl_rmse_k75_allCts
sl_rmse_k75_eachCt

rctd_rmse_k9_allCts
rctd_rmse_k9_eachCt
rctd_rmse_k75_allCts
rctd_rmse_k75_eachCt

lda_rmse_k9_allCts
lda_rmse_k9_eachCt
lda_rmse_k75_allCts
lda_rmse_k75_eachCt

```


# B - Correlations between GT

Each method wrt 9 major cts across all spots, do for each bregma separately

Boxplot of correlations
Also show heatmaps of best matched

# C - Remove CT from MERFISH

Recompute the RMSE and correlations

# =========================
# D - MOB 

Correlations between predicted cell types for each method (LDA vs SL vs RCTD)

Cell types that SL and RCTD correlate poorly on wrt to each other? As in, which cts are not consistent between the two methods? Implies that the reference approach predictions are also dependent on the method. And this is consistent with the fact that microglia or astrocytes filled the neuronal ct gap for the merfish dropped cells.

# LDA Ref and Train

## k = 38 (for cts in scRNAseq ref)

```{r}

mob_k38 <- buildLDAobject(LDAmodel = optimalModel(mob_LDAs, opt = 38),
                      deepSplit = 2,
                      colorScheme = "rainbow")

```

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(38)

```

```{r}

m <- mob_k38$theta # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topic clusters

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(9)

```

```{r}

m <- mob_k38$thetaCombn # theta for 6 topic clusters of the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-2_mob_k15_clusters_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- mob_k38$theta
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

```{r}

m <- mob_k38$thetaCombn
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k38$clustCols,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

Check out the individual topics that make up each cluster

```{r}

m <- mob_k38$theta
p <- mobCorpus$mob$pos

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = mob_k38$cols,
                 sharedCol = FALSE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## theta correlation

See which topics correlate with the 5 cell layer annotations based on txn clustering

```{r}

# proxy theta for the txn clusters
mobProxyTheta <- model.matrix(~ 0 + mob_annot)
rownames(mobProxyTheta) <- names(mob_annot)

# fix names
colnames(mobProxyTheta) <- unlist(lapply(colnames(mobProxyTheta), function(x) {
  unlist(strsplit(x, ": "))[2]
}))

mobProxyTheta <- as.data.frame.matrix(mobProxyTheta)

```

```{r}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k38$theta,
                                       type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
# dev.off()

```

Topic cluster theta correlations

```{r}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                                       m2 = mob_k38$thetaCombn,
                                       type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_theta_combined_Cor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(4,11))
# dev.off()

```

## beta correlation

Correlate to a mob scRNAseq reference to see if certain topics also correlate with known cell types.

```{r}

betaCorMtx<- getCorrMtx(m1 = mob_k38$beta,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

# pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

```

```{r}

betaCorMtx <- getCorrMtx(m1 = mob_k38$betaCombn,
                                       m2 = as.matrix(mobWtCellProxyBeta), # gt proxy beta
                                       type = "b")

# pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-5_mob_k15_scRNAseqProxy_betaCor_combined_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

```

# SL MOB Ref and Train

```{r}

data(mOB)
cd <- mOB$counts

countsClean <- MERINGUE::cleanCounts(counts = t(cd),
                                       min.reads = 100,
                                       min.lib.size = 100,
                                       plot=TRUE,
                                       verbose=TRUE)

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

mob_se_wt <- mob_se[,wt_cells]

meta.data.wt <-  mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]


mob_se_wt_obj <- CreateSeuratObject(counts = mob_se_wt, project = "mob_wt",
                                      meta.data = meta.data.wt)

# a lot of metadata info not being added...? try doing manually:
mob_se_wt_obj[["ClusterName"]] <- meta.data.wt$ClusterName
mob_se_wt_obj[["percent.mito"]] <- meta.data.wt$percent.mito

# Set the known clusters as the "active.indent"
Seurat::Idents(object = mob_se_wt_obj) <- mob_se_wt_obj@meta.data$ClusterName

# get cluster markers
cluster_markers_mob_se_wt <- Seurat::FindAllMarkers(object = mob_se_wt_obj,
                                              assay = "RNA",
                                              slot = "data",
                                              verbose = TRUE,
                                              only.pos = TRUE)

# down samples cell from each cluster and select genes marker and variable genes
se_sc_down_wt <- downsample_se_obj(se_obj = mob_se_wt_obj,
                                clust_vr = "ClusterName",
                                cluster_markers = cluster_markers_mob_se_wt,
                                cl_n = 100, # size to sample from each cluster
                                hvg = 3000) # number or NULL. choose additional highly variable genes on top of cluster genes

# nmf_mod_mob_wt_countsClean_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt,
#                         se_sc = se_sc_down_wt,
#                         mtrx_spatial = t(countsClean), # the original mob st data
#                         clust_vr = "ClusterName",
#                         ntop = NULL, # number unique markers per cluster, otherwise all of them
#                         hvg = 3000, # number of highly variable genes in addition to the marker genes
#                         transf = "uv",
#                         method = "nsNMF")

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_ls.RData")
# nmf_mod_mob_wt_countsClean_ls
nmf_mod_mob_wt_countsClean_ls[[1]]

# 6336 genes kept of the cluster genes + 1000 variable genes that are also in cleanCounts ST data

```

```{r}

sl_countsClean <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_countsClean_ls, stCounts = t(countsClean))

```

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(38)

```

```{r}

m <- sl_countsClean$thetaCt # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- sl_countsClean$thetaCt
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# RCTD MOB Ref and Train

## reference

RCTD takes untransformed raw counts


```{r}

mob_se_wt_obj
# mob_se_wt_raw_obj_nOEC

# a lot of metadata info not being added...? try doing manually:
# mob_se_wt[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName
# mob_se_wt[["percent.mito"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$percent.mito
mob_se_wt_raw_obj[["nUMI"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$nUMI
mob_se_wt_raw_obj[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName

```

cluster markers using the raw counts

```{r}

Seurat::Idents(object = mob_se_wt_raw_obj) <- mob_se_wt_raw_obj@meta.data$ClusterName

cluster_markers_mob_se_wt_raw <- Seurat::FindAllMarkers(object = mob_se_wt_raw_obj,
                                              assay = "RNA",
                                              slot = "data",
                                              verbose = TRUE,
                                              only.pos = TRUE)

```



```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_ref/"

ref <- mob_se_wt_raw_obj

meta_ref <- ref@meta.data[,c("ClusterName", "nUMI")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$ClusterName),
                         Name = unique(ref@meta.data$ClusterName)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_ref/"
mob_scRNAseq_RCTD_reference <- dgeToSeurat(refdir)

```

## `countsClean` data

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_countsClean/"
# d <- countsClean
# 
# x <- as.data.frame(t(d))
# cols <- colnames(x)
# x$Row.names <- rownames(x)
# x <- x[,c("Row.names", cols)]
# write.table(x=x, sep = ",",
#             col.names = colnames(x),
#             row.names = FALSE,
#             file=paste0(p, "MappedDGEForR.csv"))
# 
# beads <- mobCorpus$mob$pos
# colnames(beads) <- c("xcoord", "ycoord")
# beads$barcodes <- rownames(beads)
# beads <- beads[,c("barcodes", "xcoord", "ycoord")]
# write.table(x=beads,
#             sep = ",",
#             row.names = FALSE,
#             file=paste0(p, "BeadLocationsForR.csv"))

write.csv(x=t(countsClean), file=paste0(p, "MappedDGEForR.csv"))
write.csv(x=mobCorpus$mob$pos, file=paste0(p, "BeadLocationsForR.csv"))

```

```{r}

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_countsClean/"
spatialRNA <- read.SpatialRNA(datadir)

```

## results

```{r}

RCTD_mob <- create.RCTD(spatialRNA,
                        mob_scRNAseq_RCTD_reference,
                        max_cores = 7, CELL_MIN_INSTANCE = 20)

RCTD_mob_fit <- run.RCTD(RCTD_mob, doublet_mode = TRUE)

RCTD_mob_results <- RCTD_mob_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_mob_results_norm <-  sweep(RCTD_mob_results$weights, 1, rowSums(RCTD_mob_results$weights), '/')

```

```{r}

dim(RCTD_mob_results_norm)

```

10 cell types not detected at all

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(28)

```

```{r}

m <- RCTD_mob_results_norm # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- RCTD_mob_results_norm
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# 1. Correlations between methods

```{r}

mob_k38$theta
sl_countsClean$thetaCt
RCTD_mob_results_norm

# Mural2 not present at all in SL so drop
sl_ctTheta <- sl_countsClean$thetaCt[,which(!colnames(sl_countsClean$thetaCt) %in% c("Mural2"))]

```

## LDA vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = sl_ctTheta,
                           m2 = mob_k38$theta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_vs_sl_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_vs_sl_ct_cors, breaks = 10)
mean(lda_vs_sl_ct_cors)
sd(lda_vs_sl_ct_cors)

```

## LDA vs RCTD

```{r}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = mob_k38$theta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_vs_rctd_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_vs_rctd_ct_cors, breaks = 10)
mean(lda_vs_rctd_ct_cors)
sd(lda_vs_rctd_ct_cors)

```

## RCTD vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = sl_ctTheta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_vs_sl_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_vs_sl_ct_cors, breaks = 10)
mean(rctd_vs_sl_ct_cors)
sd(rctd_vs_sl_ct_cors)

```

## LDA topic-clusters

### vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = mob_k38$thetaCombn,
                           m2 = sl_ctTheta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_clusters_vs_sl_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_clusters_vs_sl_ct_cors, breaks = 10)
mean(lda_clusters_vs_sl_ct_cors)
sd(lda_clusters_vs_sl_ct_cors)

```

### vs RCTD

```{r}

thetaCorMtx <- getCorrMtx(m1 = mob_k38$thetaCombn,
                           m2 = as.matrix(RCTD_mob_results_norm),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_clusters_vs_rctd_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_clusters_vs_rctd_ct_cors, breaks = 10)
mean(lda_clusters_vs_rctd_ct_cors)
sd(lda_clusters_vs_rctd_ct_cors)

```

## LDA K=15 model

RCTD and SL used same reference but different cts detected from each. For example, RCTD detected 28 and SL detected 37. So let's compare each method by their own strategy, i.e. LDA via finding and optimal K instead of presetting to 38

### vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = mob_k15$theta,
                           m2 = sl_ctTheta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k15_vs_sl_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k15_vs_sl_ct_cors, breaks = 10)
mean(lda_k15_vs_sl_ct_cors)
sd(lda_k15_vs_sl_ct_cors)

```

### vs RCTD

```{r}

thetaCorMtx <- getCorrMtx(m1 = mob_k15$theta,
                           m2 = as.matrix(RCTD_mob_results_norm),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_k15_vs_rctd_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_k15_vs_rctd_ct_cors, breaks = 10)
mean(lda_k15_vs_rctd_ct_cors)
sd(lda_k15_vs_rctd_ct_cors)

```

## SL and RCTD same cts

```{r}

# mob_k38$theta
# sl_countsClean$thetaCt
# RCTD_mob_results_norm
# 
# # Mural2 not present at all in SL so drop
# sl_ctTheta <- sl_countsClean$thetaCt[,which(!colnames(sl_countsClean$thetaCt) %in% c("Mural2"))]

sl_ctTheta_samects <- sl_ctTheta[,which(colnames(sl_ctTheta) %in% colnames(RCTD_mob_results_norm))]

```

## LDA vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = sl_ctTheta_samects,
                           m2 = mob_k38$theta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
lda_vs_slsame_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(lda_vs_slsame_ct_cors, breaks = 10)
mean(lda_vs_slsame_ct_cors)
sd(lda_vs_slsame_ct_cors)

```

## RCTD vs SL

```{r}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = sl_ctTheta_samects,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
rctd_vs_slsame_ct_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(rctd_vs_slsame_ct_cors, breaks = 10)
mean(rctd_vs_slsame_ct_cors)
sd(rctd_vs_slsame_ct_cors)

```

## summarize

```{r}

cor_mob_summary <- list("STdev vs SL" = lda_vs_sl_ct_cors,
                        "STdev vs RCTD" = lda_vs_rctd_ct_cors,
                        "RCTD vs SL" = rctd_vs_sl_ct_cors,
                        "STdev clusters vs SL" = lda_clusters_vs_sl_ct_cors,
                        "STdev clusters vs RCTD" = lda_clusters_vs_rctd_ct_cors,
                        "STdev k=15 vs SL" = lda_k15_vs_sl_ct_cors,
                        "STdev k=15 vs RCTD" = lda_k15_vs_rctd_ct_cors,
                        "STdev vs SL (28cts)" = lda_vs_slsame_ct_cors,
                        "RCTD vs SL (same cts)" = rctd_vs_slsame_ct_cors)

# reshape2::melt(plyr::ldply(cor_mob_summary, rbind))

# my_comparisons <- list( c("lda_vs_sl", "lda_vs_rctd"), c("lda_vs_rctd", "sl_vs_rctd"), c("lda_vs_sl", "sl_vs_rctd") )

# `plyr::ldply` combines vectors in list of different lenghts into dataframe
# then `reshape2::melt` into long form dataframe for ggplot

ggplot(data = reshape2::melt(plyr::ldply(cor_mob_summary, rbind)), 
       aes(x=.id, y=value, fill=.id)) +
  geom_boxplot() + 
  # stat_compare_means(comparisons = my_comparisons, method = "wilcox.test",
  #                    label.y = c(1.02, 1.09, 1.19)) +
  geom_point(position=position_jitterdodge()) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  labs(title = "Correlations between best matched predicted cell types",
       x = "Method", y = "Correlation")

```

# 2. poorly correlated cts

## RCTD vs SL

```{r}

# bottom 3
bottom <- order(rctd_vs_sl_ct_cors, decreasing = FALSE)[1:3]
print(rctd_vs_sl_ct_cors[bottom])

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = sl_ctTheta,
                           type = "t")
pairs <- lsatPairs(thetaCorMtx)
thetaCorMtx[pairs$rowix[bottom], pairs$colsix[bottom]]

```

are these predicted to be a very low amounts?

## RCTD vs SL (same cts)

```{r}

# bottom 3
bottom <- order(rctd_vs_slsame_ct_cors, decreasing = FALSE)[1:3]
print(rctd_vs_slsame_ct_cors[bottom])

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = sl_ctTheta_samects,
                           type = "t")
pairs <- lsatPairs(thetaCorMtx)
thetaCorMtx[pairs$rowix[bottom], pairs$colsix[bottom]]

```

## LDA vs RCTD

```{r}

# bottom 3
bottom <- order(lda_vs_rctd_ct_cors, decreasing = FALSE)[1:3]
print(lda_vs_rctd_ct_cors[bottom])

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_mob_results_norm),
                           m2 = mob_k38$theta,
                           type = "t")
pairs <- lsatPairs(thetaCorMtx)
thetaCorMtx[pairs$rowix[bottom], pairs$colsix[bottom]]

```

## LDA vs SL

```{r}

# bottom 3
bottom <- order(lda_vs_sl_ct_cors, decreasing = FALSE)[1:3]
print(lda_vs_sl_ct_cors[bottom])

thetaCorMtx <- getCorrMtx(m1 = sl_ctTheta,
                           m2 = mob_k38$theta,
                           type = "t")
pairs <- lsatPairs(thetaCorMtx)
thetaCorMtx[pairs$rowix[bottom], pairs$colsix[bottom]]

```

# ---------
# E - Remove OECs

Show N2s for SL and RCTD

## SL

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_noOECs_ls.RData")
# nmf_mod_mob_wt_countsClean_noOECs_ls

```

```{r}

sl_countsClean_noOEC <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_countsClean_noOECs_ls, stCounts = t(countsClean))

```

### viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(33)

```

```{r}

m <- sl_countsClean_noOEC$thetaCt # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- sl_countsClean_noOEC$thetaCt
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## RCTD

## reference

RCTD takes untransformed raw counts

```{r}

cts <- unique(mob_se_wt_raw_obj@meta.data$ClusterName)
cts <- cts[which(!cts %in% c("OEC1", "OEC2", "OEC3", "OEC4", "OEC5"))]

mob_se_wt_raw_obj_nOEC <- subset(mob_se_wt_raw_obj, subset = (ClusterName %in% cts))

```

```{r}

# mob_se_wt_obj
mob_se_wt_raw_obj_nOEC

# a lot of metadata info not being added...? try doing manually:
# mob_se_wt[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName
# mob_se_wt[["percent.mito"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$percent.mito
# mob_se_wt_raw_obj[["nUMI"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$nUMI
# mob_se_wt_raw_obj[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName

```

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_noOEC_ref/"

ref <- mob_se_wt_raw_obj_nOEC

meta_ref <- ref@meta.data[,c("ClusterName", "nUMI")]
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts))
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$ClusterName),
                         Name = unique(ref@meta.data$ClusterName)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_noOEC_ref/"
mob_scRNAseq_noOEC_RCTD_reference <- dgeToSeurat(refdir)

dim(mob_scRNAseq_noOEC_RCTD_reference@assays$RNA@counts)

```

### results

```{r}

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_countsClean/"
spatialRNA <- read.SpatialRNA(datadir)

RCTD_noOEC <- create.RCTD(spatialRNA,
                          mob_scRNAseq_noOEC_RCTD_reference,
                          max_cores = 7, CELL_MIN_INSTANCE = 20)

RCTD_noOEC_fit <- run.RCTD(RCTD_noOEC, doublet_mode = TRUE)

RCTD_noOEC_results <- RCTD_noOEC_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_mob_noOEC_results_norm <-  sweep(RCTD_noOEC_results$weights, 1, rowSums(RCTD_noOEC_results$weights), '/')

```

### viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(33)

```

```{r}

m <- RCTD_mob_noOEC_results_norm # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- RCTD_mob_noOEC_results_norm
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# 1. change in proportions

```{r}

# Mural2 not present at all in SL so drop
sl_ctTheta <- sl_countsClean$thetaCt[,which(!colnames(sl_countsClean$thetaCt) %in% c("Mural2"))]

```

## SL

```{r, fig.height=8, fig.width=10}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                         m2 = sl_ctTheta,
                         type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11))
# dev.off()

```

OECs correlate with the Olfactory Nerve Layer. N2 correlates with Granule Cell Layer.

```{r}

m <- sl_ctTheta[,c("OEC1","OEC2","OEC3","OEC4","OEC5", "N2")]
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)

# make OECs the same cluster/level
cc_OECs <- c("#FF0000", "#FF0000", "#FF0000", "#FF0000", "#FF0000", "#FF00FF")
names(cc_OECs) <- c("OEC1","OEC2","OEC3","OEC4","OEC5", "N2")
cc_OECs <- as.factor(cc_OECs)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc_OECs,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)


```

Removal of OECs:

```{r, fig.height=8, fig.width=10}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                         m2 = sl_countsClean_noOEC$thetaCt,
                         type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11))
# dev.off()

```

OECs correlate with the Olfactory Nerve Layer. N2 correlates with Granule Cell Layer.

```{r}

m <- sl_countsClean_noOEC$thetaCt
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)

# make OECs the same cluster/level
# cc_OECs <- c("#FF0000", "#FF0000", "#FF0000", "#FF0000", "#FF0000", "#FF00FF")
# names(cc_OECs) <- c("OEC1","OEC2","OEC3","OEC4","OEC5", "N2")
# cc_OECs <- as.factor(cc_OECs)
# 
# vizTopicClusters(theta = m,
#                  pos = p,
#                  clusters = cc_OECs,
#                  sharedCol = TRUE,
#                  groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
#                  group_cols = c("0" = "white", "1" = "black"),
#                  r = 0.4, # different size piecharts for mOB data sets
#                  lwd = 0.3,
#                  showLegend = TRUE,
#                  plotTitle = NA)


```

Proportional change:


 Just the olfactory nerve layer
```{r, fig.height=12, fig.width=12}

spots <- rownames(mobProxyTheta[which(mobProxyTheta$`Olfactory Nerve Layer` == 1),])

sl_theta_olfNerve <- as.data.frame(sl_countsClean$thetaCt[spots,])
# sl_noOEC_theta_allCts
sl_theta_olfNerve$ref <- "all cts"

sl_noOEC_theta_olfNerve <- as.data.frame(sl_countsClean_noOEC$thetaCt[spots,])
sl_noOEC_theta_olfNerve$ref <- "no OECs"

# make sure same columns
sharedCols <- intersect(colnames(sl_theta_olfNerve), colnames(sl_noOEC_theta_olfNerve))

sl_theta_olfNerve_merged <- rbind(sl_theta_olfNerve[,sharedCols], sl_noOEC_theta_olfNerve[,sharedCols])

ggplot(data = reshape2::melt(sl_theta_olfNerve_merged), aes(x = ref, y = value, fill = ref)) +
  geom_boxplot(outlier.shape=NA) +
  facet_wrap(~variable) +
  # stat_compare_means(method = "wilcox.test", label.y = c(0.31), size=3) +
  geom_point(position=position_jitterdodge(), alpha = 0.3, size = 0.5) +
  theme_classic()

```

all spots
```{r, fig.height=12, fig.width=12}

spots <- rownames(mobProxyTheta)

sl_theta_olfNerve <- as.data.frame(sl_countsClean$thetaCt[spots,])
# sl_noOEC_theta_allCts
sl_theta_olfNerve$ref <- "all cts"

sl_noOEC_theta_olfNerve <- as.data.frame(sl_countsClean_noOEC$thetaCt[spots,])
sl_noOEC_theta_olfNerve$ref <- "no OECs"

# make sure same columns
sharedCols <- intersect(colnames(sl_theta_olfNerve), colnames(sl_noOEC_theta_olfNerve))

sl_theta_olfNerve_merged <- rbind(sl_theta_olfNerve[,sharedCols], sl_noOEC_theta_olfNerve[,sharedCols])

ggplot(data = reshape2::melt(sl_theta_olfNerve_merged), aes(x = ref, y = value, fill = ref)) +
  geom_boxplot(outlier.shape=NA) +
  facet_wrap(~variable) +
  stat_compare_means(method = "wilcox.test", label.y = c(0.31), size=3) +
  geom_point(position=position_jitterdodge(), alpha = 0.3, size = 0.5) +
  theme_classic()

```

N2 one of the few that actually changes and has by far the most significant and largest change. This may be an important detail to mention to help transition.


In the original predictions, is N2 and OECs similar transcriptionally (via the W matrix from SL?)

## ** Transcriptional similarities **

beta self correlation

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = sl_countsClean$betaCt,
                         m2 = sl_countsClean$betaCt, # gt made from cells in bregma
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

N2 has a "higher" correlation with OEC1/2 than other cts, so make sense it would be assigned there.

then also the original scRNAseq clusters

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                         m2 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

heatmap(x = betaCorMtx)

```

Something to think about:
Here is the average gexp for each cluster of the mobWtCellProxyBeta computed from mob_se_wt cells.
Then above that is the W values, which are trained weights learned from the exp of the cluster genes (6336). Clearly, the W matrix is capturing more variation to separate the clusters based on the weights. So the weights are definitely not gexp values. But do represent how a given gene represents a cluster. The dendrogram clustering of the cell types is maintained between each pretty well, with some small differences. If I adjust the relationship above to visualize better..?

If I correlate the W and the "proxyBeta":

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = sl_countsClean$betaCt,
                         m2 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.9,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

# heatmap(x = betaCorMtx)

```

The paired cts from the scRNAseq and the W values are the same, so the weights of the genes for a cell type also corresponds or correlates well with the actual average gene expression of the cluster. Not perfect correlation, but strong. 

A thought: The average gene expression is from the processed values of the scRNAseq data. Are these log? Maybe should unlog first before averaging into clusters for the proxyBeta? But I think for input into SL or RCTD ok? Double check.. Also are they CPM normalized?

## RCTD

```{r, fig.height=8, fig.width=10}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                         m2 = as.matrix(RCTD_mob_results_norm),
                         type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11))
# dev.off()

```

OECs correspond to Olfactory Nerve Layer.
N2s not even detected

```{r}

m <- as.matrix(RCTD_mob_results_norm)[,c("OEC1","OEC2","OEC3","OEC4","OEC5", "N11", "N5", "N10")]
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)

# make OECs the same cluster/level
cc_OECs <- c("#FF0000", "#FF0000", "#FF0000", "#FF0000", "#FF0000", "#00E8FF", "#B900FF")
names(cc_OECs) <- c("OEC1","OEC2","OEC3","OEC4","OEC5", "N11", "N5")
cc_OECs <- as.factor(cc_OECs)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc_OECs,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)


```

Removal of OECs:

```{r, fig.height=8, fig.width=10}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(mobProxyTheta),
                         m2 = as.matrix(RCTD_mob_noOEC_results_norm),
                         type = "t")

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,11)) # margins for labels
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-3_mob_k15_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Predicted topics",
                  ylab = "Cell layer",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 1,
                  # lhei = c(1,3),
                  margins = c(6,11))
# dev.off()

```

Now N2 pops up and correlates strongly with Olf Nerve Layer

```{r}

m <- as.matrix(RCTD_mob_noOEC_results_norm)
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)

# make OECs the same cluster/level
cc_OECs <- c("#FF00FF", "#00E8FF", "#B900FF")
names(cc_OECs) <- c("N2", "N11", "N5")
cc_OECs <- as.factor(cc_OECs)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc_OECs,
                 sharedCol = TRUE,
                 groups = as.character(mobProxyTheta$`Olfactory Nerve Layer`),
                 group_cols = c("0" = "white", "1" = "black"),
                 r = 0.4, # different size piecharts for mOB data sets
                 lwd = 0.3,
                 showLegend = TRUE,
                 plotTitle = NA)


```

Proportional change:

 Just the olfactory nerve layer
```{r, fig.height=12, fig.width=12}

spots <- rownames(mobProxyTheta[which(mobProxyTheta$`Olfactory Nerve Layer` == 1),])

rctd_theta_olfNerve <- as.data.frame(RCTD_mob_results_norm[spots,])
# sl_noOEC_theta_allCts
rctd_theta_olfNerve$ref <- "all cts"

# no N2 in RCTD_mob_results_norm so add with 0s
rctd_theta_olfNerve$N2 <- rep(0, length(spots))

rctd_noOEC_theta_olfNerve <- as.data.frame(RCTD_mob_noOEC_results_norm[spots,])
rctd_noOEC_theta_olfNerve$ref <- "no OECs"

# make sure same columns
sharedCols <- intersect(colnames(rctd_theta_olfNerve), colnames(rctd_noOEC_theta_olfNerve))

rctd_theta_olfNerve_merged <- rbind(rctd_theta_olfNerve[,sharedCols], rctd_noOEC_theta_olfNerve[,sharedCols])

ggplot(data = reshape2::melt(rctd_theta_olfNerve_merged), aes(x = ref, y = value, fill = ref)) +
  geom_boxplot(outlier.shape=NA) +
  facet_wrap(~variable) +
  stat_compare_means(method = "wilcox.test", label.y = c(0.31), size=3) +
  geom_point(position=position_jitterdodge(), alpha = 0.3, size = 0.5) +
  theme_classic()

```

all spots
```{r, fig.height=12, fig.width=12}

spots <- rownames(mobProxyTheta)

rctd_theta_olfNerve <- as.data.frame(RCTD_mob_results_norm[spots,])
# sl_noOEC_theta_allCts
rctd_theta_olfNerve$ref <- "all cts"

# no N2 in RCTD_mob_results_norm so add with 0s
rctd_theta_olfNerve$N2 <- rep(0, length(spots))

rctd_noOEC_theta_olfNerve <- as.data.frame(RCTD_mob_noOEC_results_norm[spots,])
rctd_noOEC_theta_olfNerve$ref <- "no OECs"

# make sure same columns
sharedCols <- intersect(colnames(rctd_theta_olfNerve), colnames(rctd_noOEC_theta_olfNerve))

rctd_theta_olfNerve_merged <- rbind(rctd_theta_olfNerve[,sharedCols], rctd_noOEC_theta_olfNerve[,sharedCols])

ggplot(data = reshape2::melt(rctd_theta_olfNerve_merged), aes(x = ref, y = value, fill = ref)) +
  geom_boxplot(outlier.shape=NA) +
  facet_wrap(~variable) +
  stat_compare_means(method = "wilcox.test", label.y = c(0.31), size=3) +
  geom_point(position=position_jitterdodge(), alpha = 0.3, size = 0.5) +
  theme_classic()

```

N10 very much granule cell layer, but highly variable wrt predicted proportions across spots.

# 2. gexp cluster markers


Get genes with significant differential genes determined used the raw scRNAseq counts, too.
See if similar to the processed

```{r}

N2_seurat_genes <- cluster_markers_mob_se_wt_raw[which(cluster_markers_mob_se_wt_raw$cluster == "N2"),]
N2_seurat_genes

```

```{r}

# order by p-val
N2_seurat_genes[order(N2_seurat_genes$p_val_adj, decreasing = FALSE),]

# order by avg_log2FC (fold change in group compared to all other groups)
N2_seurat_genes[order(N2_seurat_genes$avg_log2FC, decreasing = TRUE),]

# get top 5 based on fold change (also significant)
top5_n2 <- N2_seurat_genes[order(N2_seurat_genes$avg_log2FC, decreasing = TRUE),]$gene[1:5]

```

N2

Seurat cluster dif genes

```{r}

N2_seurat_genes <- cluster_markers_mob_se_wt[which(cluster_markers_mob_se_wt$cluster == "N2"),]
N2_seurat_genes

```

```{r}

# order by p-val
N2_seurat_genes[order(N2_seurat_genes$p_val_adj, decreasing = FALSE),]

# order by avg_log2FC (fold change in group compared to all other groups)
N2_seurat_genes[order(N2_seurat_genes$avg_log2FC, decreasing = TRUE),]

# get top 5 based on fold change (also significant)
top5_n2 <- N2_seurat_genes[order(N2_seurat_genes$avg_log2FC, decreasing = TRUE),]$gene[1:5]

```

```{r}

# View these in the ST data using the `countsClean`
N2genes <- intersect(colnames(countsClean), top5_n2)
genecounts <- countsClean[,N2genes]
mobExp <- merge(mobCorpus$mob$pos, as.data.frame(genecounts), by=0)
rownames(mobExp) <- mobExp$Row.names
mobExp <- mobExp[,2:ncol(mobExp)]

group_cols <- c("0" = "white", "1" = "black")

# ---------------------------------------------------------------------------

for (gene in N2genes) {
  mainTitle <- paste0("N2 seurat marker: ", gene)
  vizGeneCounts(df = mobExp,
                gene = gene,
                # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
                # group_cols = c("0" = "white", "1" = "white"),
                # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
                stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
                plotTitle = mainTitle,
                showLegend = TRUE)
  # ggsave(filename = "Fig1_F-3_mob_k15_clust6_granule_Tubb2b.pdf",
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
}

for (gene in N2genes) {
  mainTitle <- paste0("N2 seurat marker: ", gene)
  vizGeneCounts(df = mobExp,
                gene = gene,
                # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
                # group_cols = c("0" = "white", "1" = "white"),
                size = (mobProxyTheta$`Olfactory Nerve Layer` + 0.5) * 5,
                stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
                plotTitle = mainTitle,
                showLegend = TRUE)
  # ggsave(filename = "Fig1_F-3_mob_k15_clust6_granule_Tubb2b.pdf",
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
}

```

W marker genes

```{r}

# top genes in beta matrix for N2 ct
sl_countsClean$betaCt["N2",order(sl_countsClean$betaCt["N2",], decreasing = TRUE)[1:10]]

sl_countsClean$ctTopicProps[order(sl_countsClean$ctTopicProps[,"N2"], decreasing = TRUE), "N2"]

# N2 composed of Topic_16 and Topic_33 primarily
sl_countsClean$betaTopics["Topic_16",order(sl_countsClean$betaTopics["Topic_16",], decreasing = TRUE)[1:10]]
sl_countsClean$betaTopics["Topic_33",order(sl_countsClean$betaTopics["Topic_33",], decreasing = TRUE)[1:10]]

# top genes in beta matrix for N2 ct
# sl_countsClean$betaCt["N2",order(sl_countsClean$betaCt["N2",], decreasing = TRUE)[1:10]]

```

so also "Sox11", "Igfbpl1", "Sox4" top genes


Also, LDA topic 17 corresponds to N2 the best in terms of beta. And 17 falls in granule cell layer center...

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = sl_countsClean$betaCt,
                           m2 = mob_k38$beta,
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_gt_cors, breaks = 10)
mean(paired_gt_cors)
sd(paired_gt_cors)

```

# -------------
# F - MOB Cortex

Compare to the mob scRNAseq reference to be considered as ground truth

So for SL or RCTD, compare the cortex predictions to the mob scRNAseq predictions (wrt beta and theta)

Also correlate the two scRNAseq refs to see which cell types relate the most transcriptionally

## SL

```{r}

path_to_data <- system.file(package = "SPOTlight")
cortex_sc <- readRDS(glue::glue("{path_to_data}/allen_cortex_dwn.rds"))

```

```{r}

set.seed(123)
cortex_sc <- Seurat::SCTransform(cortex_sc, verbose = FALSE)

```

```{r}

Seurat::Idents(object = cortex_sc) <- cortex_sc_sct@meta.data$subclass
cortex_cluster_markers <- Seurat::FindAllMarkers(object = cortex_sc, 
                                              assay = "SCT",
                                              slot = "data",
                                              verbose = TRUE, 
                                              only.pos = TRUE)

```

"proxyBeta" for cortex

```{r}

# normalized and log transformed data via `Seurat::SCTransform`
# cortex_sc@assays$SCT@data 

# clusters
cortexClusters <- cortex_sc@meta.data$subclass
names(cortexClusters) <- rownames(cortex_sc@meta.data)

cortexProxyBeta <- model.matrix(~ 0 + as.factor(cortexClusters))

rownames(cortexProxyBeta) <- names(cortexClusters)

# fix names
colnames(cortexProxyBeta) <- unlist(lapply(colnames(cortexProxyBeta), function(x) {
  unlist(strsplit(x, ")"))[2]
}))

cortexProxyBeta <- t(as.matrix(cortex_sc@assays$SCT@data) %*% cortexProxyBeta)

cortexProxyBeta <- cortexProxyBeta/rowSums(cortexProxyBeta)

dim(cortexProxyBeta)

```

With raw counts:

```{r}

# cortex_sc@assays$RNA@counts 

# clusters
cortexClusters <- cortex_sc@meta.data$subclass
names(cortexClusters) <- rownames(cortex_sc@meta.data)

cortexProxyBetaRaw <- model.matrix(~ 0 + as.factor(cortexClusters))

rownames(cortexProxyBetaRaw) <- names(cortexClusters)

# fix names
colnames(cortexProxyBetaRaw) <- unlist(lapply(colnames(cortexProxyBetaRaw), function(x) {
  unlist(strsplit(x, ")"))[2]
}))

cortexProxyBetaRaw <- t(as.matrix(cortex_sc@assays$RNA@counts) %*% cortexProxyBetaRaw)

# filter out genes to make same as cortexProxyBeta
cortexProxyBetaRaw <- cortexProxyBetaRaw[,colnames(cortexProxyBeta)]

cortexProxyBetaRaw <- cortexProxyBetaRaw/rowSums(cortexProxyBetaRaw)

dim(cortexProxyBetaRaw)

```

note that additional filtering and transformations also when performing SCTransform

```{r}

plot(cortexProxyBetaRaw, cortexProxyBeta)

```



```{r}

# save(cortex_sc, cortex_cluster_markers,
#      file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/sl_cortex_sc_and_markers.RData")

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/sl_cortex_sc_and_markers.RData")
# cortex_sc
# cortex_cluster_markers

```

```{r}

# set.seed(123)
# 
# sl_cortexRef_countsClean_ls <- spotlight_deconvolution(
#   se_sc = cortex_sc,
#   counts_spatial = t(countsClean),
#   clust_vr = "subclass", # Variable in sc_seu containing the cell-type annotation
#   cluster_markers = cortex_cluster_markers, # Dataframe with the marker genes
#   cl_n = 100, # number of cells per cell type to use
#   hvg = 3000, # Number of HVG to use
#   ntop = NULL, # How many of the marker genes to use (by default all)
#   transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
#   method = "nsNMF", # Factorization method
#   min_cont = 0 # Remove those cells contributing to a spot below a certain threshold 
#   )

```

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/sl_cortexRef_countsClean_ls.RData")
# sl_cortexRef_countsClean_ls

# ran `spotlight_deconvolution()` instead of `train_nmf()
# so first value in list is actually the nmf_mod_ls, and the second is the decon_mtx

```

```{r}

sl_countsClean_cortexRef <- SPOTlightPredict(nmfRef = sl_cortexRef_countsClean_ls[[1]], stCounts = t(countsClean))

```

### viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(23)

```

```{r}

m <- sl_countsClean_cortexRef$thetaCt # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- sl_countsClean_cortexRef$thetaCt
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

## RCTD

### reference

need to start from raw count data

```{r}

p <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/cortex_ref/"

ref <- cortex_sc

meta_ref <- ref@meta.data[,c("subclass", "nCount_RNA")] # nUMI = nCount_RNA
meta_ref$barcode <- rownames(meta_ref)
colnames(meta_ref) <- c("cluster", "nUMI", "barcode")
meta_ref <- meta_ref[,c("barcode", "cluster", "nUMI")]
write.csv(x=meta_ref, row.names = FALSE, file=paste0(p, "meta_data.csv"))


x <- as.data.frame(as.matrix(ref@assays$RNA@counts)) # make sure set to raw counts
cols <- colnames(x)
x$Row.names <- rownames(x)
x <- x[,c("Row.names", cols)]
write.table(x=x, sep = ",",
            col.names = colnames(x),
            row.names = FALSE,
            file=paste0(p, "dge.csv"))

# write.table(x=ref@assays$RNA@counts,
#             sep = ",",
#             col.names = colnames(ref@assays$RNA@counts),
#             file=paste0(p, "dge.csv"))

write.csv(x = data.frame(Cluster = unique(ref@meta.data$subclass),
                         Name = unique(ref@meta.data$subclass)),
          row.names = FALSE,
          file = paste0(p, "cell_type_dict.csv"))

```

``` {r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/cortex_ref/"
cortex_scRNAseq_RCTD_reference <- dgeToSeurat(refdir)

```

### results

```{r}

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/RCTD/mob_countsClean/"
spatialRNA <- read.SpatialRNA(datadir)

RCTD_cortex <- create.RCTD(spatialRNA,
                            cortex_scRNAseq_RCTD_reference,
                            max_cores = 7, CELL_MIN_INSTANCE = 7)

RCTD_cortex_fit <- run.RCTD(RCTD_cortex, doublet_mode = TRUE)

RCTD_cortexRef_results <- RCTD_cortex_fit@results
# normalize the cell type proportions to sum to 1.
RCTD_cortexRef_results_norm <-  sweep(RCTD_cortexRef_results$weights, 1, rowSums(RCTD_cortexRef_results$weights), '/')

```

### viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(23)

```

```{r}

m <- RCTD_cortexRef_results_norm # theta for the k=15 fitted LDA for mob data set
p <- mobCorpus$mob$pos # the positions of filtered spots for mob data set

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 0.4, # different size piecharts for mOB data sets
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA)
# ggsave(filename = "Fig1_E-1_mob_k15_predict.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

m <- RCTD_cortexRef_results_norm
p <- mobCorpus$mob$pos

cc <- as.factor(rainbow(ncol(m)))
names(cc) <- colnames(m)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = cc,
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 0.4,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = NA)

```

# 1. Comparisons

compare the cortex predictions to the mob scRNAseq predictions (wrt beta and theta). VLMC in OECs/olfactory nerve layers

## SL

```{r}

# L5.IT not present at all in SL so drop
sl_cortex_ctTheta <- sl_countsClean_cortexRef$thetaCt[,which(!colnames(sl_countsClean_cortexRef$thetaCt) %in% c("L5.IT"))]

```


### theta

```{r, fig.height=8, fig.width=8}

thetaCorMtx <- getCorrMtx(m1 = sl_cortex_ctTheta,
                           m2 = sl_ctTheta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

VLMC paired up with OEC1/2 and also Mes1 actually has highest corr wrt theta in mOB

### beta

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = sl_countsClean_cortexRef$betaCt,
                           m2 = sl_countsClean$betaCt,
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

VLMC closest to Mes1 transcriptionally

seurat markers for mob versus those for cortex

```{r, fig.height=8, fig.width=8}

# in terms of cluster genes for the mob and cortex cts
betaCorMtx <- getCorrMtx(m1 = cortexProxyBetaRaw[,colnames(sl_countsClean_cortexRef$betaCt)],
                         m2 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                         type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

heatmap(betaCorMtx)

```

transcriptionally, VLMC similar to Mes1 and OECs than to other cts

## RCTD

### theta

```{r, fig.height=8, fig.width=8}

thetaCorMtx <- getCorrMtx(m1 = as.matrix(RCTD_cortexRef_results_norm),
                           m2 = as.matrix(RCTD_mob_results_norm),
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

VLMC also assigned to Mes1 and OEC clusters


So transcirptionally correlated and thus likely to be assigned based on reference even if those cell types don't belong there.


## LDA

### beta

curious how the cortex scRNAseq ref corresponds to the beta of the topics

I suspect some correspondence between VLMC and the topics that are assigned to the Olfactory nerve layer

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = cortexProxyBetaRaw[,colnames(sl_countsClean_cortexRef$betaCt)],
                           m2 = mob_k38$beta,
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_gt_cors, breaks = 10)
mean(paired_gt_cors)
sd(paired_gt_cors)

```

The correlation is lower, which could be a good thing because shows how the cortex cell type clusters correlate less than the actual mob cell type references (although gene set is smaller and its cluster gexp versus beta weights)

with the mobscRNAseq

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = mobWtCellProxyBetaRaw,
                           m2 = mob_k38$beta,
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_gt_cors, breaks = 10)
mean(paired_gt_cors)
sd(paired_gt_cors)

```

correlation is higher for the actual mob, but probably not in a significant way

However, VLMC correlates best with 33, and here, best with Mes1..so actually there is some similarity. Makes sense though because the gene exp frequencies are what drives the topic assignment


Question is what is the real proportion of Mes1/2 cells versus the OEC cells in the tissue. The models are assigning OECs. Without them, N2 gets assigned. Without any of that, VLMC gets assigned which has some similarity to Mes1. Mes1 has some similarity to OECs I believe. So it all makes sense but definitely the reference predictions can change quite a bit and not make biological sense even if there is some similarity transcriptionally.

Actually Mes1/2 is only slightly similar transcriptionally to the OECs...

```{r, fig.height=8, fig.width=8}

# reduce set of genes to test correlation to the cluster ones


betaCorMtx <- getCorrMtx(m1 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                           m2 = mobWtCellProxyBetaRaw[,colnames(sl_countsClean$betaCt)],
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_gt_cors, breaks = 10)
mean(paired_gt_cors)
sd(paired_gt_cors)

heatmap(betaCorMtx)

```

```{r, fig.height=8, fig.width=8}

# reduce set of genes to test correlation to the cluster ones


betaCorMtx <- getCorrMtx(m1 = cortexProxyBetaRaw[,colnames(sl_countsClean_cortexRef$betaCt)],
                           m2 = cortexProxyBetaRaw[,colnames(sl_countsClean_cortexRef$betaCt)],
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-5_FN7_k8_mjrcts_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_gt_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_gt_cors, breaks = 10)
mean(paired_gt_cors)
sd(paired_gt_cors)

```

# =========================

# Figure 3

# Breast ST

Question: what is known about the patient, and the histology and pathology of this particular sample? Has the tissue been annotated by a pathologist?

Use the MERIGNUE BCL data already available

```{r}

data(BCL)
# 4 layers, 1031 total spots.

bcl_pos <- BCL$pos[,1:2]
bcl_slice <- BCL$pos[,3]
names(bcl_slice) <- rownames(bcl_pos)

# clean
bcl_countsClean <- MERINGUE::cleanCounts(counts = BCL$counts, # genes x spots mtx
                                        min.reads = 10,
                                        min.lib.size = 10,
                                        verbose=TRUE)

bcl_CPM <- MERINGUE::normalizeCounts(counts = bcl_countsClean,
                                          verbose=TRUE, log=FALSE)

```

# LDA

One thing to realize is that for LDA need to reduce down the gene set to most OD genes and more variable, really to capture as much variation as possible while reducing size of corpus.

FOr other methods, use a reference, and then the corpus they are trained on uses the countsClean genes. So these models are seeing a lot more genes so assign cts than LDA is.

**Is it worth retraining the other models on just the genes in the corpus used to train LDA? Or consider this gene set reduction as part of the process of LDA?**


Consider all 4 slices as part of same corpus

But first, for genes, consider those that are overdispersed in all slices separately

```{r}

# list of either the mob data sets or paths to the data for inputs into `preprocess`

bcl_paths <- list()
bcl_paths[[1]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 1])]))
bcl_paths[[2]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 2])]))
bcl_paths[[3]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 3])]))
bcl_paths[[4]] <- as.matrix(t(BCL$counts[,names(bcl_slice[bcl_slice == 4])]))

```

```{r}

bclRepGenes <- lapply(bcl_paths, function(p) {
  dat <- preprocess(p,
                   alignFile = NA,
                   extractPos = FALSE,
                   selected.genes = NA,
                   nTopGenes = NA,
                   genes.to.remove = NA,
                   perc.spots = NA,
                   min.reads = 10,
                   min.lib.size = 10,
                   ODgenes = TRUE, # select the overdispersed genes
                   od.genes.alpha = 0.2,
                   gam.k = 5)
  colnames(dat$corpus)
})

commonBCLGenes <- Reduce(intersect, bclRepGenes)
length(commonBCLGenes)

```

Now select those common OD genes to build the entire corpus

```{r}

bclCorpus <- preprocess(t(as.matrix(BCL$counts)),
                       alignFile = NA,
                       extractPos = FALSE,
                       selected.genes = commonBCLGenes,
                       nTopGenes = NA,
                       genes.to.remove = NA,
                       perc.spots = NA,
                       min.reads = 10,
                       min.lib.size = 10,
                       ODgenes = FALSE,
                       od.genes.alpha = 0.05, # ODgenes ignored; so is this
                       gam.k = 5) # ODgenes ignored; so is this

# positions already included in `mOB$pos` but make sure only use the filtered positions in the corpus
bclCorpus$pos <- bcl_pos[rownames(bclCorpus$corpus), ]

```

corpus is 1029 total spots and 152 genes for the 4 slices combined

Fit LDA models

```{r}

# fit models to a range of K's that include 5 (5 original txn clusters) and
# 37 and 38 (for the cts in the scRNAseq refs; 38 originally but SL doesn't find and Meis2 so dropped)
ks <- seq(from = 2, to = 30, by = 1)

```

```{r}

pdf(file = paste0(fig_path, "Fig3_A-1_bcl_lda_fit.pdf"))
bcl_LDAs <- fitLDA(counts = bclCorpus$slm,
                        Ks = ks,
                        seed = 0,
                        ncores = 7,
                        plot = TRUE)
dev.off()

```

## k = 12 kOpt1 min

```{r}

bcl_k12 <- buildLDAobject(LDAmodel = optimalModel(bcl_LDAs, opt = "min"),
                      deepSplit = 4,
                      colorScheme = "rainbow")

```

## viz predictions

### individual topics

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(12)

```

```{r}

lapply(unique(as.vector(bcl_slice)), function(ix){
  
  spots <- names(bcl_slice[bcl_slice == ix])
  # bcl_slice still has all 1031 spots. Some removed during cleanCounts for corpus creation
  # so just get the spots that were kept
  shared_spots <- intersect(rownames(bcl_k12$theta), spots)
  
  m <- bcl_k12$theta[shared_spots,]
  p <- bclCorpus$pos[shared_spots,]

  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=rainbow(ncol(m)),
               groups = NA,
               group_cols = NA,
               r = 0.4, # different size piecharts for mOB data sets
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)
  # ggsave(filename = "Fig1_E-2_mob_k15_clusters_predict.pdf",
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})

```

### topic clusters

```{r}

set.seed(888) # for randomColorR

# consistent colors between plots for topics
colspace <- randomcoloR::distinctColorPalette(6)

```

```{r}

lapply(unique(as.vector(bcl_slice)), function(ix){
  
  spots <- names(bcl_slice[bcl_slice == ix])
  # bcl_slice still has all 1031 spots. Some removed during cleanCounts for corpus creation
  # so just get the spots that were kept
  shared_spots <- intersect(rownames(bcl_k12$thetaCombn), spots)
  
  m <- bcl_k12$thetaCombn[shared_spots,]
  p <- bclCorpus$pos[shared_spots,]

  vizAllTopics(theta = m,
               pos = p,
               topicOrder=seq(ncol(m)),
               topicCols=rainbow(ncol(m)),
               groups = NA,
               group_cols = NA,
               r = 0.4, # different size piecharts for mOB data sets
               lwd = 0.01,
               showLegend = TRUE,
               plotTitle = NA)
  # ggsave(filename = "Fig1_E-2_mob_k15_clusters_predict.pdf",
  #        device = "pdf",
  #        path = fig_path,
  #        scale = 1.5,
  #        width = 5,
  #        height = 4,
  #        units = c("in"),
  #        dpi = 600)
})

```

### topics separately

Visualize the individual topics and also the topic clusters separately

```{r}

x <- lapply(unique(as.vector(bcl_slice)), function(ix){
  
  spots <- names(bcl_slice[bcl_slice == ix])
  # bcl_slice still has all 1031 spots. Some removed during cleanCounts for corpus creation
  # so just get the spots that were kept
  shared_spots <- intersect(rownames(bcl_k12$theta), spots)
  
  m <- bcl_k12$theta[shared_spots,]
  p <- bclCorpus$pos[shared_spots,]

  cc <- as.factor(rainbow(ncol(m)))
  names(cc) <- colnames(m)
  
  vizTopicClusters(theta = m,
                   pos = p,
                   clusters = cc,
                   sharedCol = TRUE,
                   groups = NA,
                   group_cols = NA,
                   r = 0.4,
                   lwd = 0.01,
                   showLegend = TRUE,
                   plotTitle = as.character(ix))
})

```

### topic clusters separately

```{r}

# x <- lapply(unique(as.vector(bcl_slice)), function(ix){
x <- lapply(c(1), function(ix){
  
  spots <- names(bcl_slice[bcl_slice == ix])
  # bcl_slice still has all 1031 spots. Some removed during cleanCounts for corpus creation
  # so just get the spots that were kept
  shared_spots <- intersect(rownames(bcl_k12$thetaCombn), spots)
  
  m <- bcl_k12$thetaCombn[shared_spots,]
  p <- bclCorpus$pos[shared_spots,]

  vizTopicClusters(theta = m,
                   pos = p,
                   clusters = bcl_k12$clustCols,
                   sharedCol = TRUE,
                   groups = NA,
                   group_cols = NA,
                   r = 0.4,
                   lwd = 0.01,
                   showLegend = TRUE,
                   plotTitle = as.character(ix))
})

```

Check out the individual topics that make up each cluster

```{r}

x <- lapply(unique(as.vector(bcl_slice)), function(ix){
  
  spots <- names(bcl_slice[bcl_slice == ix])
  # bcl_slice still has all 1031 spots. Some removed during cleanCounts for corpus creation
  # so just get the spots that were kept
  shared_spots <- intersect(rownames(bcl_k12$theta), spots)
  
  m <- bcl_k12$theta[shared_spots,]
  p <- bclCorpus$pos[shared_spots,]

  vizTopicClusters(theta = m,
                   pos = p,
                   clusters = bcl_k12$cols,
                   sharedCol = FALSE,
                   groups = NA,
                   group_cols = NA,
                   r = 0.4,
                   lwd = 0.01,
                   showLegend = TRUE,
                   plotTitle = as.character(ix))
})

```

## Explore topic genes

```{r}

bcl_k12$clusters

```


```{r}

# topics 1 and 11 in cluster 3 (green)
bcl_k12$betaCombn[3, order(bcl_k12$betaCombn[3,], decreasing = TRUE)][1:5]
bcl_k12$beta[1, order(bcl_k12$beta[1,], decreasing = TRUE)][1:5]
bcl_k12$beta[11, order(bcl_k12$beta[11,], decreasing = TRUE)][1:5]

```

SPINT2: Kunitz-type protease inhibitor 2 is an enzyme inhibitor; This gene is a presumed tumor suppressor by inhibiting HGF activator which prevents the formation of active hepatocyte growth factor

RPN2: RPN2 has been demonstrated to be a prognostic marker of human cancer, and may be a potential target of clinical importance.

FN1: Fibronectin plays a major role in cell adhesion, growth, migration, and differentiation, and it is important for processes such as wound healing and embryonic development. Altered fibronectin expression, degradation, and organization has been associated with a number of pathologies, including cancer and fibrosis.

also CD24

This topic overlays well with the invasive section


```{r}

# topics 3 and 6 in cluster 5 (purple)
bcl_k12$betaCombn[5, order(bcl_k12$betaCombn[5,], decreasing = TRUE)][1:5]
bcl_k12$beta[3, order(bcl_k12$beta[3,], decreasing = TRUE)][1:5]
bcl_k12$beta[6, order(bcl_k12$beta[6,], decreasing = TRUE)][1:5]

```

FN1: Fibronectin plays a major role in cell adhesion, growth, migration, and differentiation, and it is important for processes such as wound healing and embryonic development. Altered fibronectin expression, degradation, and organization has been associated with a number of pathologies, including cancer and fibrosis.

IGLL5: Immunoglobulin lambda-like polypeptide 5; five-gene signature b-cell response; favorable outcome

JCHAIN: Joining chain of multimeric IgA and IgM; favorable outcome

IGFBP5: insulin-like growth factor binding protein 5; associated with metastasis in breast cancer

CCL21: C-C chemokine ligand 21/chemokine receptor 7 (CCL21/CCR7) pair promotes growth and metastasis of many tumor types including melanomas, breast, thyroid, colon, head, and neck cancers

This also overlays well with cancer section. 

```{r}

# topics 4 and 9 in cluster 4 (blue)
bcl_k12$betaCombn[4, order(bcl_k12$betaCombn[4,], decreasing = TRUE)][1:5]
bcl_k12$beta[4, order(bcl_k12$beta[4,], decreasing = TRUE)][1:5]
bcl_k12$beta[9, order(bcl_k12$beta[9,], decreasing = TRUE)][1:5]

```

PPP1R1B: Dopamine and cAMP regulated phosphoprotein 32 kDa (DARPP-32) also known as phosphoprotein phosphatase-1 regulatory subunit 1B and encoded by the PPP1R1B gene is an inhibitor of protein phosphatase-1 and protein kinase A. DARPP-32 is expressed in a wide range of epithelial cells and some solid tumours.

ERBB2: HER2; ErbB2 plays an important role in human malignancies. The erbB2 gene is amplified or overexpressed in approximately 30% of human breast cancers

LY6E: Lymphocyte antigen 6 complex, locus E (LY6E) has been implicated in the malignant progression of various types of cancers. LY6E as an activator of HIF-1 and revealed their mechanistic and functional links in malignant tumor growth. Ly6K/E in human breast cancer specimens correlates with poor overall survival, TGF- signalling ?

ENG: endoglin; ENG is selectively expressed on vascular and lymphatic endothelium in tumors. This allows us to target both tumor-associated vasculature and lymphatic vessels to suppress tumor growth and metastasis. ENG is essential for angiogenesis/vascular development and a co-receptor of TGF-

This cluster seems to overlay with the non-malignant tissue

```{r}

# topics 5, 7, and 10 in cluster 1 (red)
bcl_k12$betaCombn[1, order(bcl_k12$betaCombn[1,], decreasing = TRUE)][1:5]
bcl_k12$beta[5, order(bcl_k12$beta[5,], decreasing = TRUE)][1:5]
bcl_k12$beta[7, order(bcl_k12$beta[7,], decreasing = TRUE)][1:5]
bcl_k12$beta[10, order(bcl_k12$beta[10,], decreasing = TRUE)][1:5]

```

IFI6: G1P3, Interferon alpha-inducible protein 6, The encoded protein may play a critical role in the regulation of apoptosis. 

PRSS23: Serine Protease PRSS23 Is Upregulated by Estrogen Receptor  and Associated with Proliferation of Breast Cancer Cells

cluster 1 is kind of everywhere

```{r}

# topics 2, 8, and 12 in cluster 2 (yellow)
bcl_k12$betaCombn[2, order(bcl_k12$betaCombn[2,], decreasing = TRUE)][1:5]
bcl_k12$beta[8, order(bcl_k12$beta[8,], decreasing = TRUE)][1:5]
bcl_k12$beta[12, order(bcl_k12$beta[12,], decreasing = TRUE)][1:5]
bcl_k12$beta[2, order(bcl_k12$beta[2,], decreasing = TRUE)][1:5]

```

MGP: This gene encodes a member of the osteocalcin/matrix Gla family of proteins. The encoded vitamin K-dependent protein is secreted by chondrocytes and vascular smooth muscle cells, and functions as a physiological inhibitor of ectopic tissue calcification

CST4: par of the cystatin superfamily

KRT8: keratin 8; can be used to differentiate lobular carcinoma of the breast from ductal carcinoma of the breast.  In normal tissue, it reacts mainly with secretory epithelia, but not with squamous epithelium, such as that found in the skin, cervix, and esophagus. However, it also reacts with a range of malignant cells, including those derived from secretory epithelia, but also some squamous carcinomata, such as spindle cell carcinoma. It is considered useful in identifying microscopic metastases of breast carcinoma in lymph nodes, and in distinguishing Paget's disease from malignant melanoma. It also reacts with neuroendocrine tumors. **Luminal cell marker??**

FXYD3: upregulated in breast cancer tissues

XBP1: XBP1 promotes triple-negative breast cancer by controlling the HIF1 pathway

cluster 2 is also everywhere

# Txn clustering

In the original paper, 3 clusters ID:
- ductal carcinoma in situ
- invasive ductal carcinoma
- non-malignant

```{r}

# use the CPM adjusted counts and the common OD genes used in corpus for MOB

pcs.info <- prcomp(t(log10(as.matrix(bcl_CPM[commonBCLGenes,])+1)), center=TRUE)
plot(pcs.info$sdev[1:30])
nPcs <- 5
pcs <- pcs.info$x[,1:nPcs]
# 2D embedding by tSNE
emb <- Rtsne::Rtsne(pcs,
                    is_distance=FALSE,
                    perplexity=30,
                    num_threads=1,
                    verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)
# Graph-based cluster detection
k <- 300
bcl_com <- MERINGUE::getClusters(pcs, k, method=igraph::cluster_louvain)

par(mfrow=c(2,2), mar=rep(1,4))

# top row
# left: all slice spots tSNE embedding and labeled by cluster assignment
MUDAN::plotEmbedding(emb, groups=bcl_com,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: all slice spots tSNE embedding and labeled by tissuse slice assignment
MUDAN::plotEmbedding(emb, groups=bcl_slice,
                     show.legend=TRUE, xlab=NA, ylab=NA,
                     verbose=FALSE)

# bottom row
# left: spots labeld by cluster assignment and overlayed on each slice.
# Same clusters seem to be at similar spot locations on slices. Nice to see
MUDAN::plotEmbedding(bclCorpus$pos, groups=bcl_com,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)
# right: spots colored by slice and slices overlayed
MUDAN::plotEmbedding(bclCorpus$pos, groups=bcl_slice,
                     cex=1, xlab=NA, ylab=NA,
                     verbose=FALSE)


```

some additional filtering

```{r}

length(bcl_slice)

dim(bclCorpus$pos)

# filter spots in bcl_slice based on those kept in the corpus
bcl_slice_filt <- bcl_slice[names(bcl_slice) %in% rownames(bclCorpus$pos)]
length(bcl_slice_filt)

# `bcl_com` already filtered b/c used the `bcl_CPM`, which went through `MERINGUE::cleanCounts`
length(bcl_com)

```

# overlay spots 

overlay the txn cluster labeled spots on top of the H&E images

## BCL1

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer1_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer1_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==1,]

bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==1])]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# Flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# posScale[,"x"] <- posScale[,"x"]

# set the x and y to start at 0 again, after flipping
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale[,"x"] <- posScale[,"x"] + 1380
posScale[,"y"] <- posScale[,"y"] + 2669


# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com_slice), pch=16)


m <- bcl_k12$thetaCombn[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=topo.colors(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- topo.colors(5)
names(clustCols) <- colnames(bcl_k12$thetaCombn)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

```

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer1_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer1_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==1,]

bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==1])]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# Flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# posScale[,"x"] <- posScale[,"x"]

# set the x and y to start at 0 again, after flipping
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale[,"x"] <- posScale[,"x"] + 1380
posScale[,"y"] <- posScale[,"y"] + 2669


# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
# plot.new()
# plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 
# 
# # the point coords correspond to the mirror of the jpeg when plotted
# # first dim is the y, which we reverse to match spot
# # he[dim(he)[1]:1, , ]
# # but if the y is not reveresed, then the spots need to be rotated along the horizontal
# # to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# # posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# # take distance of spots from the center horizontal of the image, multiply by 2 then add
# rasterImage(he[, , ],
#             0, 0,
#             dim(he)[2], dim(he)[1])
# # points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# # points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com_slice), pch=16)


m <- bcl_k12$theta[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- rainbow(ncol(m))
names(clustCols) <- colnames(bcl_k12$theta)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

```

## BCL2 

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer2_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer2_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==2,]

bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==2])]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# final adjustments

# for image 2, the spots actually need to be rotated slightly to align properly with the tissue image
# based on the Stahl data spot coordinates, plot the base image and the spots rotated along the horizontal
# axis (similar strategy done above for he1). This is the alignment we want.
# Then, can take the range of the x and y coordinates for the Stahl plots.
# The difference between the min and max are how we can check that the rotation
# done below for this plot has the spots placed in the correct orientation (make sure the x and y range difs here match)
# it turns out that a rotation of 12 degrees looks pretty good

# so, first flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] # + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots by 12 degrees in radians
posScale <- MERINGUE::rotatePos(posScale, theta = -pi/(180/12))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 2010
posScale[,"y"] <- posScale[,"y"] + 2641


# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com_slice), pch=16)


m <- bcl_k12$thetaCombn[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- topo.colors(5)
names(clustCols) <- colnames(bcl_k12$thetaCombn)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)


m <- bcl_k12$theta[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- rainbow(ncol(m))
names(clustCols) <- colnames(bcl_k12$theta)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

```

## BCL 3

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer3_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer3_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==3,]
# posScale <- bcl_pos[grepl("L3-", rownames(bcl_pos)),] # all spots

bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==3])]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustments

# for image 3, need to flip the spots across a vertical axis

# flip spots
posScale[,"y"] <- posScale[,"y"] #+ 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots in radians
posScale <- MERINGUE::rotatePos(posScale, theta = pi/(180/32))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 1425
posScale[,"y"] <- posScale[,"y"] + 2902



# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com_slice), pch=16)


m <- bcl_k12$thetaCombn[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- topo.colors(5)
names(clustCols) <- colnames(bcl_k12$thetaCombn)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)


m <- bcl_k12$theta[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- rainbow(ncol(m))
names(clustCols) <- colnames(bcl_k12$theta)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

```

## BCL 4

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer4_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer4_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==4,]
# posScale <- bcl_pos[grepl("L3-", rownames(bcl_pos)),] # all spots

bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==4])]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustments

# for image 4, flip x-coords across vertical axis

# flip spots
# posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
posScale[,"x"] <- posScale[,"x"] + 2*((dim(he)[2]/2) - posScale[,"x"])

# then rotate the spots in radians
posScale <- MERINGUE::rotatePos(posScale, theta = pi/(180/5))

# now reset the x and y to start at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# and finally shift by the start of the x and y coordinates for the stahl points (flipped across horizontal)
posScale[,"x"] <- posScale[,"x"] + 2824
posScale[,"y"] <- posScale[,"y"] + 2033



# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com_slice), pch=16)


m <- bcl_k12$thetaCombn[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- topo.colors(5)
names(clustCols) <- colnames(bcl_k12$thetaCombn)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

m <- bcl_k12$theta[names(bcl_com_slice),]
p <- posScale # bclCorpus$pos[names(bcl_com_slice),]

vizAllTopics(theta = m,
             pos = p,
             topicOrder=seq(ncol(m)),
             topicCols=rainbow(ncol(m)),
             groups = NA,
             group_cols = NA,
             r = 100,
             lwd = 0.01,
             showLegend = TRUE,
             plotTitle = NA,
             overlay = he)

# clustCols <- RColorBrewer::brewer.pal(5, name = "Dark2")
clustCols <- rainbow(ncol(m))
names(clustCols) <- colnames(bcl_k12$theta)

vizTopicClusters(theta = m,
                 pos = p,
                 clusters = as.factor(clustCols),
                 sharedCol = TRUE,
                 groups = NA,
                 group_cols = NA,
                 r = 100,
                 lwd = 0.01,
                 showLegend = TRUE,
                 plotTitle = as.character(1),
                 overlay = he)

```

## gene expression

col=MERINGUE:::map2col(topic) to viz gene expression across spots

```{r, fig.width=10, fig.height=11}

he <- readJPEG('/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/HE_BrightfieldImages/HE_layer1_BC.jpg')

# alignment matrices came with these images
he_align <- matrix(unlist(read.table("/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/Alignments/Layer1_BC_transformation.txt")), nrow = 3, ncol = 3)

posScale <- bclCorpus$pos[bcl_slice_filt==1,]

# txn groups
bcl_com_slice <- bcl_com[names(bcl_slice_filt[bcl_slice_filt==1])]

# topic proportion in spots
topic <- bcl_k12$thetaCombn[names(bcl_com_slice),5]

# use the alignment file to adjust
posScale[,"x"] <- posScale[,"x"] * he_align[1,1]
posScale[,"y"] <- posScale[,"y"] * he_align[2,2]

# bring coordinates to positive values. set the x and y to start  at 0
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])

# Flip the spots horizontally
posScale[,"y"] <- posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# posScale[,"x"] <- posScale[,"x"]

# set the x and y to start at 0 again, after flipping
posScale[,"x"] <- posScale[,"x"] - min(posScale[,"x"])
posScale[,"y"] <- posScale[,"y"] - min(posScale[,"y"])


# final adjustment
# based on the Stahl et al spot coordinates (from Layer1_BC_count_matrix-1.tsv)
# that were adjusted with the alignment matrix, get the minimum x and y coords of these spots
# also double checked that the range of both sets of spot coordinates
# matched these, which they do. So just a matter of shifting spots in x and y direction
# equal to where the positions of the spots are in the stahl data
posScale[,"x"] <- posScale[,"x"] + 1380
posScale[,"y"] <- posScale[,"y"] + 2669


# plotting:
# ==============================================

# par(mfrow=c(1,1), mar=rep(5,4))
plot.new()
plot(c(0,dim(he)[2]), c(0,dim(he)[1])) 

# the point coords correspond to the mirror of the jpeg when plotted
# first dim is the y, which we reverse to match spot
# he[dim(he)[1]:1, , ]
# but if the y is not reveresed, then the spots need to be rotated along the horizontal
# to do this, find midpoint on the y-axis, and use this to rotate the y-coords of the spots
# posScale[,"y"] + 2*((dim(he)[1]/2) - posScale[,"y"])
# take distance of spots from the center horizontal of the image, multiply by 2 then add
rasterImage(he[, , ],
            0, 0,
            dim(he)[2], dim(he)[1])
# points(posScale[,"x"], posScale[,"y"], col='red', pch="+")
# points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::fac2col(bcl_com), pch=16)
points(posScale[,"x"], posScale[,"y"], col=MERINGUE:::map2col(topic), pch=16)

```

## groups of genes
gs <- rownames(bcl.CPM)[grepl('^CD', rownames(bcl.CPM))]
sapply(gs, function(g) {
  g %in% rownames(bcl.CPM)
  gexp <- scale(bcl.CPM[g,])[,1]
  gexp[gexp > 2] <- 2
  gexp[gexp < -2] <- -2
  MERINGUE::plotEmbedding(pos[slice[rownames(pos)]==1, ], col=gexp, main=g, cex=2)
})


# Co-localization of topics

```{r}

head(bcl_k12$theta)
rowSums(bcl_k12$theta)

pcor <- do.call(rbind, lapply(1:12, function(i) {
  p1 <- bcl_k12$theta[,i]
  unlist(lapply(1:12, function(j) {
    p2 <- bcl_k12$theta[,j]
    cor(p1, p2)
  }))
}))
diag(pcor) <- NA
range(pcor)
heatmap(pcor, col=correlation_palette)
which(pcor == max(pcor), arr.ind=TRUE)

tcor <- do.call(rbind, lapply(1:12, function(i) {
  p1 <- bcl_k12$beta[i,]
  unlist(lapply(1:12, function(j) {
    p2 <- bcl_k12$beta[j,]
    cor(p1, p2)
  }))
}))
diag(tcor) <- NA
range(tcor)
heatmap(tcor, col=correlation_palette, scale='none')
which(tcor == max(tcor), arr.ind=TRUE)

foo <- pcor - tcor
range(foo)
diag(foo) <- NA
heatmap(foo, col=correlation_palette, scale='none')
which(foo == max(foo, na.rm=TRUE), arr.ind=TRUE)

```


```{r, fig.height=8, fig.width=8}

thetaCorMtx <- getCorrMtx(m1 = bcl_k12$theta,
                           m2 = bcl_k12$theta,
                           type = "t")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = thetaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(thetaCorMtx)
gplots::heatmap.2(x = thetaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(thetaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

```{r, fig.height=8, fig.width=8}

betaCorMtx <- getCorrMtx(m1 = bcl_k12$beta,
                           m2 = bcl_k12$beta,
                           type = "b")

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor.pdf"))
gplots::heatmap.2(x = betaCorMtx,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_B-4_FN7_k8_mjrcts_thetaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(betaCorMtx)
gplots::heatmap.2(x = betaCorMtx[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 0.8,
                  cexCol = 0.8,
                  # lhei = c(1,3),
                  margins = c(7,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
paired_cors <- diag(betaCorMtx[pairs$rowix, pairs$colsix])

hist(paired_cors, breaks = 10)
mean(paired_cors)
sd(paired_cors)

```

what's interesting is topics 11 and 1 are in the same topic cluster, but are in different parts of the tissue. So similar gexp but different theta. Could these be same cells (but different states).

Also what are some transcriptionally different topics? But similar theta?

6 and 3 with 1 and 11? 
3 and 1 specifically?

# =========================

# Addt'l

# -------

objects to save

```{r}

# for assessing beta values
save(mob_se_wt,
     mob_se_wt_obj,
     mob_se_wt_raw,
     mob_se_wt_raw_obj_sct,
     cluster_markers_mob_se_wt,
     cluster_markers_mob_se_wt_raw,
     mobWtCellProxyBeta,
     mobWtCellProxyBetaRaw,
     mob_k15,
     sl_countsClean,
     sl_ctTheta,
     W_countsClean,
     file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/mob_data_to_assess_beta.RData")

```

```{r}

# all of the trained models for mob:

save(mob_k15,
     mob_k38,
     mobCorpus,
     mobProxyTheta,
     countsClean,
     nmf_mod_mob_wt_countsClean_ls,
     sl_countsClean,
     RCTD_mob_results_norm,
     nmf_mod_mob_wt_countsClean_noOECs_ls,
     sl_countsClean_noOEC,
     RCTD_mob_noOEC_results_norm,
     sl_cortexRef_countsClean_ls,
     sl_countsClean_cortexRef,
     RCTD_cortexRef_results_norm,
     file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/mob_fitted_models.RData")

```

```{r}

# all of the trained models for merfish:
save(bregmaCellsGexpFN7, # gene counts
      bregmaCellsGexpFN7_filt, # gene counts cells in patches
      gtCtGenesFN7,
      gtCtNeuronalGenesFN7,
      FN7,
      FN7_neuro,
      bregmaFN7FullSeur, # seurat object using just cells in patches
      bregmaFN7FullSeur_noNeuro,
      simBregmasFN7,
      simBregmasFN7_neuro,
      simFN7,
      simFN7_neuro,
      FN7_K8,
      FN7_K75,
      bregmaFN7FullSeur_markers8cts,
      bregmaFN7FullSeur_markers75neurocts,
      bregmaFN7FullSeur_noNeuro_markers,
      SL_bregmaFN7FullSeur8cts_fit,
      SL_bregmaFN7FullSeur75neurocts_fit,
      RCTD_FN7_results_norm,
      RCTD_FN7_neuro_results_norm,
      SL_bregmaFN7FullSeur_noNeuro_fit,
      RCTD_FN7_noNeuro_results_norm,
      file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/merfish_fitted_models.RData")


```

```{r}

# all of the trained models for BCL:

save(bcl_countsClean,
      bcl_CPM,
      bclCorpus,
      bcl_k12,
     file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/repos/STdeconvolve/data/bcl_fitted_models.RData")


```


# explore beta vs gene counts

Hows does the beta and the actual cell type txn profiles (gene counts) correspond? They are different, especially when looking at spotlight W and the Seurat ref. Agreement, but correlation is about 0.68 across the paired topics in W (the gene weights or probabilities) and the averaged expression of genes for the scRNAseq mob clusters. See `merged_workflow.Rmd` "scRNAseq cluster gexp".

Ex: If 2 cell types express gene A at 10 and 20, is the beta probability going to be 2x higher for gene A in second cell type? Does the relationship between beta and gene counts relate in terms of z-scores? Or logFC, or just the rank of the gene wrt the cell types (higher expressed genes have higher beta? Maybe not this because I would think that if the counts were 1000 and 2000 (higher overall compared to other genes, but the relative distance (2X more expression) the same, then maybe the association with the corresponding topic would have the same beta (2x higher in second cell type, but same beta as the gene that is onlt 10 and 20?). Unclear)

## mob_k15$beta vs mobWtCellProxyBeta

```{r}

m1 <- mob_k15$beta
m2 <- as.matrix(mobWtCellProxyBetaRaw)

betaCor <- getCorrMtx(m1 = m1,
                      m2 = m2, # gt proxy beta
                      type = "b")


mobk15_mobProxyBeta_sharedGenes <- intersect(colnames(m1), colnames(m2))

m1_filt <- m1[,mobk15_mobProxyBeta_sharedGenes]
m2_filt <- m2[,mobk15_mobProxyBeta_sharedGenes]

pairs <- lsatPairs(betaCor)
gplots::heatmap.2(x = betaCor[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  # xlab = "Predicted topics",
                  # ylab = "Major cell class",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))

diag_cors <- diag(betaCor[pairs$rowix, pairs$colsix])

hist(diag_cors, breaks = 10)
mean(diag_cors)
sd(diag_cors)

```

```{r}

# Mes1 and topic 4 correlate strongly (0.827). What about the genes?
plot(m2_filt["N1",], m1_filt[5,])

# N4 and topic 3 correlate weakly (0.37). What about the genes?
plot(m2_filt["N7",], m1_filt[2,])

# OEC5 and topic 14 in correlate moderately (0.65). What about the genes?
plot(m2_filt["Mono",], m1_filt[15,])

```

The genes that are chosen to be highly associated with the topic in the beta are not necessarily the ones that are expressed the highest in the cell type. Instead, maybe they are actually reflective of the deferentially expressed genes?

In cases where the beta correlates strongly, it is due to the expression of a few genes that are highly expressed. These also appear to be significantly differentially expressed in the ct (see below) but not always the case. For instance, N4 has a lot of sig dif genes, but a weaker correlation. Maybe too many specific genes for the LDA to chose as a defining marker to weight heavily? Some cts with no specific sig dif genes still correlate well. Again, this may point to the fact that the LDA is looking primarily for, and weighting on, genes that are more unique to a certain ct and not necessarily whether they are differentially expressed or not. 

However, consider that the LDA topics were derived from a completely different data set than what the scRNAseq was derived from.

So should really try this using the "W" matrix from spotlight which is trained using a reference scRNAseq data set. Then see how these two correspond.

```{r}

difExpAll <- MERINGUE::getDifferentialGenes(cd = mob_se_wt_raw, cols = mobWtCellClusters)

# also try with just the genes in the LDA corpus
# this actually ends up being very similar in terms of the p.adj, Z, M, fe values
# assigned even with a limited set of genes to begin with. Just stick to all genes above
# difExp_limitedGenes <- MERINGUE::getDifferentialGenes(cd = mob_se_wt[mobk15_mobProxyBeta_sharedGenes,], cols = mobWtCellClusters)

```

```{r}

difExpAll_sig <- lapply(difExpAll, function(x) {
  x <- x[x$p.adj < 0.05,]
  x <- na.omit(x)
  x <- x[x$highest,]
  rownames(x)
})

difExp_limitedGenes_sig <- lapply(difExp_limitedGenes, function(x) {
  x <- x[x$p.adj < 0.05,]
  x <- na.omit(x)
  x <- x[x$highest,]
  rownames(x)
})

```

```{r}

m1_filt[4,order(m1_filt[4,], decreasing = TRUE)]

m1_filt[14,order(m1_filt[14,], decreasing = TRUE)]

m1_filt[11,order(m1_filt[11,], decreasing = TRUE)]

```


```{r}


ggplot(data = reshape2::melt(m1_filt)) +
  geom_boxplot(aes(x = as.character(Var1), y = value)) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Ptgds"),], 
             aes(x = as.character(Var1), y = value, color = "Ptgds")) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Apod"),], 
             aes(x = as.character(Var1), y = value, color = "Apod")) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Fabp7"),], 
             aes(x = as.character(Var1), y = value, color = "Fabp7")) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Kctd12"),], 
             aes(x = as.character(Var1), y = value, color = "Kctd12")) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Atp1b1"),], 
             aes(x = as.character(Var1), y = value, color = "Atp1b1")) +
  geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Nrgn"),], 
             aes(x = as.character(Var1), y = value, color = "Nrgn")) +
  labs(
       x = "Topic", y = "gene beta value")

# ggplot(data = reshape2::melt(m1_filt)) +
#   geom_boxplot(aes(x = as.character(Var1), y = value)) +
#   geom_point(data = reshape2::melt(m1_filt)[which(reshape2::melt(m1_filt)[,"Var2"] == "Ptgds"),], 
#              aes(x = as.character(Var1), y = value, color = "red"))

```

```{r}

PDF <- approxfun(density(m1_filt[3,]), rule=2)
plot(PDF)
points(m1_filt[3,"Nrgn"], PDF(m1_filt[3,"Nrgn"]))
p <- integrate(PDF, lower=m1_filt[3,"Nrgn"], upper=1)
p

```

```{r}

topicGenePvals <- do.call(rbind, lapply(rownames(m1_filt), function(t){
  pvals <- unlist(lapply(mobk15_mobProxyBeta_sharedGenes, function(g){
    PDF <- approxfun(density(m1_filt[t,]), rule=2)
    p <- integrate(PDF, lower=m1_filt[t,g], upper=1, stop.on.error = FALSE)
    p$value
  }))
  names(pvals) <- mobk15_mobProxyBeta_sharedGenes
  pvals
}))
rownames(topicGenePvals) <- rownames(m1_filt)


```

```{r}

l <- lapply(1:15, function(t){
  plot(-log10(topicGenePvals[t,]), m1_filt[t,])
  plot(rank(topicGenePvals[t,]), rank(m1_filt[t,]))
  
  -log10(topicGenePvals[t,order(-log10(topicGenePvals[t,]), decreasing = TRUE)])
  m1_filt[t,order(m1_filt[t,], decreasing = TRUE)]
  
  # print(-log10(topicGenePvals[t, which(-log10(topicGenePvals[t,]) > -log10(0.05))]))
  print(m1_filt[t, which(-log10(topicGenePvals[t,]) > -log10(0.05))])
  
})


```

```{r}

plot(-log10(topicGenePvals), m1_filt)
abline(v = -log10(0.05), col='red')

```


```{r}

mat <- rbind(m1_filt, m1_filt, m1_filt)

tps <- rownames(mat)
names(tps) <- rownames(mat)
tps <- as.factor(tps)

sigDiffTopicGenes <- MERINGUE::getDifferentialGenes(cd = t(mat), cols = tps)

## average gene expression for each group
# mat.group <- do.call(cbind, lapply(levels(tps), function(g) {
#   rowMeans(t(m1_filt)[,group==g])
# }))
# colnames(mat.group) <- levels(group)
# ## construct tree related groups

# d_ <- as.dist(1-cor(t(m1_filt)))
# hc_ <- stats::hclust(d_, method = "ward.D")
# plot(hc_)
# 
# dend <- as.dendrogram(hc_)
# group <- tps
# M <- mobk15_mobProxyBeta_sharedGenes
# mat <- t(m1_filt)
# G <- length(levels(mob_k15$clusters))
# 
# pv <- sapply(M, function(i) {
#   mydataframe <- data.frame(y=mat[i,], ig=group)
#   print(mydataframe)
#   fit <- aov(y ~ ig, data=mydataframe)
#   summary(fit)[[1]][["Pr(>F)"]][1]
# })




# pv.sig.all <- c()
# pv.recur <- function(dend) {
#   g1 <- labels(dend[[1]])
#   g2 <- labels(dend[[2]])
#   #print(g1)
#   #print(g2)
#   ingroup <- names(group)[group %in% g1]
#   outgroup <- names(group)[group %in% g2]
#   print(ingroup)
#   print(outgroup)
#   pv <- sapply(M, function(i) {
#     t.test(mat[i,ingroup], mat[i,outgroup])$p.value
#   })
#   names(pv) <- rownames(mat)
#   pv.sig <- names(pv)[pv < 0.05/length(M)/length(hc_$height)] ## bonferonni
#   print(pv.sig)
#   pv.sig.all <<- c(pv.sig.all, pv.sig) ## save
#   
#   ## recursion to go down tree if not leaf
#   print(dend)
#   print(dend[[1]])
#   print(dend[[2]])
#   if(!is.leaf(dend[[1]])) {
#     pv.recur(dend[[1]])
#   }
#   if(!is.leaf(dend[[2]])) {
#     pv.recur(dend[[2]])
#   }
# }
# pv.recur(dend)
# 
# heatmap(mat[unique(unlist(pv.sig.all)),], Rowv=NA, Colv=NA, col=colorRampPalette(c('blue', 'white', 'red'))(100), scale="none", ColSideColors=rainbow(G)[group], labCol=FALSE, labRow=FALSE)

```


For each cluster and topic combo, compute correlation (pearson or spearman) wrt beta and a component of gene expression (p-val of significant diff exp, z-score, or expression in cluster.

Does expression of a gene across clusters correlated with its beta across topics?


```{r}

# Note:
# difExp_limitedGenes and difExpAll nearly the same. So doesn't matter which gene set is used.
# Makes sense because genes are not being compared to other genes
# Each gene is compared across clusters independent of the other genes




ct <- "MyOligo"
tp <- 4

# difExpGenesDF <- difExpAll[[ct]][names(m2_filt[ct,]),]
# difExpGenesDF$beta <- m1_filt[tp,]
# difExpGenesDF$betaZ <- scale(m1_filt[tp,])

# ggplot(data = difExpGenesDF) +
#   geom_point(aes(x = -log10(p.adj), y = beta))
# 
# ggplot(data = difExpGenesDF) +
#   geom_point(aes(x = -log10(p.adj), y = beta))

# Mes1 and topic 4 correlate strongly (0.827). What about the genes?
plot(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,])
cor(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,], method = c("pearson"))
cor(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,], method = c("spearman"))

plot(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,])
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,], method = c("pearson"))
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,], method = c("spearman"))

plot(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,])
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,], method = c("pearson"))
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,], method = c("spearman"))

plot(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])], m1_filt[tp,])
cor(-log10(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])]), m1_filt[tp,], method = c("pearson"))
cor(-log10(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])]), m1_filt[tp,], method = c("spearman"))


ct <- "OEC5"
tp <- 14

plot(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,])
cor(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,], method = c("pearson"))
cor(-log10(difExpAll[[ct]][names(m2_filt[ct,]),]$p.adj), m1_filt[tp,], method = c("spearman"))

plot(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,])
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,], method = c("pearson"))
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$M, m1_filt[tp,], method = c("spearman"))

plot(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,])
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,], method = c("pearson"))
cor(difExpAll[[ct]][names(m2_filt[ct,]),]$Z, m1_filt[tp,], method = c("spearman"))

plot(-log10(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])]), m1_filt[tp,])
cor(-log10(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])]), m1_filt[tp,], method = c("pearson"))
cor(-log10(as.matrix(mobWtCellProxyBeta)[ct, names(m2_filt[ct,])]), m1_filt[tp,], method = c("spearman"))

```

```{r}

# Mes1 and topic 4 correlate strongly (0.827). What about the genes?
plot(difExpAll$Mes1[names(m2_filt["Mes1",]),]$p.adj, m1_filt[4,])

# significant cluster genes determined by seurat that are in the corpus
mobWtdifGenesSeurat_inCorpus <- cluster_markers_mob_se_wt[which(cluster_markers_mob_se_wt$cluster == "Mes1" & cluster_markers_mob_se_wt$gene %in% names(m2_filt["Mes1",])),]
dim(mobWtdifGenesSeurat_inCorpus)

# compare to beta from LDA model
plot(difExpAll$Mes1[names(m2_filt["Mes1",]),]$p.adj, m1_filt[4,])

```



In cases where the beta correlates well with the ct expression, there are a few top genes that are highly expressed in the cell type that the beta picks up on. But the weights are not direct correspondences with the gene expressions.

Then looked at the total number of unique sig dif "marker" genes for a cell type but that doesn't seem to affect correlation. The idea being that gene expression profiles the beta correlates strongest with could be due to the LDA picking up on significantly differentially expressed genes in the ct and weighting the beta based on this differential expression. But doesn't seem to be the case wrt number of marker genes.

```{r}

# colnames(betaCor[pairs$rowix, pairs$colsix])

numSigGenes <- unlist(lapply(colnames(betaCor[pairs$rowix, pairs$colsix]), function(ct){
  length(difExpAll_sig[[ct]])
}))

plot(numSigGenes, diag(betaCor[pairs$rowix, pairs$colsix]))

```

## SL W mob vs scRNAseq ref

Make a proxy beta using the 38 cell type clusters of the mob scRNAseq reference

```{r}

dim(mobWtCellProxyBetaRaw)

```

Compare to Spotlight trained NMF, with a fitted W matrix (the "beta" topic-gene probability matrix)

This one was fit using `mob_counts`, so the seurat cluster genes were additionally removed if they were not kept in the `mob_counts` spatial data set.

```{r}

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_ls.RData")
# nmf_mod_mob_wt_countsClean_ls

W_countsClean <- nmf_mod_mob_wt_countsClean_ls[[1]]@fit@W

dim(W_countsClean)

keep_genes <- colnames(mobWtCellProxyBetaRaw)[colnames(mobWtCellProxyBetaRaw) %in% rownames(W_countsClean)]
length(keep_genes)

```

correlate each, then plot gene expression vs betas for a variety of different topics/cell types

```{r}

w_vs_mobScRNA_beta <- getCorrMtx(m1 = mobWtCellProxyBetaRaw[,keep_genes],
                                       m2 = t(W_countsClean),
                                       type = "b")

# pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor.pdf"))
gplots::heatmap.2(x = w_vs_mobScRNA_beta,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Major cell class",
                  ylab = "Predicted topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# pdf(file = paste0(fig_path, "Fig1_E-4_mob_k15_scRNAseqProxy_betaCor_pairs.pdf"))
# pair up best matching cell class to a predicted topic
pairs <- lsatPairs(w_vs_mobScRNA_beta)
gplots::heatmap.2(x = w_vs_mobScRNA_beta[pairs$rowix, pairs$colsix],
                  Rowv = NA, # to order topics based on pairs and not dendrogram
                  Colv = NA,
                  density.info = "none",
                  trace = "none",
                  col = correlation_palette,
                  breaks = correlation_breaks,
                  key.xlab = "Correlation",
                  xlab = "Cell type clusters",
                  ylab = "W topics",
                  key.title = NA,
                  cexRow = 1,
                  cexCol = 0.9,
                  # lhei = c(1,3),
                  margins = c(6,4))
# dev.off()

# correlations along diagonal (after assigning best matches)
cors <- diag(w_vs_mobScRNA_beta[pairs$rowix, pairs$colsix])

hist(cors, breaks = 10)
mean(cors)
sd(cors)

```

```{r}

# astro 3 and 3 corr = 0.86
plot(x = mobWtCellProxyBetaRaw["Astro3",keep_genes], y = t(W_countsClean)[3,keep_genes])

# corr = 0.915
plot(x = mobWtCellProxyBetaRaw["N3",keep_genes], y = t(W_countsClean)[25,keep_genes])

# corr = 0.37
plot(x = mobWtCellProxyBetaRaw["Mural1",keep_genes], y = t(W_countsClean)[12,keep_genes])

```

```{r}

# astro 3 and 3 corr = 0.86
plot(x = mobWtCellProxyBeta["Astro3",keep_genes], y = t(W_countsClean)[3,keep_genes])

# corr = 0.915
plot(x = mobWtCellProxyBeta["N3",keep_genes], y = t(W_countsClean)[25,keep_genes])

# corr = 0.37
plot(x = mobWtCellProxyBeta["Mural1",keep_genes], y = t(W_countsClean)[12,keep_genes])

```

First off, the range of the values in W correspond very closely to the actual relative gene expression from the mob scRNAseq refernce cell clusters. But does vary. The topics in W also sum to 1 wrt the gene counts.

The genes for this W were the cluster genes and also 1000 variables genes and filtered down to also be genes in the mob_count st data set. So maybe the highest expressed genes from this list observed in a cluster would also be expected to be marker genes and weighted similarly in W?

```{r}

# top W genes
t(W_countsClean)[3,keep_genes][order(t(W_countsClean)[3,keep_genes], decreasing = TRUE)][1:10]

# top W genes
t(W_countsClean)[25,keep_genes][order(t(W_countsClean)[25,keep_genes], decreasing = TRUE)][1:10]

```

```{r}

# input df for `vizGeneCounts`
df <- t(mob_cpm)[,c("Rps29", "Mt3", "Cst3", "Rpl41", "Tmsb10", "Ptgds", "Atp1b1")]
df <- merge(mobCorpus$mob$pos, as.data.frame(df), by=0)
rownames(df) <- df$Row.names

```

```{r}

vizGeneCounts(df = df,
              gene = "Atp1b1",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Atp1b1",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Ptgds",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Ptgds",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Rps29",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Rps29",
              showLegend = TRUE)
# ggsave(filename = "Fig1_F-3_mob_k15_clust6_granule_Tubb2b.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

vizGeneCounts(df = df,
              gene = "Mt3",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Mt3",
              showLegend = TRUE)
# ggsave(filename = "Fig1_F-3_mob_k15_clust1_granule_Atp1b1.pdf",
#        device = "pdf",
#        path = fig_path,
#        scale = 1.5,
#        width = 5,
#        height = 4,
#        units = c("in"),
#        dpi = 600)

vizGeneCounts(df = df,
              gene = "Cst3",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Cst3",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Rpl41",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Rpl41",
              showLegend = TRUE)

vizGeneCounts(df = df,
              gene = "Tmsb10",
              # groups = as.character(mobProxyTheta$`Granule Cell Layer`),
              # group_cols = c("0" = "white", "1" = "white"),
              # size = (mobProxyTheta$`Granule Cell Layer` + 0.5) * 5,
              # stroke = 0, # maybe consider just the size? group of interest is large spots, the rest are small?
              plotTitle = "Tmsb10",
              showLegend = TRUE)

```

# p-val vs beta

## mob_k15


```{r}

x1 <- seq(from = 10, to = 100, by = 10)
x2 <- seq(from = 50, to = 100, by = 5)
x3 <- seq(from = 20, to = 100, by = 20)



```





# -------
