---
title: "merged_wrokflow"
author: "Brendan F. Miller"
date: "2/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}

k_ <- seq(from = 10, to = 75, by = 5)
k_

```

# ==========================
# MOB

# mOB merignue data

```{r}

data(mOB)
cd <- mOB$counts

```

```{r}

mob <- preprocess(t(cd),
                  alignFile = NA, extractPos = FALSE,
                  nTopGenes = 5,
                  genes.to.remove = c("mt-"),
                  perc.spots = 1.0,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.05,
                  gam.k = 5)

mob$pos <- mOB$pos[rownames(mob$corpus),]

```

 range to get perplexities for testing optimal search function
```{r}

k <- seq(from = 2, to = 35, by = 1)
k

```


```{r}

start_time <- Sys.time()

mob_LDAs <- fitLDA(mob$slm, k, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

could test out different corpus's and how they affect K and perplexity...

```{r}

mobLDA_alphas <- sapply(mob_LDAs$models, slot, "alpha")
dat <- data.frame(k = as.character(k),
                  alpha = mobLDA_alphas,
                  perplexities = mob_LDAs$perplexities,
                  pos = seq(length(k)))

ggplot() +
  geom_point(data = dat, aes(x = pos, y = perplexities)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("perplexity") +
  theme_classic()

ggplot() +
  geom_point(data = dat, aes(x = pos, y = alpha)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("alpha") +
  theme_classic()

# for testing optimal k search function. 2-35 by 1 with optimal k at 12
# dat_mob <- dat

```

```{r}

mob_opt <- buildLDAobject(LDAmodel = optimalModel(mob_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- mob_opt

ctcols <- as.factor(colnames(m$theta))
names(ctcols) <- colnames(m$theta)
levels(ctcols) <- gg_color_hue(length(colnames(m$theta)))

# all topics
vizAllTopics(theta = m$theta,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$theta))),
             cluster_cols = levels(ctcols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob combined")

# same color topics in each cluster
# vizTopicClusters(theta = m$thetaCombn,
#                 pos = pos,
#                 clusters = m$clustCols,
#                 sharedCol = TRUE,
#                 r = 0.4,
#                 lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = ctcols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

interesting because less information captured using these 196 genes than using the 146 common genes from the 4 different data sets.

note that for the 4 data sets, no genes were removed via top expressed, or certain percent of spots. So perhaps lost too much information. Whereas taking the common set still ended up filtering but kept the most variable genes and therefor more of the variation? Could this be explored more looking at PCA of gene counts?

# Rep1 Stahl data

```{r}

path <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep1_MOB_count_matrix-1.tsv"

mob_rep1 <- preprocess(path,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("mt-"),
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

mob_rep1_LDAs <- fitLDA(mob_rep1$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep1_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep1_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep1$pos
m <- mob_rep1_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob_rep1_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# Rep2 Stahl data

```{r}

path <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep2_MOB_count_matrix-1.tsv"

mob_rep2 <- preprocess(path,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("mt-"),
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

mob_rep2_LDAs <- fitLDA(mob_rep2$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep2_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep2_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep2$pos
m <- mob_rep2_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob_rep2_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# Rep3 Stahl data

```{r}

path <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep3_MOB_count_matrix-1.tsv"

mob_rep3 <- preprocess(path,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("mt-"),
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

mob_rep3_LDAs <- fitLDA(mob_rep3$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep3_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep3_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep3$pos
m <- mob_rep3_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob_rep3_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# Standardize corpus for datasets

Common set of genes to use for all curpuses with the MOB. Make it easier to assess reliability of models and produced topics for a given tissue across different samples.

Should still be careful about the time it takes based on the corpus size...

```{r}

dim(mob$corpus)
dim(mob_rep1$corpus)
dim(mob_rep2$corpus)
dim(mob_rep3$corpus)

```

```{r}

paths <- list()
paths[[1]] <- t(cd)
paths[[2]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep1_MOB_count_matrix-1.tsv"
paths[[3]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep2_MOB_count_matrix-1.tsv"
paths[[4]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep3_MOB_count_matrix-1.tsv"

filtMobGenes <- lapply(paths, function(p) {
  
  dat <- preprocess(p,
            alignFile = NA, extractPos = FALSE,
            nTopGenes = NA,
            genes.to.remove = NA,
            perc.spots = NA,
            min.reads = 100,
            min.lib.size = 100,
            od.genes.alpha = 0.1,
            gam.k = 5)
  colnames(dat$corpus)
  
})

commonGenes <- Reduce(intersect, filtMobGenes)
length(commonGenes)

```

now, starting from each gene matrix, cleanup then select set of common genes to use as corpus

```{r}

mobDataCommonSet <- lapply(paths, function(p) {
  
  dat <- preprocess(p,
            alignFile = NA, extractPos = FALSE,
            selected.genes = commonGenes,
            nTopGenes = NA,
            genes.to.remove = NA,
            perc.spots = NA,
            min.reads = 100,
            min.lib.size = 100,
            ODgenes = FALSE)
  
})

mob_common <- mobDataCommonSet[[1]]
mob_rep1_common <- mobDataCommonSet[[2]]
mob_rep2_common <- mobDataCommonSet[[3]]
mob_rep3_common <- mobDataCommonSet[[4]]

dim(mob_common$corpus)
dim(mob_rep1_common$corpus)
dim(mob_rep2_common$corpus)
dim(mob_rep3_common$corpus)

sum(mob_common$corpus)
sum(mob_rep1_common$corpus)
sum(mob_rep2_common$corpus)
sum(mob_rep3_common$corpus)

```

as a reference, the initial meringue corpus was 260 x 196 and 103,115 terms and took about 5 minutes to linearly assess k from 10 to 75 (14 k's)

## mOB meringue

```{r}

start_time <- Sys.time()

mob_common_LDAs <- fitLDA(mob_common$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_common_LDA_alphas <- sapply(mob_common_LDAs$models, slot, "alpha")
dat <- data.frame(k = as.character(k_),
                  alpha = mob_common_LDA_alphas,
                  perplexities = mob_common_LDAs$perplexities,
                  pos = seq(length(k_)))

ggplot() +
  geom_point(data = dat, aes(x = pos, y = perplexities)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("perplexity") +
  theme_classic()

ggplot() +
  geom_point(data = dat, aes(x = pos, y = alpha)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("alpha") +
  theme_classic()

```

```{r}

mob_common_opt <- buildLDAobject(LDAmodel = optimalModel(mob_common_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- mob_common_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob common combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

```{r}

head(mob_common_opt$betaCombn[c(17),order(mob_common_opt$betaCombn[c(17),], decreasing = TRUE)], n=10)
head(mob_common_opt$betaCombn[c(17),order(mob_common_opt$betaCombn[c(7),], decreasing = TRUE)], n=10)
head(mob_common_opt$betaCombn[c(17),order(mob_common_opt$betaCombn[c(3),], decreasing = TRUE)], n=10)
head(mob_common_opt$betaCombn[c(17),order(mob_common_opt$betaCombn[c(4),], decreasing = TRUE)], n=10)

```


```{r}

genes <- c("Mbp", "Atp1b1", "Snap25", "Fabp7")
genecounts <- mob_common$corpus[,genes]
mobExp <- merge(as.data.frame(mob$pos), as.data.frame(genecounts), by=0)
rownames(mobExp) <- mobExp$Row.names
mobExp <- mobExp[,2:ncol(mobExp)]

```

```{r}

vizGeneCounts(mobExp, gene = "Fabp7")

```



## Rep1 Stahl

```{r}

start_time <- Sys.time()

mob_rep1_common_LDAs <- fitLDA(mob_rep1_common$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep1_common_LDA_alphas <- sapply(mob_rep1_common_LDAs$models, slot, "alpha")
dat <- data.frame(k = as.character(k_),
                  alpha = mob_rep1_common_LDA_alphas,
                  perplexities = mob_rep1_common_LDAs$perplexities,
                  pos = seq(length(k_)))

ggplot() +
  geom_point(data = dat, aes(x = pos, y = perplexities)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("perplexity") +
  theme_classic()

ggplot() +
  geom_point(data = dat, aes(x = pos, y = alpha)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("alpha") +
  theme_classic()

```

```{r}

mob_rep1_common_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep1_common_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep1$pos
m <- mob_rep1_common_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob common combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

## Rep2 Stahl

```{r}

start_time <- Sys.time()

mob_rep2_common_LDAs <- fitLDA(mob_rep2_common$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep2_common_LDA_alphas <- sapply(mob_rep2_common_LDAs$models, slot, "alpha")
dat <- data.frame(k = as.character(k_),
                  alpha = mob_rep2_common_LDA_alphas,
                  perplexities = mob_rep2_common_LDAs$perplexities,
                  pos = seq(length(k_)))

ggplot() +
  geom_point(data = dat, aes(x = pos, y = perplexities)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("perplexity") +
  theme_classic()

ggplot() +
  geom_point(data = dat, aes(x = pos, y = alpha)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("alpha") +
  theme_classic()

```

```{r}

mob_rep2_common_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep2_common_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep2$pos
m <- mob_rep2_common_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob common combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

## Rep3 Stahl

```{r}

start_time <- Sys.time()

mob_rep3_common_LDAs <- fitLDA(mob_rep3_common$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

mob_rep3_common_LDA_alphas <- sapply(mob_rep3_common_LDAs$models, slot, "alpha")
dat <- data.frame(k = as.character(k_),
                  alpha = mob_rep3_common_LDA_alphas,
                  perplexities = mob_rep3_common_LDAs$perplexities,
                  pos = seq(length(k_)))

ggplot() +
  geom_point(data = dat, aes(x = pos, y = perplexities)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("perplexity") +
  theme_classic()

ggplot() +
  geom_point(data = dat, aes(x = pos, y = alpha)) +
  scale_x_continuous(breaks = dat$pos, labels = dat$k) +
  xlab("K") + ylab("alpha") +
  theme_classic()

```

```{r}

mob_rep3_common_opt <- buildLDAobject(LDAmodel = optimalModel(mob_rep3_common_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- mob_rep3$pos
m <- mob_rep3_common_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "mob common combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# compare models

## meringue vs Rep1

```{r, fig.height=7, fig.width=8}

m1 <- mob_common_opt
m2 <- mob_rep1_common_opt

beta_cor <- correlationBetweenBetas(beta1 = m1$beta,
                                      beta2 = m2$beta)

betaCombn_cor <- correlationBetweenBetas(beta1 = m1$betaCombn,
                                       beta2 = m2$betaCombn)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta mob v Rep1 cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$cols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta mob v Rep1 cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

# -------------------------------------------------------
# betaCombn:

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor,
          # Rowv = bregmaOpt_04$dendro,
          # Colv = bregmaOpt_09$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$clustCols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta mob v Rep1 clusters cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(betaCombn_cor)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$clustCols)[pairs$colsix],
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta mob v Rep1 clusters cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
betaCombn_paired_cors <- diag(betaCombn_cor[pairs$rowix, pairs$colsix])


hist(beta_paired_cors, breaks = 20)
mean(beta_paired_cors)
sd(beta_paired_cors)

hist(betaCombn_paired_cors, breaks = 20)
mean(betaCombn_paired_cors)
sd(betaCombn_paired_cors)

```

## Rep1 vs Rep2

```{r, fig.height=7, fig.width=8}

m1 <- mob_rep1_common_opt
m2 <- mob_rep2_common_opt

beta_cor <- correlationBetweenBetas(beta1 = m1$beta,
                                      beta2 = m2$beta)

betaCombn_cor <- correlationBetweenBetas(beta1 = m1$betaCombn,
                                       beta2 = m2$betaCombn)


par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep1 v Rep2 cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$cols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep1 v Rep2 cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

# -------------------------------------------------------
# betaCombn:

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor,
          # Rowv = bregmaOpt_04$dendro,
          # Colv = bregmaOpt_09$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$clustCols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep1 v Rep2 clusters cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(betaCombn_cor)) # more rows than columns so t()

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor[pairs$colsix, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$clustCols)[pairs$rowix], # more rows than columns so t()
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep1 v Rep2 clusters cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
betaCombn_paired_cors <- diag(betaCombn_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()


hist(beta_paired_cors, breaks = 20)
mean(beta_paired_cors)
sd(beta_paired_cors)

hist(betaCombn_paired_cors, breaks = 20)
mean(betaCombn_paired_cors)
sd(betaCombn_paired_cors)

```

## Rep2 vs Rep3

```{r, fig.height=7, fig.width=8}

m1 <- mob_rep2_common_opt
m2 <- mob_rep3_common_opt

beta_cor <- correlationBetweenBetas(beta1 = m1$beta,
                                      beta2 = m2$beta)

betaCombn_cor <- correlationBetweenBetas(beta1 = m1$betaCombn,
                                       beta2 = m2$betaCombn)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep2 v Rep3 cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$cols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep2 v Rep3 cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

# -------------------------------------------------------
# betaCombn:

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor,
          # Rowv = bregmaOpt_04$dendro,
          # Colv = bregmaOpt_09$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$clustCols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep2 v Rep3 clusters cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(betaCombn_cor)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$clustCols)[pairs$colsix],
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta Rep2 v Rep3 clusters cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
betaCombn_paired_cors <- diag(betaCombn_cor[pairs$rowix, pairs$colsix])


hist(beta_paired_cors, breaks = 20)
mean(beta_paired_cors)
sd(beta_paired_cors)

hist(betaCombn_paired_cors, breaks = 20)
mean(betaCombn_paired_cors)
sd(betaCombn_paired_cors)

```

# ------------------------------------

# ** mob_common with k = scRNA clusters (38)

same as NMF topics 38. What about the remaining cell types after filtering (the NMF ones that were actually present)
Here its 17 i think?

# ==========================
# PDAC

# PDAC A ST1

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/moncada_pdac_GSE111672/GSE111672_RAW/GSM3036911_PDAC-A-ST1-filtered.txt"

# reformat the data before preprocessing
# need a matrix in which:
pdac_a1 <- read.table(path, header = TRUE, sep = "\t")
pdac_a1

```

input for `preprocess` should be spot (row) x gene (columns) mtx with raw gene counts

```{r}

spotids <- unlist(lapply(colnames(pdac_a1)[2:ncol(pdac_a1)], function(i) {
  ix <- strsplit(i, "X")[[1]][2]
  ix
}))

t <- t(pdac_a1)
colnames(t) <- pdac_a1$Genes
t <- t[2:nrow(t),]
pdac_a1 <- apply(t, 2,FUN = as.numeric)
rownames(pdac_a1) <- spotids
pdac_a1[1:10,1:10]

```

```{r}

pdac_a1 <- preprocess(pdac_a1,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("^MT", "^RPL", "^MRPL"), # note, MTOR is removed...maybe other non MT genes...?
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

pdac_a1_LDAs <- fitLDA(pdac_a1$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

pdac_a1_opt <- buildLDAobject(LDAmodel = optimalModel(pdac_a1_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- pdac_a1$pos
m <- pdac_a1_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "pdac_a1_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# PDAC A ST2

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/moncada_pdac_GSE111672/GSE111672_RAW/GSM4100721_PDAC-A-st2.tsv"

# input for `preprocess` should be spot (row) x gene (columns) mtx with raw gene counts

pdac_a2 <- loadPDACfile(path = path)
pdac_a2[1:10,1:10]

```

```{r}

pdac_a2 <- preprocess(pdac_a2,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("^MT", "^RPL", "^MRPL"), # note, MTOR is removed...maybe other non MT genes...?
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

pdac_a2_LDAs <- fitLDA(pdac_a2$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

pdac_a2_opt <- buildLDAobject(LDAmodel = optimalModel(pdac_a2_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- pdac_a2$pos
m <- pdac_a2_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "pdac_a2_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$thetaCombn,
                pos = pos,
                clusters = m$clustCols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# PDAC B ST1

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/moncada_pdac_GSE111672/GSE111672_RAW/GSM3405534_PDAC-B-ST1-filtered.txt"

# input for `preprocess` should be spot (row) x gene (columns) mtx with raw gene counts

pdac_b1 <- loadPDACfile(path = path)
pdac_b1[1:10,1:10]

```

```{r}

pdac_b1 <- preprocess(pdac_b1,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("^MT", "^RPL", "^MRPL"), # note, MTOR is removed...maybe other non MT genes...?
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

pdac_b1_LDAs <- fitLDA(pdac_b1$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

pdac_b1_opt <- buildLDAobject(LDAmodel = optimalModel(pdac_b1_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- pdac_b1$pos
m <- pdac_b1_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "pdac_b1_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# PDAC B ST2

```{r}

path <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/moncada_pdac_GSE111672/GSE111672_RAW/GSM4100723_PDAC-B-st2.tsv"

# input for `preprocess` should be spot (row) x gene (columns) mtx with raw gene counts

pdac_b2 <- loadPDACfile(path = path)
pdac_b2[1:10,1:10]

```

```{r}

pdac_b2 <- preprocess(pdac_b2,
                  alignFile = NA, extractPos = TRUE,
                  nTopGenes = 5,
                  genes.to.remove = c("^MT", "^RPL", "^MRPL"), # note, MTOR is removed...maybe other non MT genes...?
                  perc.spots = .95,
                  min.reads = 100,
                  min.lib.size = 100,
                  od.genes.alpha = 0.10)

```

```{r}

start_time <- Sys.time()

pdac_b2_LDAs <- fitLDA(pdac_b2$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

pdac_b2_opt <- buildLDAobject(LDAmodel = optimalModel(pdac_b2_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- pdac_b2$pos
m <- pdac_b2_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "pdac_b2_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 0.4,
                lwd = 0.01)

```

# Standardize corpus for datasets

Because the corpuses are so different, not sure if it makes sense. But perhaps just try it anyways.

```{r}

dim(pdac_a1$corpus)
dim(pdac_a2$corpus)
dim(pdac_b1$corpus)
dim(pdac_b2$corpus)

```

```{r}

paths <- list()
paths[[1]] <- t(cd)
paths[[2]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep1_MOB_count_matrix-1.tsv"
paths[[3]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep2_MOB_count_matrix-1.tsv"
paths[[4]] <- "/Users/brendan/Desktop/PostDoc/data/ImputeTranscriptomeFromHE/2016_Stahl/SpotGeneCountMatrices/Rep3_MOB_count_matrix-1.tsv"

filtMobGenes <- lapply(paths, function(p) {
  
  dat <- preprocess(p,
            alignFile = NA, extractPos = FALSE,
            nTopGenes = NA,
            genes.to.remove = NA,
            perc.spots = NA,
            min.reads = 100,
            min.lib.size = 100,
            od.genes.alpha = 0.1,
            gam.k = 5)
  colnames(dat$corpus)
  
})

commonGenes <- Reduce(intersect, filtMobGenes)
length(commonGenes)

```

# ==========================
# MERFISH


# '171021_FN7_2_M22_M26'

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mpoa_merfish_clean.RData")
# has `annot.table`, `counts`, and `features`
# annot.table: table of the individual cells and data like coordinates, cell types, bregma, animal
# features: has cells and additional features. Also dataset they belong to
# counts: gene counts of cell in annot.table for 130 merfish genes profiled

# select cells that are part of given dataset:
selected_cells <- rownames(features)[features$dataset_name %in% c('171021_FN7_2_M22_M26')]

spatial_position_and_class <- annot.table[selected_cells, c('Centroid_X', 'Centroid_Y', 'Bregma', "Cell_class", "Neuron_cluster_ID")]
spatial_position_and_class <- na.omit(spatial_position_and_class) # remove rows with NA

dim(spatial_position_and_class)
# [1] 36329     5

```

```{r}

FN7_2_M22_M26_hash <- build_bregma_hash_table(spatial_position_and_class, 100)

```

```{r}

keys(FN7_2_M22_M26_hash)

```

# models

to run through 14 k's:
seq(from = 10, to = 75, by = 5)
takes on average 15 minutes for the MERFISH corpuses

```{r}

# documents and genes same for all:
sapply(bregma04_LDAs$models, slot, "Dim")[,1]

# terms in each corpus
sapply(bregma04_LDAs$models, slot, "n")[1]
sapply(bregma09_LDAs$models, slot, "n")[1]
sapply(bregma14_LDAs$models, slot, "n")[1]
sapply(bregma19_LDAs$models, slot, "n")[1]
sapply(bregma24_LDAs$models, slot, "n")[1]
sapply(bregma29_LDAs$models, slot, "n")[1]

# about 1.4 million terms

```
bregmas:
<!-- "-0.04" "-0.09" "-0.14" "-0.19" "-0.24" "-0.29" -->

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merfish_FN7_2_M22_M26_hash.RData")

```

# -0.04

```{r}

bregma04 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.04")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma04

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma04_LDAs <- fitLDA(bregma04$sim, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma04_opt <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=8, fig.width=9}

pos <- bregma04$cellCounts[,c("x","y")]
m <- bregma04_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma04_opt combined")

```


```{r, fig.height=6, fig.width=8}

pos <- bregma04$cellCounts[,c("x","y")]
m <- bregma04_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma04_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

## theta

```{r}

m1 <- bregma04
m2 <- bregma04_opt


# -------------------------------------------------------
# individual topics

theta_cor <- correlationBetweenThetas(theta1 = m1$gtDocTopics[,4:12], # 9
                                      theta2 = m2$theta) # 75

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "breg04 theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$cols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "breg04 theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$gtDocTopics[,4:12],
                                      theta2 = m2$thetaCombn)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$clustCols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "bregma04_opt clusters theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$clustCols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "bregma04_opt clusters theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

## beta

```{r}

m1 <- bregma04_opt
m2 <- bregma04


# -------------------------------------------------------
# individual topics

cor <- correlationBetweenBetas(beta1 = m1$beta, # 75
                               beta2 = m2$gtTopicWords, # 9
                               thresh = NULL)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "breg04 beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$cols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "breg04 beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
cor_paired_cors <- diag(cor[pairs$colsix, pairs$rowix])

hist(cor_paired_cors, breaks = 10)
mean(cor_paired_cors)
sd(cor_paired_cors)

# -------------------------------------------------------
# clusters

cor <- correlationBetweenBetas(beta1 = m1$betaCombn,
                                beta2 = m2$gtTopicWords,
                                thresh = NULL)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "bregma04_opt clusters beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$colsix],
          ColSideColors = as.vector(m2$cols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "bregma04_opt clusters beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
cor_paired_cors <- diag(cor[pairs$colsix, pairs$rowix])

hist(cor_paired_cors, breaks = 10)
mean(cor_paired_cors)
sd(cor_paired_cors)

```

# -0.09

```{r}

bregma09 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.09")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma09

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma09_LDAs <- fitLDA3(interval = k_, p = 6,
                         corpus = bregma09$sim,
                         seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma09_opt <- buildLDAobject(LDAmodel = optimalModel(bregma09_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- bregma09$cellCounts[,c("x","y")]
m <- bregma09_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma09_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

# -0.14

```{r}

bregma14 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.14")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma14

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma14_LDAs <- fitLDA3(interval = k_, p = 6,
                         corpus = bregma14$sim,
                         seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma14_opt <- buildLDAobject(LDAmodel = optimalModel(bregma14_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- bregma14$cellCounts[,c("x","y")]
m <- bregma14_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma14_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

# -0.19

```{r}

bregma19 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.19")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma19

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma19_LDAs <- fitLDA3(interval = k_, p = 6,
                         corpus = bregma19$sim,
                         seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma19_opt <- buildLDAobject(LDAmodel = optimalModel(bregma19_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- bregma19$cellCounts[,c("x","y")]
m <- bregma19_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma19_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

# -0.24

```{r}

bregma24 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.24")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma24

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma24_LDAs <- fitLDA3(interval = k_, p = 6,
                         corpus = bregma24$sim,
                         seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma24_opt <- buildLDAobject(LDAmodel = optimalModel(bregma24_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- bregma24$cellCounts[,c("x","y")]
m <- bregma24_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma24_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

# -0.29

```{r}

bregma29 <- extractBregmaCorpus(FN7_2_M22_M26_hash, "-0.29")

```

```{r, fig.height=6, fig.width=8}

breg <- bregma29

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  facet_wrap(~ Cell_class, nrow = 4) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df,
             aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$df, aes(x=Centroid_X, y=Centroid_Y, color=Cell_class)) +
  scale_fill_manual(values=breg$cols) +
  geom_rect(data = breg$gtDocTopics,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100),
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

ggplot() +
  geom_point(data = breg$cellCounts, size=7, aes(x=x+50, y=y+50, color=counts)) +
  scale_color_viridis(option = "C") +
  geom_rect(data = breg$cellCounts,
            aes(xmin = x - 0, xmax = x + 100,
                ymin = y - 0, ymax = y + 100), 
            fill = NA, color = "white") +
  theme(panel.background = element_rect(fill = "black"),
          panel.grid = element_blank())

```

```{r}

start_time <- Sys.time()

bregma29_LDAs <- fitLDA3(interval = k_, p = 6,
                         corpus = bregma29$sim,
                         seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

bregma29_opt <- buildLDAobject(LDAmodel = optimalModel(bregma29_LDAs),
                      deepSplit = 3,
                      colorScheme = "ggplot")

```

```{r, fig.height=6, fig.width=8}

pos <- bregma29$cellCounts[,c("x","y")]
m <- bregma29_opt

# all topics
vizAllTopics(theta = m$thetaCombn,
             pos = pos,
             topicOrder = seq_len(length(colnames(m$thetaCombn))),
             cluster_cols = levels(m$clustCols),
             groups = NA,
             group_cols = NA, 
             r = 40,
             lwd = 0.01,
             plotTitle = "bregma29_opt combined")

# same color topics in each cluster
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = TRUE,
                r = 40,
                lwd = 0.01)

# color topics in cluster differently
vizTopicClusters(theta = m$theta,
                pos = pos,
                clusters = m$cols,
                sharedCol = FALSE,
                r = 40,
                lwd = 0.01)

```

# compare models

```{r}

bregmaOpt_04 <- buildLDAobject(LDAmodel = optimalModel(bregma04_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

bregmaOpt_09 <- buildLDAobject(LDAmodel = optimalModel(bregma09_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

bregmaOpt_14 <- buildLDAobject(LDAmodel = optimalModel(bregma14_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

bregmaOpt_24 <- buildLDAobject(LDAmodel = optimalModel(bregma24_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

bregmaOpt_29 <- buildLDAobject(LDAmodel = optimalModel(bregma29_LDAs),
                      deepSplit = 4,
                      colorScheme = "ggplot")

```

## 04 vs 09

```{r, fig.height=7, fig.width=8}

m1 <- bregmaOpt_04
m2 <- bregmaOpt_09

beta_cor <- correlationBetweenBetas(beta1 = m1$beta,
                                      beta2 = m2$beta)

betaCombn_cor <- correlationBetweenBetas(beta1 = m1$betaCombn,
                                       beta2 = m2$betaCombn)


par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta 04 v 09 cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$cols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta 04 v 09 cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

# -------------------------------------------------------
# betaCombn:

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor,
          # Rowv = bregmaOpt_04$dendro,
          # Colv = bregmaOpt_09$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$clustCols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta 04 v 09 clusters cor",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(betaCombn_cor)) # more rows than columns so t()

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(betaCombn_cor[pairs$colsix, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$clustCols)[pairs$rowix], # more rows than columns so t()
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "beta 04 v 09 clusters cor paired",
          lhei = c(1,5),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
betaCombn_paired_cors <- diag(betaCombn_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()


hist(beta_paired_cors, breaks = 20)
mean(beta_paired_cors)
sd(beta_paired_cors)

hist(betaCombn_paired_cors, breaks = 20)
mean(betaCombn_paired_cors)
sd(betaCombn_paired_cors)

```

# ==========================
# SPOTlight

# mOB scRNAseq reference
# run through of steps:

## - preproccessing and training

Starting from processed:

 make into sparse mtx
```{r}

# mob_se <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_6_runs_processed_seurat.dge.csv", sep = ",")
# 
# mob_se <- as.sparse(mob_se)

```

 load the processes sparse mtx
```{r}

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

```

 accompanying meta data that has assigned clusters of the cells and wt labels
```{r}

# mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

```

 use metadata to just get the WT cells and the associated clusters from the metadata.
```{r}

# wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
# print(length(wt_cells))

```

```{r}

# mob_se_wt <- mob_se[,wt_cells]

```

 make seurat object for just WT cells
```{r}

# mob_se_wt <- CreateSeuratObject(counts = mob_se_wt, project = "mob",
                                # meta.data = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),])

```

 add in cluster names to object
```{r}

# a lot of metadata info not being added...? try doing manually:
# mob_se_wt[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName
# mob_se_wt[["percent.mito"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$percent.mito

```

based on the paper methods and the values, it looks already log normalized and filtered.

the spotlight pipeline is looking for "assay = RNA" and "slot = counts" so make sure these are part of the seurat object.

For PCA and UMAP, idea is to get clusters. But I already have clusters in the meta data file. So can skip this.

If I wanted to do PCA, this is looking for "scale.data" slot, and to get this I can do:
ScaleData,

or alternatively, I can do SCTransform, which is an alternative to: 1. Normalize, 2. Find Variable Features, 3. Scale data.

Results are saved in a new assay (named SCT by default) with counts being (corrected) counts, data being log1p(counts), and scale.data is the pearson residuals.

But because this data has already been log transformed, and I'm not sure how SCTransform is transforming the data, I should just stick to finding the variable features and then scaling.

But scaling takes time, and again, I already have clusters for cells from metadata. So skip for now.

 SKIP
```{r}

# mob_se_wt <- FindVariableFeatures(mob_se_wt, selection.method = "vst", nfeatures = 3000)
# mob_se_wt <- ScaleData(mob_se_wt, vars.to.regress = c("percent.mito", "nCount_RNA"))

```

 SKIP
```{r}

# mob_se_wt <- RunPCA(mob_se_wt, verbose = FALSE)
# mob_se_wt <- RunUMAP(mob_se_wt, dims = 1:30, verbose = FALSE)
# 
# Seurat::DimPlot(cortex_sc,
#                 group.by = "ClusterName",
#                 label = TRUE) + Seurat::NoLegend()

```

Set the known clusters as the "active.indent"

Then get the markers for each of these clusters. In this case, using the already normalized data.

It looks like under the only assay I have so far, RNA, there is counts and data. But by the looks of it both are the same values so doesnt matter which one is used. In the future, data is probably transformed and counts could be adjusted or maybe raw counts.

```{r}

# Set the known clusters as the "active.indent"
# Seurat::Idents(object = mob_se_wt) <- mob_se_wt@meta.data$ClusterName

# get cluster markers
# cluster_markers_mob_se_wt <- Seurat::FindAllMarkers(object = mob_se_wt, 
#                                               assay = "RNA",
#                                               slot = "data",
#                                               verbose = TRUE, 
#                                               only.pos = TRUE)

```

 now we can train the NMF model
```{r}

# down samples cell from each cluster and select genes marker and variable genes
# se_sc_down <- downsample_se_obj(se_obj = mob_se_wt,
#                                 clust_vr = "ClusterName",
#                                 cluster_markers = cluster_markers_mob_se_wt,
#                                 cl_n = 100, # size to sample from each cluster
#                                 hvg = 3000) # number or NULL. choose additional highly variable genes

```

 TRAIN (takes a while...) This builds NMF object of downsampled reference scRNAseq seurat data
```{r}

# start_time <- Sys.time()
# nmf_mod_mob_wt_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt, 
#                         se_sc = se_sc_down, 
#                         mtrx_spatial = cd, # the original mob st data
#                         clust_vr = "subclass",
#                         ntop = NULL,
#                         hvg = 3000, # number of highly variable genes in addition to the marker genes
#                         transf = "uv",
#                         method = "nsNMF")

# the final genes used must be shared between the selected seurat genes and genes detected in the ST data
# before training, the selected seurat marker gene counts are normalized. "uv" = divide by sd

# nmf_mod_mob_wt <- nmf_mod_mob_wt_ls[[1]]

# [1] "Preparing Gene set"
# [1] "Normalizing count matrix"
# [1] "Seeding initial matrices"
# [1] "Training..."
# [1] "Time to train NMF model was 255.28mins"

```

## - load trained NMF

 Load in the NMF object for the WT trained mOB scRNAseq data
```{r}

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/modeling_merged.20210209.image.RData")


load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/merged_workflow.20210217.image.RData")
load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_with_mob.RData")
nmf_mod_mob_wt <- nmf_mod_mob_wt_ls[[1]]
# first element is the NMF, second is vector of cluster ID label for each of the cells


# this should have all the previous variables and outputs from the LDA models
# plus the SPOTlight NMF outputs after training
# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/modeling_merged.20210211.image.RData")

```

## - reference mtxs

 the W and H matrices of the trained NMF
 W = genes x topics. Think of it like the topic beta mtx. Prob of each gene with given topic
 H = topics x cells. Weight of each topic associated with a cell.
     If normalize each cell by topic weights get proportion of each topic associated with a cell.
```{r}

# get basis matrix W (genes x topic)
w <- basis(nmf_mod_mob_wt)
dim(w)

# get coefficient matrix H (cells x topic)
h <- coef(nmf_mod_mob_wt)
dim(h)

```

 uses the H matrix and the cluster labels to get a new mtx where topic x cluster,
 which is basically the topic proportion of each cluster/cell type.
 Cell types can be made up of multiple topics...
 But looks like typically one topic makes up the vast majority of a given cell type cluster
```{r}

# reference for which cell type(s) a topic represents
ct_topic_profiles <- topic_profile_per_cluster_nmf(h = h,
                              train_cell_clust = nmf_mod_mob_wt_ls[[2]])

```


## - predictions

NOTE:
may need to make sure the same genes are used between the corpus and the scRNAseq NMF for comparison purposes and to see what the NMF model can predict based on a given set of genes in the ST data. I can filter the NMF directly by accessing it via NMF@fit@W/H

The NMF was originally trained with a bunch of Seurat genes that were cluster marker genes based on the scRNA seq data, plus some variable genes. But only genes that were in the ST mob dataset were kept.


 Predict the topic proportions for the ST data
 mtx of topics x spots. Values are weights of each topic.
 Normalize by column sums to get topic proportions
```{r}

mixture_transcriptome <- cd
transf <- "uv" # normalization for the st data. Same as what was done for the scRNAseq data

# Important that the genes are the same in the ST and and the W.
# This function appears to account for that only using genes in ST that are also in W

# NNLS to get topic coefficients for each spot based on genes associated with each topic (W)

profile_mtrx <- predict_spatial_mixtures_nmf(nmf_mod = nmf_mod_mob_wt,
                               mixture_transcriptome = mixture_transcriptome,
                               transf = transf)

```


```{r}

spotlight_spot_topics <- do.call(cbind, lapply(seq(ncol(profile_mtrx)), function(i){
  ct <- profile_mtrx[,i]
  ct/sum(ct)
}))

rownames(spotlight_spot_topics) <- paste("Topic", 1:nrow(profile_mtrx), sep = "_")
colnames(spotlight_spot_topics) <- colnames(profile_mtrx)

# no idea why but simply dividing by colSums does not normalize correctly
# the new colSums after normalizing to the sum of topics in each spot doesn't equal 1..??
# spotlight_spot_topics <- profile_mtrx/colSums(profile_mtrx)
# colSums(spotlight_spot_topics)

spotlight_spot_topics
colSums(spotlight_spot_topics)

```



"profile mtx" also obtained in the below function `mixture_deconvolution_nmf`

Here, it there is a second NNLS step with the ct_topic_profiles" and the "profile_mtrx" (topics in each spot)
to then get a mtx of "cell types" in each spot.

decon_mtrx = spots (rows) x cell types (columns)

"profile_mtrx" would be the topics (rows) in each spot (columns).
In this case nearly identical to t(decon_mtrx) because each topic is associated almost entirely with a single cell type.

```{r}

decon_mtrx <- mixture_deconvolution_nmf(nmf_mod = nmf_mod_mob_wt,
                          mixture_transcriptome = cd,
                          transf = "uv", 
                          reference_profiles = ct_topic_profiles, 
                          min_cont = 0.09) # only keep topics if 9% or more in a spot

# note that last column is an additional columns for the residual error

rownames(decon_mtrx) <- colnames(mixture_transcriptome)
spotlight <- decon_mtrx[,1:(ncol(decon_mtrx)-1)] # last column is residuals

```

## - filtering

For comparison purposes, make sure the same spots are being used
(this an example of why this is important is because "EC2" actually is predicted to be 71% of a spot that was removed from the mob dataset after "cleanCounts"). This is also the only spot that has this cell type asigned. So by removing this spot, also removed EC2, which would be 0 in all other spots.

```{r}

# make sure the spots are the same
spotlightFilt <- spotlight[rownames(mob_opt$theta),]

# drop any clusters that were not detected at all in the ST data
spotlightFilt <- spotlightFilt[,which(!colSums(spotlightFilt) == 0)]

dim(spotlightFilt)

```

 colors for spotlight predicted cell types
```{r}

# assign colors for the remaining spotlight predicted clusters that are present
spotlightFiltCols <- as.factor(colnames(spotlightFilt))
names(spotlightFiltCols) <- colnames(spotlightFilt)
levels(spotlightFiltCols) <- gg_color_hue(length(colnames(spotlightFilt)))

```

## - viz

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- spotlightFilt
cols <- spotlightFiltCols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

what if I removed topics that were in only in 10 spots or less? because a lot of topics are only in a few spots.

```{r}

spotlightFilt_ <- spotlightFilt
spotlightFilt_[spotlightFilt_ > 0.0] <- 1
main_cts <- which(colSums(spotlightFilt_) > 10)

```

```{r, fig.height=6, fig.width=8}

main_ct_cols <- as.vector(spotlightFiltCols[main_cts])
names(main_ct_cols) <- names(main_cts)
main_ct_cols <- as.factor(main_ct_cols)

pos <- mob$pos
m <- spotlightFilt[,main_cts]
cols <- main_ct_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = as.vector(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

```{r, fig.height=6, fig.width=8}

g <- c("N10", "N11", "N4")
pos <- mob$pos
m <- spotlightFilt[,main_cts[g]]
m <- cbind(m, 1 - rowSums(m))
colnames(m) <- c(g, "other")

main_ct_cols <- as.vector(spotlightFiltCols[main_cts][g])
main_ct_cols <- c(main_ct_cols, "gray")
names(main_ct_cols) <- names(main_cts[c(g, "other")])
main_ct_cols <- as.factor(main_ct_cols)

cols <- main_ct_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = as.vector(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")


g <- c("N15", "N14")
pos <- mob$pos
m <- spotlightFilt[,main_cts[g]]
m <- cbind(m, 1 - rowSums(m))
colnames(m) <- c(g, "other")

main_ct_cols <- as.vector(spotlightFiltCols[main_cts][g])
main_ct_cols <- c(main_ct_cols, "gray")
names(main_ct_cols) <- names(main_cts[c(g, "other")])
main_ct_cols <- as.factor(main_ct_cols)

cols <- main_ct_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = as.vector(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")


g <- c("Astro1")
pos <- mob$pos
m <- spotlightFilt[,main_cts[g]]
m <- cbind(m, 1 - m)
colnames(m) <- c(g, "other")

main_ct_cols <- as.vector(spotlightFiltCols[main_cts][g])
main_ct_cols <- c(main_ct_cols, "gray")
names(main_ct_cols) <- names(main_cts[c(g, "other")])
main_ct_cols <- as.factor(main_ct_cols)

cols <- main_ct_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = as.vector(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")


g <- c("OEC4", "OEC2", "OEC1", "Mes1")
pos <- mob$pos
m <- spotlightFilt[,main_cts[g]]
m <- cbind(m, 1 - rowSums(m))
colnames(m) <- c(g, "other")

main_ct_cols <- as.vector(spotlightFiltCols[main_cts][g])
main_ct_cols <- c(main_ct_cols, "gray")
names(main_ct_cols) <- names(main_cts[c(g, "other")])
main_ct_cols <- as.factor(main_ct_cols)

cols <- main_ct_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = as.vector(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "decon_mtrx mob sc ref")

```

```{r}

ct_topic_profiles_r <- round(ct_topic_profiles, 4)

spotlight_ct_topics <- do.call(cbind, lapply(seq(ncol(ct_topic_profiles_r)), function(i){
  ct <- ct_topic_profiles_r[,i]
  ct/sum(ct)
}))

rownames(spotlight_ct_topics) <- paste("Topic", 1:nrow(m), sep = "_")
colnames(spotlight_ct_topics) <- colnames(ct_topic_profiles_r)

# no idea why but simply dividing by colSums does not divide correctly, like in the case of
# "Mural1" in column 12. After apparently normalizing, the colSum is now 1.4855702.
# something doesn't make any sense. So using the above do.call instead which does work...

# m <- ct_topic_profiles_r/colSums(ct_topic_profiles_r) # normalized topic x cell type mat

spotlight_ct_topics
colSums(spotlight_ct_topics)

```

```{r, fig.height=7, fig.width=8}

# correlation_palette <- colorRampPalette(c("black", "red"))(n = 109)
# correlation_breaks = c(seq(0,0.009,length=10),
#                        seq(0.01,1,length=100))

correlation_palette <- colorRampPalette(c("white", "black"))(n = 209)

pairs <- lsatPairs(spotlight_ct_topics)

par(mfrow=c(1,1), mar=c(2,2,2,2))
heatmap.2(t(spotlight_ct_topics[pairs$rowix, pairs$colsix]),
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          # breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(4,5),
          main = "ct_topic_profiles",
          lhei = c(1,5),
          key.xlab = "Proportion",
          key.title = NA)
par(mfrow=c(1,1), oma=c(1.6,10.4,4.8,2.8)) # b, l, t, r
grid(nx = 38, ny = 38)

```

```{r, fig.height=7, fig.width=8}

m_melted <- mtx2ggplotDf(t(spotlight_ct_topics[pairs$rowix, pairs$colsix]))

ggplot(m_melted, aes(rows, columns)) +
    geom_tile(aes(fill = cells), colour = "black") +
    scale_fill_gradient(low = "white",high = "steelblue")

```

## - betas

topic 12 not matched to any cell type. Why?

Some cell types are mixtures of topics and not completely pure matches

therefore to compare to the NMF "beta" (W), will be comparing to the actual "topics" and not cell types.
If want to compare to a "cell type beta", then for each cell type, sum topic-gene vectors in proportion to the topic proportions for a given cell type

```{r}

colnames(w) <- paste("Topic", 1:ncol(w), sep = "_")

w[1:10,1:10]
spotlight_ct_topics[1:10,1:10]

```

```{r}

spotlight_beta <- do.call(rbind, lapply(seq(ncol(spotlight_ct_topics)), function(ix){
  
  # topics for the given cell type in m
  ts <- spotlight_ct_topics[,ix]
  # topics that make up the cell type and their proportions
  ts <- ts[which(ts > 0)]
  
  # w topics and the gene associations, multiplied by the topic proportions of the cell type
  g <- w[,names(ts)] * ts
  
  # if multiple topics, add the adjusted topic gene vectors together
  if (is.null(dim(g)) == FALSE){
    g <- rowSums(g)
  }
  
  # final adjustment to make topic gene proportions sum to 1
  g <- g/sum(g)
  g
  
}))

rownames(spotlight_beta) <- colnames(spotlight_ct_topics)

rowSums(spotlight_beta)

```

Now I have:

"spotlight_beta", cell types x genes ("beta" for cell type clusters)
"w", genes x topics ("beta" for topics, but will need to be t())

"spotlight_ct_topics", topic x cell type proportions

"spotlight_spot_topics", topic x spot, like theta but needs to be t(). Also all spots and topics
"spotlight", spots x cell type proportions (like theta). all spots and cell types
"spotlightFilt", spots x cell type proportions (like theta). spots in cd and just cell types detected

Can use these for comparisons with topic model thetas and betas.

When comparing betas, make sure same genes in both betas


Write function to return objects that contain those matrices for a given spotlight analysis.
Then can quickly generate these for any given ST data set and a NMF trained reference
for easy comparison to the topic model for the same ST data set.


## - wrapper function

```{r}

# nmfRef = the list from SPOTlight::train_nmf()
# stCounts = ST count matrix, genes x spots
SPOTlightPredict <- function(nmfRef, stCounts) {
  
  # get basis matrix W [genes x topics]
  w <- basis(nmfRef[[1]])
  colnames(w) <- paste("Topic", 1:ncol(w), sep = "_")
  # get coefficient matrix H [topics x cells]
  h <- coef(nmfRef[[1]])
  
  # ---------------------------------------------------------------------------
  # reference for which cell type(s) a topic represents
  # ct_topic_profiles = [topics x CellTypes] (seurat clusters)
  # values are coefficients
  # uses the H matrix and the cluster labels to get a new mtx where topic x cluster,
  # Cell types can be made up of multiple topics...
  ct_topic_profiles <- topic_profile_per_cluster_nmf(h = h,
                              train_cell_clust = nmfRef[[2]])
  
  # convert to topic proportions for each cell type
  ct_topic_profiles_r <- round(ct_topic_profiles, 4)
  spotlight_ct_topics <- do.call(cbind, lapply(seq(ncol(ct_topic_profiles_r)), function(i){
    ct <- ct_topic_profiles_r[,i]
    ct/sum(ct)
  }))
  rownames(spotlight_ct_topics) <- paste("Topic", 1:nrow(ct_topic_profiles_r), sep = "_")
  colnames(spotlight_ct_topics) <- colnames(ct_topic_profiles_r)
  
  # now that we have the proportion of each topic for a cell type,
  # use this information to get gene weights (sum to 1) for each cell type
  # (w is gene weights for each topic)
  # do this by getting the topic-gene vectors from w for each cell type and
  # merging them based on the topic proportions for the cell type
  spotlight_beta <- do.call(rbind, lapply(seq(ncol(spotlight_ct_topics)), function(ix){
    # topics for the given cell type in spotlight_ct_topics
    ts <- spotlight_ct_topics[,ix]
    # topics that make up the cell type and their proportions
    ts <- ts[which(ts > 0)]
    # w topics and the gene associations, multiplied by the topic proportions of the cell type
    g <- w[,names(ts)] * ts
    
    # if multiple topics, add the adjusted topic gene vectors together
    if (is.null(dim(g)) == FALSE){
      g <- rowSums(g)
    }
    
    # final adjustment to make topic gene proportions sum to 1
    g <- g/sum(g)
    g
  }))
  rownames(spotlight_beta) <- colnames(spotlight_ct_topics)
  
  # ---------------------------------------------------------------------------
  # [topics x spots]; topic coefficients for each spot
  # This function appears to account for that only using genes in ST that are also in W
  # NNLS to get topic coefficients for each spot based on genes associated with each topic (W)
  profile_mtrx <- predict_spatial_mixtures_nmf(nmf_mod = nmfRef[[1]],
                               mixture_transcriptome = stCounts,
                               transf = "uv")
  # normalize to get topic proportions in each spot
  spotlight_spot_topics <- do.call(cbind, lapply(seq(ncol(profile_mtrx)), function(i){
    ct <- profile_mtrx[,i]
    ct/sum(ct)
  }))
  rownames(spotlight_spot_topics) <- paste("Topic", 1:nrow(profile_mtrx), sep = "_")
  colnames(spotlight_spot_topics) <- colnames(profile_mtrx)
  
  # ---------------------------------------------------------------------------
  # returns [spot x CellType]; proportion of each cell type in each spot
  # topics below `min_cont` are not counted in a spot
  # within this function, `profile_mtrx` is also made but not returned
  decon_mtrx <- mixture_deconvolution_nmf(nmf_mod = nmfRef[[1]],
                            mixture_transcriptome = stCounts,
                            transf = "uv", 
                            reference_profiles = ct_topic_profiles, 
                            min_cont = 0.09) # only keep topics if 9% or more in a spot
  # note that last column is an additional columns for the residual error
  # cleanup to get actual spot-celltype predictions:
  rownames(decon_mtrx) <- colnames(stCounts)
  spotlight <- decon_mtrx[,1:(ncol(decon_mtrx)-1)] # last column is residuals
  # note: all spots and cell types.
  # Possible some cell type will not be detected at all and be 0 for all spots
  
  return(list(topicBeta = t(w), # topic x gene weights that sum to 1 (all genes and topics)
              ctBeta = spotlight_beta, # CellType x gene weights that sum to 1 (all genes and topics)
              ctTopicProps = spotlight_ct_topics, # topic proportion for each cell type
              spotTopicTheta = t(spotlight_spot_topics), # proportion of each topic in each spot (all topics)
              spotCtTheta = spotlight)) # spot x celltype proportions (all spots and cell types)
  
  # if made with original raw `stCounts` then will have thousands of genes and all spots.
  # so when comparing, will need to make sure the betas or thetas have same spots and genes as
  # the `stCounts` they might actually be compared to (corpus for a given topic model)
  # however, a raw `stCounts` can be used to make the SPOTlight predictions at first, and
  # after the betas and theta can be filtered. OR, a processed corpus could be used for
  # SPOTlight, which will probably affect the predicted topics because the gene set used
  # will be smaller. Worth comparing both cases.
  
  # WARNING: SPOTlight functions crash the session if use a corpus with a gene set
  # that is not in the NMF. I think this happens in `SPOTlight::predict_spatial_mixtures()`
  # during the nnls step at the end. Because it generates the full W matrix after selecting
  # genes in the ST mtrx. When the NMF was trained, there was a step that made it only
  # train on the intersecting genes. So under normal circumstances this would not be noticed
  # because all genes should match between W and ST mtrx.
  # But if one were to use a different ST mtrx on the trained NMF, then I bet it would crash
  # because the matrices end up not being comparable shapes.
  
  # looking at the code, it seems the cd is bigger than w. So actually cd is being trimmed
  # such that it's genes equal W. If other way around it all crashes
  
  # remember that during training of the NMF, it got cluster genes, and then only kept
  # those that were in cd.
  # with the corpuses, genes could come up as variable genes that were not picked
  # as cluster genes for the NMF, and thus would not be in the NMF at all
  
}

```




## -----------------------
## Predictions Using:

SPOTlight predictions using different ST corpuses (maybe using the full cd one most fair?)
  assess these to see which is the best one for SPOTlight.

Then compare these predictions with various topic models. Make sure the ST data of the same tissue replicate used.
but the model could be fitted using a corpus with different OD genes or K. 

Get a sl prediction for each tissue rep to compare to topic models of the same rep.

***
It's the same W and H with weights trained from the same scRNAseq data, but different genes being used with NNLS for predictions
***

## 1: cd mob

Same large set of ST genes that informed the cluster genes kept in the NMF.
Predictions using 9850 genes

```{r}

sl_cd <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_ls, stCounts = cd)

```

```{r}

dim(sl_cd$spotCtTheta)
dim(sl_cd$spotTopicTheta)
dim(sl_cd$ctBeta)
dim(sl_cd$topicBeta)
dim(sl_cd$ctTopicProps)

```

```{r, fig.height=7, fig.width=8}

# correlation_palette <- colorRampPalette(c("black", "red"))(n = 109)
# correlation_breaks = c(seq(0,0.009,length=10),
#                        seq(0.01,1,length=100))

correlation_palette <- colorRampPalette(c("white", "black"))(n = 209)

pairs <- lsatPairs(sl_cd$ctTopicProps)

par(mfrow=c(1,1), mar=c(2,2,2,2))
heatmap.2(t(sl_cd$ctTopicProps[pairs$rowix, pairs$colsix]),
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          # breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(4,5),
          main = "sl_cd$ctTopicProps",
          lhei = c(1,5),
          key.xlab = "Proportion",
          key.title = NA)
par(mfrow=c(1,1), oma=c(1.6,10.4,4.8,2.8)) # b, l, t, r
grid(nx = 38, ny = 38)

```

### compare to LDAs:
### - mob_opt 12 topics x 220 genes x 260 spots

Filter the matrices

- same spots in thetas
- only sl clusters/topics that were detected in spots
- make sure same genes in same order in betas
    with different corpuses, OD genes may not have been cluster genes in seurat and so do not appear in the sl beta


 Filtered sl matrices wrt mob_opt LDA model:
```{r}

sl_cd_mob_opt <- filterSPOTlightMtxs(sl = sl_cd, lda_model = mob_opt)

dim(sl_cd_mob_opt$ctThetaFilt)
dim(sl_cd_mob_opt$topicThetaFilt)
dim(sl_cd_mob_opt$ctBetaFilt)
dim(sl_cd_mob_opt$topicBetaFilt)
length(sl_cd_mob_opt$shared_genes)

```

Viz predicted cell type proportions

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_cd_mob_opt$ctThetaFilt
cols <- sl_cd_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl cd predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

Viz predicted topic proportions

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_cd_mob_opt$topicThetaFilt
cols <- sl_cd_mob_opt$topiccols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl cd topic predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

recall that 22 of 38 cell types were actually kept, so some these topics in theory would be trimmed away. The piecharts are proportions, so the remaining topic colors would likely shift to better represent the piecharts for the visualized cell types.

But in terms of comparing thetas and betas in terms of correlation, ok to have all the topics. Remember that some cell types contain multiple topics.

#### theta

```{r}

m1 <- mob_opt
m2 <- sl_cd_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

#### beta

```{r}

m1 <- mob_opt
m2 <- sl_cd_mob_opt

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

### - mob_common_opt 75 topics x 149 genes x 260 spots

Filter the matrices

- same spots in thetas
- only sl clusters/topics that were detected in spots
- make sure same genes in same order in betas
    with different corpuses, OD genes may not have been cluster genes in seurat and so do not appear in the sl beta


 Filtered sl matrices wrt mob_opt LDA model:
```{r}

sl_cd_mob_common <- filterSPOTlightMtxs(sl = sl_cd, lda_model = mob_common_opt)

dim(sl_cd_mob_common$ctThetaFilt)
dim(sl_cd_mob_common$topicThetaFilt)
dim(sl_cd_mob_common$ctBetaFilt)
dim(sl_cd_mob_common$topicBetaFilt)
length(sl_cd_mob_common$shared_genes)

```

#### theta

```{r}

m1 <- mob_common_opt
m2 <- sl_cd_mob_common


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor)) # more rows than columns so t()

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # more rows than columns so t()
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor)) # more rows than columns so t()

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # more rows than columns so t()
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

#### beta

```{r}

m1 <- mob_common_opt
m2 <- sl_cd_mob_common

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor)) # more rows than columns so t()

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$c, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # more rows than columns so t()
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor)) # more rows than columns so t()

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix], # more rows than columns so t()
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix], # more rows than columns so t()
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix]) # more rows than columns so t()

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

## 2: mob 

220 genes corpus for sl predictions via nnls

```{r}

# Need to make sure the W has the same genes in the corpus to be used
c <- t(mob$corpus) # genes x spots

nmfObj <- nmf_mod_mob_wt_ls[[1]]
ww <- nmfObj@fit@W

keep_genes <- rownames(ww)[rownames(ww) %in% rownames(c)]
ww <- ww[keep_genes,]
nmfObj@fit@W <- ww
nmf_mob_wt_filtmob_ls <- list(nmfObj, nmf_mod_mob_wt_ls[[2]])

sl_mob <- SPOTlightPredict(nmfRef = nmf_mob_wt_filtmob_ls, stCounts = c)

```

```{r}

dim(sl_mob$spotCtTheta)
dim(sl_mob$spotTopicTheta)
dim(sl_mob$ctBeta)
dim(sl_mob$topicBeta)
dim(sl_mob$ctTopicProps)

```

### compare to LDAs:
### - mob_opt 12 topics x 220 genes x 260 spots

Filter the matrices

- same spots in thetas
- only sl clusters/topics that were detected in spots
- make sure same genes in same order in betas
    with different corpuses, OD genes may not have been cluster genes in seurat and so do not appear in the sl beta


 Filtered sl matrices wrt mob_opt LDA model:
```{r}

sl_mob_mob_opt <- filterSPOTlightMtxs(sl = sl_mob, lda_model = mob_opt)

dim(sl_mob_mob_opt$ctThetaFilt)
dim(sl_mob_mob_opt$topicThetaFilt)
dim(sl_mob_mob_opt$ctBetaFilt)
dim(sl_mob_mob_opt$topicBetaFilt)
length(sl_mob_mob_opt$shared_genes)

```

Viz predicted cell type proportions

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_mob_mob_opt$ctThetaFilt
cols <- sl_mob_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl mob predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

Viz predicted topic proportions

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_mob_mob_opt$topicThetaFilt
cols <- sl_mob_mob_opt$topiccols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl mob topic predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

#### theta

```{r}

m1 <- mob_opt
m2 <- sl_mob_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

#### beta

```{r}

m1 <- mob_opt
m2 <- sl_mob_mob_opt

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_mob topics vs mob_opt betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```


## 3: mob common

149 gene corpus for sl predictions via nnls

```{r}

# Need to make sure the W has the same genes in the corpus to be used
c <- t(mob_common$corpus) # genes x spots

nmfObj <- nmf_mod_mob_wt_ls[[1]]
ww <- nmfObj@fit@W

keep_genes <- rownames(ww)[rownames(ww) %in% rownames(c)]
ww <- ww[keep_genes,]
nmfObj@fit@W <- ww
nmf_mob_wt_filtmobcommon_ls <- list(nmfObj, nmf_mod_mob_wt_ls[[2]])

sl_mobcommon <- SPOTlightPredict(nmfRef = nmf_mob_wt_filtmobcommon_ls, stCounts = c)

```

```{r}

dim(sl_mobcommon$spotCtTheta)
dim(sl_mobcommon$spotTopicTheta)
dim(sl_mobcommon$ctBeta)
dim(sl_mobcommon$topicBeta)
dim(sl_mobcommon$ctTopicProps)

```

### compare to LDAs:
### - mob_opt 12 topics x 220 genes x 260 spots

Filter the matrices

- same spots in thetas
- only sl clusters/topics that were detected in spots
- make sure same genes in same order in betas
    with different corpuses, OD genes may not have been cluster genes in seurat and so do not appear in the sl beta


 Filtered sl matrices wrt mob_opt LDA model:
```{r}

sl_mobcommon_mob_opt <- filterSPOTlightMtxs(sl = sl_mobcommon, lda_model = mob_opt)

dim(sl_mobcommon_mob_opt$ctThetaFilt)
dim(sl_mobcommon_mob_opt$topicThetaFilt)
dim(sl_mobcommon_mob_opt$ctBetaFilt)
dim(sl_mobcommon_mob_opt$topicBetaFilt)
length(sl_mobcommon_mob_opt$shared_genes)

```

## -----------------------

## Train with `countsClean` cd

Instead of using all genes, just consider the "cleaned ST data"

dim(cd)
[1] 15928   262
dim(countsClean)
[1]  260 7365

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

mob_se_wt <- mob_se[,wt_cells]

meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

```

```{r}

mob_se_wt <- CreateSeuratObject(counts = mob_se_wt, project = "mob_wt_noN10",
                                      meta.data = meta.data.wt)

# a lot of metadata info not being added...? try doing manually:
mob_se_wt[["ClusterName"]] <- meta.data.wt$ClusterName
mob_se_wt[["percent.mito"]] <- meta.data.wt$percent.mito

# Set the known clusters as the "active.indent"
Seurat::Idents(object = mob_se_wt) <- mob_se_wt@meta.data$ClusterName

# get cluster markers
cluster_markers_mob_se_wt <- Seurat::FindAllMarkers(object = mob_se_wt,
                                              assay = "RNA",
                                              slot = "data",
                                              verbose = TRUE,
                                              only.pos = TRUE)

# down samples cell from each cluster and select genes marker and variable genes
se_sc_down_wt <- downsample_se_obj(se_obj = mob_se_wt,
                                clust_vr = "ClusterName",
                                cluster_markers = cluster_markers_mob_se_wt,
                                cl_n = 100, # size to sample from each cluster
                                hvg = 3000) # number or NULL. choose additional highly variable genes on top of cluster genes

start_time <- Sys.time()
nmf_mod_mob_wt_countsClean_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt,
                        se_sc = se_sc_down_wt,
                        mtrx_spatial = t(countsClean), # the original mob st data
                        clust_vr = "ClusterName",
                        ntop = NULL, # number unique markers per cluster, otherwise all of them
                        hvg = 3000, # number of highly variable genes in addition to the marker genes
                        transf = "uv",
                        method = "nsNMF")
total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train NMF model was %smins", total_t))

# save(nmf_mod_mob_wt_countsClean_ls, file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_ls.RData")

```

```{r}

sl_countsClean <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_countsClean_ls, stCounts =t(countsClean))

```

```{r}

dim(sl_countsClean$spotCtTheta)
dim(sl_countsClean$spotTopicTheta)
dim(sl_countsClean$ctBeta)
dim(sl_countsClean$topicBeta)
dim(sl_countsClean$ctTopicProps)

```

```{r, fig.height=7, fig.width=8}

# correlation_palette <- colorRampPalette(c("black", "red"))(n = 109)
# correlation_breaks = c(seq(0,0.009,length=10),
#                        seq(0.01,1,length=100))

correlation_palette <- colorRampPalette(c("white", "black"))(n = 209)

pairs <- lsatPairs(sl_countsClean$ctTopicProps)

par(mfrow=c(1,1), mar=c(2,2,2,2))
heatmap.2(t(sl_countsClean$ctTopicProps[pairs$rowix, pairs$colsix]),
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$cols),
          col = correlation_palette,
          # breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(4,5),
          main = "sl_countsClean$ctTopicProps",
          lhei = c(1,5),
          key.xlab = "Proportion",
          key.title = NA)
# par(mfrow=c(1,1), oma=c(1.6,10.4,4.8,2.8)) # b, l, t, r
# grid(nx = 38, ny = 38)

```

will still need to filter to drop cts and topics that were not present

```{r}

sl_countsClean_mob_opt <- filterSPOTlightMtxs(sl = sl_countsClean, lda_model = mob_opt)

dim(sl_countsClean_mob_opt$ctThetaFilt)
dim(sl_countsClean_mob_opt$topicThetaFilt)
dim(sl_countsClean_mob_opt$ctBetaFilt)
dim(sl_countsClean_mob_opt$topicBetaFilt)
length(sl_countsClean_mob_opt$shared_genes)

```


```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_countsClean_mob_opt$ctThetaFilt
cols <- sl_countsClean_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl_countsClean_mob_opt predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_countsClean_mob_opt$topicThetaFilt
cols <- sl_countsClean_mob_opt$topiccols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl_countsClean_mob_opt topic predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

## vs `mob_common_opt` lda corpus

compare the sl predictions using the countsClean ST filtered gene set (so 6336 cluster genes used in W, and using the countsClean corpus from meringue mob set), with the lda model using the same meringue mob corpus but with topics determined from the common set of 149 OD genes between all the mob replicates.

```{r}

sl_countsClean_mob_common <- filterSPOTlightMtxs(sl = sl_countsClean, lda_model = mob_common_opt)

dim(sl_countsClean_mob_common$ctThetaFilt)
dim(sl_countsClean_mob_common$topicThetaFilt)
dim(sl_countsClean_mob_common$ctBetaFilt)
dim(sl_countsClean_mob_common$topicBetaFilt)
length(sl_countsClean_mob_common$shared_genes)

```

### theta

```{r}

m1 <- mob_common_opt
m2 <- sl_countsClean_mob_common


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$theta,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt ct thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt ct thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt topics thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean_mob_common vs mob_common_opt topics thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

### beta

```{r}

m1 <- mob_common_opt
m2 <- sl_countsClean_mob_common

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$beta[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$ctBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt ct betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt ct betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics versus clusters

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$betaCombn[,m2$shared_genes],
                                      beta2 = m2$topicBetaFilt[,m2$shared_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt topics betaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs mob_common_opt topics betaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

## -----------------------

## Compare sl models

## `sl_cd` vs `sl_mob`

sl_cd is the predicted topics and cell types use all the shared seurat cluster and St genes.
sl_mob is the above model, but only genes present in meringue mob corpus are kept (after training NMF) and used to predict cell types.

(prediction is based on nnls using the reference)

In sl_cd, the predictions 22 cell types were present. In sl_mob all 38 clusters were present. Strange even though less genes. Maybe not enough to separate??

Compare the correlation between these two predictions using different gene sets with weights trained from the same scRNAseq data.


### theta

use the filtered matrices because only have cell types and topics that were detected and the same spots

For theta doesn't matter what st corpus it was filtered with b/c same premise: only spots that were kept and drop cts and clusters that were 0.

ex:
```{r}

dim(sl_cd_mob_opt$ctThetaFilt)
dim(sl_cd_mob_opt$topicThetaFilt)
dim(sl_cd_mob_common$ctThetaFilt)
dim(sl_cd_mob_common$topicThetaFilt)

dim(sl_mob_mob_opt$ctThetaFilt)
dim(sl_mob_mob_opt$topicThetaFilt)

```
note how the cell types and topics kept are the same regardless of the filtering. However, they change when there is a different gene set used in W for the predictions during nnls

For beta however, the shared genes with the corpus are filtered for so will need to use the unfiltered sl

```{r}

m1 <- sl_cd_mob_opt
m2 <- sl_mob_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt,
                                      theta2 = m2$ctThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs sl_mob ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs sl_mob ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt,
                                      theta2 = m2$topicThetaFilt)

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs sl_mob topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vs sl_mob topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

not very well correlated. The spotCtTheta is just a cleaned up decon_mtrx. I didn't do anything else. So this is real based off the two predictions using different gene sets from the same trained reference. spotTopicTheta was the profile_mtrx, which I did adjust coefficients so that they would sum to one. I don't see anything obvious mistakes if there are any.

### beta

the topic betas should actually correlate perfectly because they are just the t(w). Will have to make sure the same genes are used in both. But there are directly from the same trained reference.

The ctBetas also should be the same. because the H matrix would be the same and I'm just combining the same gene wrt the topics that make up each cell type.

```{r}

keep_genes <- colnames(sl_cd$ctBeta)[colnames(sl_cd$ctBeta) %in% colnames(sl_mob$ctBeta)]
length(keep_genes)

```


```{r}

m1 <- sl_cd
m2 <- sl_mob

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[,keep_genes],
                                      beta2 = m2$ctBeta[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vssl_mob ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd vssl_mob ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[,keep_genes],
                                      beta2 = m2$topicBeta[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs sl_mob beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_cd topics vs sl_mob beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

perfect correlation.

makes sense. In `SPOTlightPredict`, I just take W as the topicBeta. If W subetted beforehand, then it is just those genes. I actually do not adjust those to sum to one in this case. (For sl_cd, the original reference, they do sum to 1). When i make ctBeta, I actually do adjust the gene values so they sum to 1.

When I `filterSPOTlightMtxs`, I also just take subset of genes. For sl_cd, then they would not add to 1 but I think for sl_mob_mob_opt they would? So maybe I should make sure everything sums to 1 during filtering?

```{r}

rowSums(sl_cd$topicBeta) # full W, the 9850 genes should sum to 1. When I compare to sl_mob$topicBeta, values are actually identical because sl_mob$topicBeta I did not adjust them to 1
rowSums(sl_cd$ctBeta) # I adjust this to sum to 1 after combining genes in topics that make up each cell type

rowSums(sl_mob$topicBeta) # W was subsetted to 211 genes but not adjusted
rowSums(sl_mob$ctBeta) # I adjust this to sum to 1 after combining genes in topics that make up each cell type


```

Now for the filtered lists:

```{r}

rowSums(sl_cd_mob_opt$topicBetaFilt) # now it has been filtered based on shared genes in mob_opt, so 211. And it is identical to the subsetted W that is used for topicBeta in sl_mob.

rowSums(sl_mob_mob_opt$topicBetaFilt) # this stays the same because same 211 genes that were originally subsetted for W when trying to deconvolve spots via nnls with just 211 genes


rowSums(sl_mob_mob_opt$ctBetaFilt) # same genes being used, so nothing changes and sums to 1 as per the adjustment when making ctBeta

rowSums(sl_cd_mob_opt$ctBetaFilt) # took subset of genes for filtering when ctBeta had 9850 beforehand. Interestingly, looks very similar to topic rowSums when subsetted and not adjusted to 1. Most cell types correspond to 1 topic, so nearly equivalent. Then, must mean that the


```

Adjusted such that when filtering, the betas get adjusted so the gene values sum to 1

## `sl_cd` vs `sl_cd_noN10`

### theta

#### all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_cd
m2 <- sl_cd_noN10


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta,
                                      theta2 = m2$spotCtTheta)

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

theta_cor <- correlationBetweenThetas(theta1 = m1$spotTopicTheta,
                                      theta2 = m2$spotTopicTheta)

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)


```

interesting, shows that for the most part, the same cell types correlate really well in terms of the space they were asssigned to. Also may help indicate which types are really distinct, because some cell types do correlate with other cell types. Like the N's for example. And actually when removing N10, other N's were assigned to the same region. Can see here in this theta correlation that they also correlate in space. 

Maybe try removing `Mono` next? Does this encompass a distinct tissue layer? Also Try `Astro1` because the other astro doest really correspond. Perhaps a better options. For N's, a lot of similar ones that then seem to be used to make up for another N that might be missing. Or `drop all the Astros...`

#### filtered

```{r}

m1 <- sl_cd_mob_opt
m2 <- sl_cd_noN10_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, #22
                                      theta2 = m2$ctThetaFilt) # 23

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noN10 mob_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noN10 mob_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt, # 36
                                      theta2 = m2$topicThetaFilt) # 34

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noN10 mob_opt topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noN10 mob_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

### beta

actually the genes do differ between `sl_cd` and `sl_cd_noN10` so make sure same ones are being used

```{r}

keep_genes <- colnames(sl_cd$ctBeta)[colnames(sl_cd$ctBeta) %in% colnames(sl_cd_noN10$ctBeta)]
length(keep_genes)

```

```{r}

m1 <- sl_cd
m2 <- sl_cd_noN10

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[,keep_genes], # 38 x 9850
                                      beta2 = m2$ctBeta[,keep_genes]) # 37 x 9862

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[,keep_genes],
                                      beta2 = m2$topicBeta[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noN10 topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

## `sl_cd` vs `sl_cd_noAstro`

### theta

#### all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_cd
m2 <- sl_cd_noAstro


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta, # 38
                                      theta2 = m2$spotCtTheta) # 35

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

theta_cor <- correlationBetweenThetas(theta1 = m1$spotTopicTheta,
                                      theta2 = m2$spotTopicTheta)

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)


```

```{r}

length(which(!colSums(sl_cd$spotCtTheta) == 0))
length(which(!colSums(sl_cd_noAstro$spotCtTheta) == 0))

```

Some cell types were not detected initially. (Above rows for sl_cd). Interesting that sl_cd_noAstros, while Atros1-3 were dropped, still ended up with same number of cell types present as the original (23). EC1 not detected in sl_cd, but now detected in sl_cd_noAstros. So cell type presence got shifted around when clusters dropped. Different marker genes maybe? There were actually more marker genes for the `noN10` NMF training, even though less topics initialized and missing clusters. Maybe more differential genes able to be selected? SHould look into how seurat is picking markers and how many for each cluster with and without dropping...

```{r}

dim(nmf_mod_mob_wt_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_noN10_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_noAstros_ls[[1]]@fit@W)

```


#### filtered

```{r}

m1 <- sl_cd_mob_opt
m2 <- sl_cd_noAstro_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, #22
                                      theta2 = m2$ctThetaFilt) # 23

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noAstro mob_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noAstro mob_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt, # 36
                                      theta2 = m2$topicThetaFilt) # 33

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noAstro mob_opt topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd mob_opt vs noAstro mob_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

### beta

actually the genes do differ between `sl_cd` and `sl_cd_noAstro` so make sure same ones are being used

```{r}

keep_genes <- colnames(sl_cd$ctBeta)[colnames(sl_cd$ctBeta) %in% colnames(sl_cd_noAstro$ctBeta)]
length(keep_genes)

```

```{r}

m1 <- sl_cd
m2 <- sl_cd_noAstro

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[,keep_genes], # 38 x 9850
                                      beta2 = m2$ctBeta[,keep_genes]) # 37 x 9862

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[,keep_genes],
                                      beta2 = m2$topicBeta[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_cd_noAstro topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

Transcriptionally, cell types and columns still match up really well and model doesnt get confused by assigning gene patterns from one topic or cell type to another. This makes sense given the cluster genes are primarily the same, although some small differences and thus why not 100%.

But the thetas do change and are are less perfectly correlated. So model able to define cell types well transcriptionally (b/c have that scRNAseq cluster reference). but theta changes. Makes sense. Actually if you look at `N14` and `N15` for the `sl_cd`, they too are where the `Astro1s` are. But seem to take up larger percentages now in the `sl_cd_noAstros`. 

## `sl_cd` vs `sl_countsClean`

### theta

#### all spots, cts, topics

number of spots are different for the unfiltered (`sl_cd` has all 262)

```{r}

keep_spots <- rownames(sl_cd$spotCtTheta)[which(rownames(sl_cd$spotCtTheta) %in% rownames(sl_countsClean$spotCtTheta))]

```

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_cd
m2 <- sl_countsClean


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta[keep_spots,], # 38
                                      theta2 = m2$spotCtTheta[keep_spots,]) # 38

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

theta_cor <- correlationBetweenThetas(theta1 = m1$spotTopicTheta[keep_spots,],
                                      theta2 = m2$spotTopicTheta[keep_spots,])

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)


```

#### filtered

topics and cts not detected removed and bad spots removed (260 remaining)

```{r}

m1 <- sl_cd_mob_opt
m2 <- sl_countsClean_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, #22
                                      theta2 = m2$ctThetaFilt) # 17

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt, # 36
                                      theta2 = m2$topicThetaFilt) # 36

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

### beta

actually the genes do differ between `sl_cd` and `sl_countsClean` so make sure same ones are being used

```{r}

keep_genes <- colnames(sl_cd$ctBeta)[colnames(sl_cd$ctBeta) %in% colnames(sl_countsClean$ctBeta)]
length(keep_genes)

```

```{r}

m1 <- sl_cd
m2 <- sl_countsClean

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[,keep_genes], # 38 x 9850; adjusted to 6336
                                      beta2 = m2$ctBeta[,keep_genes]) # 38 x 6336

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[,keep_genes],
                                      beta2 = m2$topicBeta[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_cd vs sl_countsClean topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

so even after cleaning and using the cleaned set of genes for training and then prediction, very similar to using all of the genes without cleaning. So for now use countsCleaned when training NMF and also dropping clusters. But in general I don't think the results should differ very much.

## `sl_countsClean` vs `sl_countsClean_noAstros`

### remove all Astros

using countsClean

```{r}

# load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# # mob_se
# 
# mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")
# 
# wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
# 
# mob_se_wt <- mob_se[,wt_cells]
# meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]
# 
# meta.data.wt.noAstros <- meta.data.wt[which(!meta.data.wt$ClusterName %in% c("Astro1", "Astro2", "Astro3")),]
# keepCells <- mob_meta[which(!mob_meta$ClusterName %in% c("Astro1", "Astro2", "Astro3")),]$"X"
# mob_se_wt_noAstros <- mob_se_wt[,which(colnames(mob_se_wt) %in% keepCells)]

```

```{r}

# mob_se_wt_noAstros <- CreateSeuratObject(counts = mob_se_wt_noAstros, project = "mob_wt_noAstros",
#                                       meta.data = meta.data.wt.noAstros)
# 
# # a lot of metadata info not being added...? try doing manually:
# mob_se_wt_noAstros[["ClusterName"]] <- meta.data.wt.noAstros$ClusterName
# mob_se_wt_noAstros[["percent.mito"]] <- meta.data.wt.noAstros$percent.mito
# 
# # Set the known clusters as the "active.indent"
# Seurat::Idents(object = mob_se_wt_noAstros) <- mob_se_wt_noAstros@meta.data$ClusterName

```


```{r}

# get cluster markers
# cluster_markers_mob_se_wt_noAstros <- Seurat::FindAllMarkers(object = mob_se_wt_noAstros,
#                                               assay = "RNA",
#                                               slot = "data",
#                                               verbose = TRUE,
#                                               only.pos = TRUE)
# 
# # down samples cell from each cluster and select genes marker and variable genes
# se_sc_down_wt_noAstros <- downsample_se_obj(se_obj = mob_se_wt_noAstros,
#                                 clust_vr = "ClusterName",
#                                 cluster_markers = cluster_markers_mob_se_wt_noAstros,
#                                 cl_n = 100, # size to sample from each cluster
#                                 hvg = 3000) # number or NULL. choose additional highly variable genes on top of cluster genes
# 
# start_time <- Sys.time()
# nmf_mod_mob_wt_countsClean_noAstros_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt_noAstros,
#                         se_sc = se_sc_down_wt_noAstros,
#                         mtrx_spatial = t(countsClean), # the original mob st data
#                         clust_vr = "ClusterName",
#                         ntop = NULL, # number unique markers per cluster, otherwise all of them
#                         hvg = 3000, # number of highly variable genes in addition to the marker genes
#                         transf = "uv",
#                         method = "nsNMF")
# total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
# print(sprintf("Time to train NMF model was %smins", total_t))
# 
# save(nmf_mod_mob_wt_countsClean_noAstros_ls, file = "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_noAstros_ls.RData")

```

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_noAstros_ls.RData")

```

```{r}

sl_countsClean_noAstros <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_countsClean_noAstros_ls, stCounts =t(countsClean))

```

```{r}

dim(sl_countsClean_noAstros$ctBeta)
dim(sl_countsClean_noAstros$topicBeta)
dim(sl_countsClean_noAstros$ctTopicProps)
dim(sl_countsClean_noAstros$spotCtTheta)
dim(sl_countsClean_noAstros$spotTopicTheta)

```


```{r}

sl_countsClean_noAstros_mob_opt <- filterSPOTlightMtxs(sl = sl_countsClean_noAstros, lda_model = mob_opt)

dim(sl_countsClean_noAstros_mob_opt$ctThetaFilt)
dim(sl_countsClean_noAstros_mob_opt$topicThetaFilt)
dim(sl_countsClean_noAstros_mob_opt$ctBetaFilt)
dim(sl_countsClean_noAstros_mob_opt$topicBetaFilt)
length(sl_countsClean_noAstros_mob_opt$shared_genes)

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_countsClean_noAstros_mob_opt$ctThetaFilt
cols <- sl_countsClean_noAstros_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl_countsClean_noAstro topic predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

### theta

#### all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_countsClean
m2 <- sl_countsClean_noAstros


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta, # 38
                                      theta2 = m2$spotCtTheta) # 35

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

theta_cor <- correlationBetweenThetas(theta1 = m1$spotTopicTheta,
                                      theta2 = m2$spotTopicTheta)

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)


```

```{r}

length(which(!colSums(sl_countsClean$spotCtTheta) == 0))
length(which(!colSums(sl_countsClean_noAstros$spotCtTheta) == 0))

```

```{r}

dim(nmf_mod_mob_wt_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_noN10_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_noAstros_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_countsClean_ls[[1]]@fit@W)
dim(nmf_mod_mob_wt_countsClean_noAstros_ls[[1]]@fit@W)

```

#### filtered

```{r}

m1 <- sl_countsClean_mob_opt
m2 <- sl_countsClean_noAstros_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, # 17
                                      theta2 = m2$ctThetaFilt) # 18

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noAstro mob_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noAstro mob_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt, # 36
                                      theta2 = m2$topicThetaFilt) # 33

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noAstro mob_opt topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noAstro mob_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

### beta

actually the genes do differ between `sl_cd` and `sl_cd_noAstro` so make sure same ones are being used

```{r}

keep_genes <- colnames(sl_countsClean$ctBeta)[colnames(sl_countsClean$ctBeta) %in% colnames(sl_countsClean_noAstros$ctBeta)]
length(keep_genes)

```

```{r}

m1 <- sl_countsClean
m2 <- sl_countsClean_noAstros

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[,keep_genes], # 38 x 6336
                                      beta2 = m2$ctBeta[,keep_genes]) # 35 x 6288

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[,keep_genes], # 38
                                      beta2 = m2$topicBeta[,keep_genes]) # 35

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

just the cts present:
```{r}

cts1 <- rownames(sl_countsClean_mob_opt$ctBetaFilt)
cts1
cts2 <- rownames(sl_countsClean_noAstros_mob_opt$ctBetaFilt)
cts2

tps1 <- rownames(sl_countsClean_mob_opt$topicBetaFilt)
tps1
tps2 <- rownames(sl_countsClean_noAstros_mob_opt$topicBetaFilt)
tps2

```


```{r}

m1 <- sl_countsClean
m2 <- sl_countsClean_noAstros

# -------------------------------------------------------
# sl predicted cell types

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$ctBeta[cts1,keep_genes], # 17 x 6336
                                      beta2 = m2$ctBeta[cts2,keep_genes]) # 18 x 6288

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro ct beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted topics

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1$topicBeta[tps1,keep_genes], # 38
                                      beta2 = m2$topicBeta[tps2,keep_genes]) # 33

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro topics beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(beta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noAstro topics beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$colsix, pairs$rowix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

## `sl_countsClean` vs `sl_countsClean_noOECs`

### theta

#### all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_countsClean
m2 <- sl_countsClean_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta, # 38
                                      theta2 = m2$spotCtTheta) # 33

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noOEC ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

theta_cor <- correlationBetweenThetas(theta1 = m1$spotTopicTheta,
                                      theta2 = m2$spotTopicTheta)

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs sl_countsClean_noOEC ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)


```

#### filtered

```{r}

m1 <- sl_countsClean_mob_opt
m2 <- sl_countsClean_noOEC_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, # 17
                                      theta2 = m2$ctThetaFilt) # 19

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noOEC mob_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noOEC mob_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$topicThetaFilt, # 36
                                      theta2 = m2$topicThetaFilt) # 31

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noOEC mob_opt topics theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$topiccols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs noOEC mob_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# `sl_countsClean_noOECs` vs `mob_common_opt`

## theta

```{r}

m1 <- mob_common_opt
m2 <- sl_countsClean_noOEC_mob_opt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta, # 75
                                      theta2 = m2$ctThetaFilt) # 19

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$ctcols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics

theta_cor <- correlationBetweenThetas(theta1 = m1$theta, # 75
                                      theta2 = m2$topicThetaFilt) # 31

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt topics theta theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$cols)[pairs$colsix],
          ColSideColors = as.vector(m2$topiccols)[pairs$rowix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt topics theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)


# -------------------------------------------------------
# sl predicted cell types versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn, # 18
                                      theta2 = m2$ctThetaFilt) # 19

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt ct thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt ct thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

# -------------------------------------------------------
# sl predicted topics versus clusters

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn, # 18
                                      theta2 = m2$topicThetaFilt) # 31

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols),
          ColSideColors = as.vector(m2$topiccols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt topics thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          RowSideColors = as.vector(m1$clustCols)[pairs$rowix],
          ColSideColors = as.vector(m2$topiccols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean noOECs vs mob_common_opt topics thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

## -----------------------


# Missing Cell Clusters:

might make more sense to retrain NMF with a dropped cluster b/c the genes are also picked based on the cluster. Alternatively could drop cluster and genes from W and H, but only if the matrices are identical either way. Then for other clusters can drop them and analyze faster. Will have to be smart in the beginning. Pick a cluster that is well represented and also makes up a distinct cell layer. How does the model do when this is missing? Correlate with other NMF, and with LDAs. Assess to a ground truth to measure performance change? Might have to stick to MERFISH if this this case because actual GT. But keep in mind the merfish vocab was based on genes that were selected specifically to separate cell types so all models would be exprected to do better than normal.


## **Important and interesting point:
Intersting: sl_cd trained with cd intersecting genes, and then used to predict on cd, get Astro 1 as the circle layer around middle (and remember when comparing to other corpuses I filter, but this just cleans up spots when looking at thetas at least. THe predictions have already been made). Middle is also N10. These are the predicted thetas. 

Now if I remove genes from W (post trained with cd), and then use to predict, on mob (just using 211 genes), or other corpus, but again, using different gene set to predict, get different cell types asigned to layers on tissue. So the marker genes uses are crucial for prediction. 

Thus, how the NMF is trained (and thus the generation of the gene weights to the topics in W (and the weights also sum to 1, based on gene set, so weights specific wrt the genes used), or the genes ultimately used for prediction) matters. 

So one will have to use the same ST data for prediction that was used to select genes initially for the NMD training.

After training and predicting, for comparing to other corpuses and models, fine to filter and use shared set gene and spots. And ok to readjust the gene value proportions of the new shared set. (I think readjusting the gene wegiths to sum to one for the shared set actually maintains their relative proportions anyways as I saw when comparing models above)


I think NMF should be trained based on all genes in cd (or whatever full ST data set is being used)
And predictions should likely be done using the whole thing, Because why wouldn't you do that?

But for comparison to LDA, will need to take subsets of the genes to compare Betas

But if I wanted to test predictions with using just a subset of genes to make it a similar vocabulary to LDA, I think I can just take gene subsets as I have been doing. But maybe W should be readjusted to 1 after subsetting?? I haven't done this yet. I just take the same values but only for genes of interest.

Although during training, perhaps the values would change if the gene set was a lot smaller than 9850..?

Not just change, but different genes picked. Removing N10 actually ended up with more cluster genes in the NMF for some reason.

# Retraining NMF (remove N10)

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

mob_se_wt <- mob_se[,wt_cells]

meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

```

remove entries that are part of a cluster to remove

If going to focus on training with using entire ST data set as is probably a reasonable thing to do, then focus on the predictions of `sl_cd`, using shared 9850 genes in cd and then predictions on cd using all genes.

(Note that comparing `sl_cd` and `sl_mob` showed different cell clusters being assigned to different cell layers/regions and topics and didn't correlate well). Interesting because the thetas are just the deconv_mtrx and the profile_mtrx after normalizing so the topics in a spot sum to 1. Both rely on W during nnls, which was the only difference.)

Example: Here, Astro1 looked like a defined layer in results from sl_cd, but was only a few spots in sl_mob. But N10 looks like the same inner region in both cases. So could be a good option.

```{r}

meta.data.wt.noN10 <- meta.data.wt[which(!meta.data.wt$ClusterName %in% c("N10")),]
keepCells <- mob_meta[which(!mob_meta$ClusterName %in% c("N10")),]$"X"
mob_se_wt_noN10 <- mob_se_wt[,which(colnames(mob_se_wt) %in% keepCells)]

```

```{r}

mob_se_wt_noN10 <- CreateSeuratObject(counts = mob_se_wt_noN10, project = "mob_wt_noN10",
                                      meta.data = meta.data.wt.noN10)

# a lot of metadata info not being added...? try doing manually:
mob_se_wt_noN10[["ClusterName"]] <- meta.data.wt.noN10$ClusterName
mob_se_wt_noN10[["percent.mito"]] <- meta.data.wt.noN10$percent.mito

# Set the known clusters as the "active.indent"
Seurat::Idents(object = mob_se_wt_noN10) <- mob_se_wt_noN10@meta.data$ClusterName

# get cluster markers
cluster_markers_mob_se_wt_noN10 <- Seurat::FindAllMarkers(object = mob_se_wt_noN10,
                                              assay = "RNA",
                                              slot = "data",
                                              verbose = TRUE,
                                              only.pos = TRUE)

```

 now we can train the NMF model
```{r}

# down samples cell from each cluster and select genes marker and variable genes
se_sc_down_wt_noN10 <- downsample_se_obj(se_obj = mob_se_wt_noN10,
                                clust_vr = "ClusterName",
                                cluster_markers = cluster_markers_mob_se_wt_noN10,
                                cl_n = 100, # size to sample from each cluster
                                hvg = 3000) # number or NULL. choose additional highly variable genes on top of cluster genes

```

 TRAIN (takes a while...) This builds NMF object of downsampled reference scRNAseq seurat data
```{r}

start_time <- Sys.time()
nmf_mod_mob_wt_noN10_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt_noN10,
                        se_sc = se_sc_down_wt_noN10,
                        mtrx_spatial = cd, # the original mob st data
                        clust_vr = "ClusterName",
                        ntop = NULL, # number unique markers per cluster, otherwise all of them
                        hvg = 3000, # number of highly variable genes in addition to the marker genes
                        transf = "uv",
                        method = "nsNMF")
total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train NMF model was %smins", total_t))

# the final genes used must be shared between the selected seurat genes and genes detected in the ST data
# before training, the selected seurat marker gene counts are normalized. "uv" = divide by sd

# "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_with_mob_wt_noN10.RData"

# nmf_mod_mob_wt <- nmf_mod_mob_wt_ls[[1]]

# [1] "Preparing Gene set"
# [1] "Normalizing count matrix"
# [1] "Seeding initial matrices"
# [1] "Training..."
# [1] "Time to train NMF model was 1006.55mins" # but stopped overnight..started back up in morning

```

```{r}

sl_cd_noN10 <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_noN10_ls, stCounts = cd)

```

```{r}

sl_cd_noN10_mob_opt <- filterSPOTlightMtxs(sl = sl_cd_noN10, lda_model = mob_opt)

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_cd_noN10_mob_opt$ctThetaFilt
cols <- sl_cd_noN10_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl cd no N10 predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```


# Remove all Astros

```{r}

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"

mob_se_wt <- mob_se[,wt_cells]
meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

meta.data.wt.noAstros <- meta.data.wt[which(!meta.data.wt$ClusterName %in% c("Astro1", "Astro2", "Astro3")),]
keepCells <- mob_meta[which(!mob_meta$ClusterName %in% c("Astro1", "Astro2", "Astro3")),]$"X"
mob_se_wt_noAstros <- mob_se_wt[,which(colnames(mob_se_wt) %in% keepCells)]

```

```{r}

mob_se_wt_noAstros <- CreateSeuratObject(counts = mob_se_wt_noAstros, project = "mob_wt_noAstros",
                                      meta.data = meta.data.wt.noAstros)

# a lot of metadata info not being added...? try doing manually:
mob_se_wt_noAstros[["ClusterName"]] <- meta.data.wt.noAstros$ClusterName
mob_se_wt_noAstros[["percent.mito"]] <- meta.data.wt.noAstros$percent.mito

# Set the known clusters as the "active.indent"
Seurat::Idents(object = mob_se_wt_noAstros) <- mob_se_wt_noAstros@meta.data$ClusterName

```


```{r}

# get cluster markers
cluster_markers_mob_se_wt_noAstros <- Seurat::FindAllMarkers(object = mob_se_wt_noAstros,
                                              assay = "RNA",
                                              slot = "data",
                                              verbose = TRUE,
                                              only.pos = TRUE)

# down samples cell from each cluster and select genes marker and variable genes
se_sc_down_wt_noAstros <- downsample_se_obj(se_obj = mob_se_wt_noAstros,
                                clust_vr = "ClusterName",
                                cluster_markers = cluster_markers_mob_se_wt_noAstros,
                                cl_n = 100, # size to sample from each cluster
                                hvg = 3000) # number or NULL. choose additional highly variable genes on top of cluster genes

start_time <- Sys.time()
nmf_mod_mob_wt_noAstros_ls <- train_nmf(cluster_markers = cluster_markers_mob_se_wt_noAstros,
                        se_sc = se_sc_down_wt_noAstros,
                        mtrx_spatial = cd, # the original mob st data
                        clust_vr = "ClusterName",
                        ntop = NULL, # number unique markers per cluster, otherwise all of them
                        hvg = 3000, # number of highly variable genes in addition to the marker genes
                        transf = "uv",
                        method = "nsNMF")
total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train NMF model was %smins", total_t))

```

```{r}

sl_cd_noAstro <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_noAstros_ls, stCounts = cd)

```

```{r}

sl_cd_noAstro_mob_opt <- filterSPOTlightMtxs(sl = sl_cd_noAstro, lda_model = mob_opt)

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_cd_noAstro_mob_opt$ctThetaFilt
cols <- sl_cd_noAstro_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl cd no Astro predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

# Remove all OECs

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/spotlight_nmf_train_mob_wt_countsClean_noOECs_ls.RData")
# nmf_mod_mob_wt_countsClean_noOECs_ls

```

## `sl_countsClean_noOEC`

```{r}

sl_countsClean_noOEC <- SPOTlightPredict(nmfRef = nmf_mod_mob_wt_countsClean_noOECs_ls, stCounts = t(countsClean))

```

```{r}

sl_countsClean_noOEC_mob_opt <- filterSPOTlightMtxs(sl = sl_countsClean_noOEC, lda_model = mob_opt)

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- sl_countsClean_noOEC_mob_opt$ctThetaFilt
cols <- sl_countsClean_noOEC_mob_opt$ctcols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "sl_countsClean_noOEC predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

# IGNORE Filtering from pretrained NMF

```{r}

nmfObj <- nmf_mod_mob_wt_ls[[1]]

ww <- nmfObj@fit@W
hh <- nmfObj@fit@H

dim(ww)
dim(hh)

```

The genes chosen for the clusters also change when filtering out the clusters so need to retrain from beginning...can't just select from W and H

# RMSE compute?

# ==========================
# RCTD

# mOB scRNAseq reference

## make reference

 load the processes sparse mtx
```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

```
 accompanying meta data that has assigned clusters of the cells and wt labels
```{r}

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

```

 use metadata to just get the WT cells and the associated clusters from the metadata.
```{r}

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"
print(length(wt_cells))

```

```{r}

mob_se_wt <- mob_se[,wt_cells]

```

 make seurat object for just WT cells
```{r}

mob_se_wt <- CreateSeuratObject(counts = mob_se_wt, project = "mob",
                                meta.data = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),])

```

 add in cluster names to object
```{r}

# a lot of metadata info not being added...? try doing manually:
mob_se_wt[["ClusterName"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$ClusterName
mob_se_wt[["percent.mito"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$percent.mito
mob_se_wt[["nUMI"]] <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$nUMI

```

```{r}

# write.csv(x=mob_se_wt@meta.data[,c("ClusterName", "nUMI")], file="meta_data.csv")
# write.csv(x=mob_se_wt@assays$RNA@counts, file="dge.csv")

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mob_RCTD_ref/"
reference <- dgeToSeurat(refdir)

```

```{r}

# write.csv(x = data.frame(Cluster = unique(mob_se_wt@meta.data$ClusterName),
#            Name = unique(mob_se_wt@meta.data$ClusterName)), file = "cell_type_dict.csv") 

```


# mOB

```{r}

# remove poor spots and genes
countsClean <- MERINGUE::cleanCounts(counts = t(cd), 
                                     min.reads = 100, 
                                     min.lib.size = 100, 
                                     plot=TRUE,
                                     verbose=TRUE)

```

```{r}

# write.csv(x=t(countsClean), file="MappedDGEForR.csv")
# write.csv(x=mob$pos, file="BeadLocationsForR.csv")

```

```{r}

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mob_RCTD_inputs/"
mob_SpatialRNA <- read.SpatialRNA(datadir)

```

```{r}

barcodes <- colnames(mob_SpatialRNA@counts)

```

```{r}

plot_puck_continuous(mob_SpatialRNA, barcodes,
                     mob_SpatialRNA@nUMI,
                     ylimit = c(0,round(quantile(mob_SpatialRNA@nUMI,0.9))), 
                     title ='plot of nUMI') 

```

```{r}

mob_RCTD <- create.RCTD(mob_SpatialRNA, reference, max_cores = 7, CELL_MIN_INSTANCE = 20)

```

took about 7 minutes
```{r}

mob_RCTD_run <- run.RCTD(mob_RCTD, doublet_mode = TRUE)

```

```{r}

mob_RCTD_results <- mob_RCTD_run@results
# normalize the cell type proportions to sum to 1.
norm_weights_mob <-  sweep(mob_RCTD_results$weights, 1, rowSums(mob_RCTD_results$weights), '/') 
cell_type_names <- mob_RCTD_run@cell_type_info$info[[2]] #list of cell type names
mob_spatialRNA <- mob_RCTD_run@spatialRNA

# puck_d <- get_decomposed_data(mob_RCTD_results$results_df,
#                               mob_RCTD_run@internal_vars$gene_list_reg,
#                               mob_spatialRNA, mob_RCTD_results$weights_doublet, 
#                               mob_RCTD_run@cell_type_info$renorm)

```

```{r}

# theta of 38 cell types
norm_weights

# puck_d 
# object with information about predicted cell types and gene counts.
# @counts = genes x cells. 3350 x 428
# @cell_labels = factor of length 428 with 38 levels (cell labels for each cell 1-428)

# question: why 428 cells? @coords = 428 x 2. 
# the `norm_weights` is 260 x 28. So these are the spots. Are the 428 cells combos of these singlets and doublets?

# can collapse genes based on cells they belong to in order to get gene expression for each cell. But if I have the single cell data, couldn't I just do this using the original scRNAseq data?

```

For SPOTlight and RCTD, would be interesting to compare the original scRNAseq cell type collapsed gene expression and compare to W, or what these 428 cells are and their collapsed gene expression.

```{r}

# colors for the cell types
rctd_cols <- as.factor(colnames(norm_weights_mob))
names(rctd_cols) <- colnames(norm_weights_mob)
levels(rctd_cols) <- gg_color_hue(length(colnames(norm_weights_mob)))

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- norm_weights_mob
cols <- rctd_cols

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "rctd mob predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

OECs looking quite distinct across SPOTlight and RCTD. So definitely try with these removed

Remove cell types less than 9% (similar to SPOTlight)

```{r}

norm_weights_ <- norm_weights_mob
norm_weights_[which(norm_weights_ < 0.09)] <- 0

norm_weights_filt <- norm_weights_[,which(!colSums(norm_weights_) == 0)]

```

```{r}

# colors for the cell types
rctd_cols_filt <- as.factor(colnames(norm_weights_filt))
names(rctd_cols_filt) <- colnames(norm_weights_filt)
levels(rctd_cols_filt) <- gg_color_hue(length(colnames(norm_weights_filt)))

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- norm_weights_filt
cols <- rctd_cols_filt

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "rctd mob predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

# `RCTD` vs SL `sl_countsClean`

## all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_countsClean
m2 <- norm_weights


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta, # 38
                                      theta2 = m2) # 38

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs RCTD norm_weights ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

```

## filtered

```{r}

m1 <- sl_countsClean_mob_opt
m2 <- norm_weights_filt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, # 17
                                      theta2 = m2) # 25

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs norm_weights_filt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean mob_opt vs norm_weights_filt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
  theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# `RCTD` vs LDA `mob_common`

## filtered

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_filt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta, # 75
                                      theta2 = m2) # 25

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_filt


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn,
                                      theta2 = m2) # 25

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt ct thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt ct thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# `RCTD_noOEC` vs `RCTD`

## all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- norm_weights_mob
m2 <- norm_weights_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1, # 38
                                      theta2 = m2) # 33

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "RCTD norm_weights vs norm_weights_noOEC ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

```

## filtered

```{r}

m1 <- norm_weights_filt
m2 <- norm_weights_filt_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1, # 25
                                      theta2 = m2) # 22

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "RCTD norm_weights vs norm_weights_noOEC filt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "RCTD norm_weights vs norm_weights_noOEC filt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
  theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# `RCTD_noOEC` vs `sl_countsClean_noOEC`

## all spots, cts, topics

```{r}

# use raw, so can see which cell types are not present at all.
# fill need to filter to get dendros and compare

m1 <- sl_countsClean_noOEC
m2 <- norm_weights_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$spotCtTheta, # 33
                                      theta2 = m2) # 33

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs RCTD norm_weights  noOEC ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

```

## filtered

```{r}

m1 <- sl_countsClean_noOEC_mob_opt
m2 <- norm_weights_filt_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$ctThetaFilt, # 19
                                      theta2 = m2) # 22

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs norm_weights noOEC filt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "sl_countsClean vs norm_weights noOEC filt ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
  theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# `RCTD_noOEC` vs LDA `mob_common`

## not filtered

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta, # 75
                                      theta2 = m2) # 33

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn, # 18
                                      theta2 = m2) # 33

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC ct thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC ct thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

## filtered

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_filt_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$theta, # 75
                                      theta2 = m2) # 22

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC filt ct theta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(t(theta_cor))

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$colsix, pairs$rowix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_noOEC ct theta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$colsix, pairs$rowix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

```{r}

m1 <- mob_common_opt
m2 <- norm_weights_filt_noOEC


# -------------------------------------------------------
# sl predicted cell types

theta_cor <- correlationBetweenThetas(theta1 = m1$thetaCombn, # 18
                                      theta2 = m2) # 22

par(mfrow=c(1,1), mar=c(3,3,1,1))
heatmap.2(theta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt_noOEC ct thetaCombn",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(theta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(theta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$ctcols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=0.5,cexCol=0.6,margins=c(3,3),
          main = "mob common opt vs norm_weights_filt_noOEC ct thetaCombn paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
theta_cor_paired_cors <- diag(theta_cor[pairs$rowix, pairs$colsix])

hist(theta_cor_paired_cors, breaks = 10)
mean(theta_cor_paired_cors)
sd(theta_cor_paired_cors)

```

# =========================
# scRNAseq cluster gexp

Trying to deconvolve cell type proportions. So makes sense to do NNLS to solve for the individual types mixed together in a spot. But for the gene expression reference, why even do NMF for W?

Also what is the RCTD deconvolved result/ Like a beta but what are the individual cells?

```{r}

# mob_se_wt@assays$RNA@counts

cell_type_clusters <- as.factor(mob_se_wt@meta.data$ClusterName)
names(cell_type_clusters) <- rownames(mob_se_wt@meta.data)

```

```{r}

mm <- model.matrix(~ 0 + cell_type_clusters)
colnames(mm) <- levels(cell_type_clusters)
scRNAseq_mob_cluster_gexp <- t(as.matrix(mob_se_wt@assays$RNA@counts) %*% mm)
scRNAseq_mob_cluster_gexp <- scRNAseq_mob_cluster_gexp/rowSums(scRNAseq_mob_cluster_gexp)
dim(scRNAseq_mob_cluster_gexp)
scRNAseq_mob_cluster_gexp[1:10,1:10]

```

## vs sl_countsClean

```{r}

W_countsClean <- nmf_mod_mob_wt_countsClean_ls[[1]]@fit@W

keep_genes <- colnames(scRNAseq_mob_cluster_gexp)[colnames(scRNAseq_mob_cluster_gexp) %in% rownames(W_countsClean)]
length(keep_genes)

```

```{r}

m1 <- scRNAseq_mob_cluster_gexp
m2 <- t(W_countsClean)

# -------------------------------------------------------
# sl topics in W

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs sl_countsClean W beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs sl_countsClean W beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

# -------------------------------------------------------
# sl ct in ctBeta (from topic gene weights but combined wrt topic proportions in cell types)

m1 <- scRNAseq_mob_cluster_gexp
m2 <- sl_countsClean$ctBeta

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs sl_countsClean ctBeta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs sl_countsClean ctBeta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)



```

```{r}

m1 <- scRNAseq_mob_cluster_gexp
m2 <- scRNAseq_mob_cluster_gexp

# -------------------------------------------------------
# sl topics in W

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs self beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs self beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

# -------------------------------------------------------
# sl ct in ctBeta (from topic gene weights but combined wrt topic proportions in cell types)

m1 <- sl_countsClean$ctBeta
m2 <- sl_countsClean$ctBeta

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs self ctBeta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean vs self ctBeta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

# -------------------------------------------------------
# W self

m1 <- t(W_countsClean)
m2 <- t(W_countsClean)

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsCleanW vs self",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "sl_countsClean W vs self paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

## vs `mob_common_opt`

```{r}

keep_genes <- colnames(scRNAseq_mob_cluster_gexp)[colnames(scRNAseq_mob_cluster_gexp) %in% colnames(mob_common_opt$beta)]
length(keep_genes)

```

```{r}

m1 <- scRNAseq_mob_cluster_gexp
m2 <- mob_common_opt$beta

# -------------------------------------------------------
# sl topics in W

# make sure only the shared genes in the same order are used
beta_cor <- correlationBetweenBetas(beta1 = m1[,keep_genes],
                                      beta2 = m2[,keep_genes])

par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor,
          # Rowv = m1$dendro,
          # Colv = m2$dendro,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols),
          # ColSideColors = as.vector(m2$ctcols),
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs mob_common_opt beta",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

pairs <- lsatPairs(beta_cor)

# recall the individual topics colored by their cluster.
# when ordered based on matches and not dendro, colors will appear mixed
par(mfrow=c(1,1), mar=c(8,8,3,2))
heatmap.2(beta_cor[pairs$rowix, pairs$colsix],
          Rowv = NULL,
          Colv = NULL,
          density.info = "none",
          trace = "none",
          # RowSideColors = as.vector(m1$cols)[pairs$rowix],
          # ColSideColors = as.vector(m2$ctcols)[pairs$colsix], # order now based on lsat
          col = correlation_palette,
          breaks = correlation_breaks,
          cexRow=1,cexCol=1,margins=c(6,3),
          main = "scRNAseq vs mob_common_opt beta paired",
          lhei = c(1,3),
          key.xlab = "Correlation",
          key.title = NA)

# correlations along diagonal (after assigning best matches)
beta_cor_paired_cors <- diag(beta_cor[pairs$rowix, pairs$colsix])

hist(beta_cor_paired_cors, breaks = 10)
mean(beta_cor_paired_cors)
sd(beta_cor_paired_cors)

```

I think the W and betas are supposed to be weights of genes associating with a topic or ct and not really the average gexp of the scRNAseq clusters

# ----------------------------------

# `RCTD` no OECs

```{r}

load("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/mob_processed_sparseMatrix.RData")
# mob_se

mob_meta <- read.csv2("/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/GSE121891_mOB_scRNAseq/GSE121891_OB_metaData_seurat.csv", sep = ",")

wt_cells <- mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]$"X"

mob_se_wt <- mob_se[,wt_cells]
meta.data.wt = mob_meta[which(mob_meta$orig.ident %in% c("WT1", "WT2")),]

cell.types <- c("OEC1", "OEC2", "OEC3", "OEC4", "OEC5")

meta.data.wt.noOEC <- meta.data.wt[which(!meta.data.wt$ClusterName %in% cell.types),]
keepCells <- meta.data.wt[which(!meta.data.wt$ClusterName %in% cell.types),]$"X"
mob_se_wt_noOEC <- mob_se_wt[,which(colnames(mob_se_wt) %in% keepCells)]

```

```{r}

mob_se_wt_noOEC <- CreateSeuratObject(counts = mob_se_wt_noOEC, project = "mob_wt_noOEC",
                                      meta.data = meta.data.wt.noOEC)

# a lot of metadata info not being added...? try doing manually:
mob_se_wt_noOEC[["ClusterName"]] <- meta.data.wt.noOEC$ClusterName
mob_se_wt_noOEC[["percent.mito"]] <- meta.data.wt.noOEC$percent.mito
mob_se_wt_noOEC[["nUMI"]] <- meta.data.wt.noOEC$nUMI

```

```{r}

write.csv(x=mob_se_wt_noOEC@meta.data[,c("ClusterName", "nUMI")], file="meta_data.csv")
write.csv(x=mob_se_wt_noOEC@assays$RNA@counts, file="dge.csv")

```

```{r}

write.csv(x = data.frame(Cluster = unique(mob_se_wt_noOEC@meta.data$ClusterName),
           Name = unique(mob_se_wt_noOEC@meta.data$ClusterName)), file = "cell_type_dict.csv")

```

```{r}

refdir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mob_RCTD_noOEC_ref/"
reference_noOEC <- dgeToSeurat(refdir)

```

```{r}

datadir <- "/Users/brendan/Desktop/PostDoc/work/STDeconvolve/data/mob_RCTD_inputs/"
mob_SpatialRNA <- read.SpatialRNA(datadir)

```

```{r}

barcodes <- colnames(mob_SpatialRNA@counts)

```

```{r}

mob_noOEC_RCTD <- create.RCTD(mob_SpatialRNA, reference_noOEC, max_cores = 7, CELL_MIN_INSTANCE = 20)

```

took about 7 minutes
```{r}

mob_noOEC_RCTD_run <- run.RCTD(mob_noOEC_RCTD, doublet_mode = TRUE)

```

```{r}

mob_noOEC_RCTD_results <- mob_noOEC_RCTD_run@results
# normalize the cell type proportions to sum to 1.
norm_weights_noOEC = sweep(mob_noOEC_RCTD_results$weights, 1, rowSums(mob_noOEC_RCTD_results$weights), '/') 
cell_type_names <- mob_noOEC_RCTD_run@cell_type_info$info[[2]] #list of cell type names
mob_spatialRNA <- mob_noOEC_RCTD_run@spatialRNA

mob_noOEC_RCTD_decomposed <- get_decomposed_data(mob_noOEC_RCTD_results$results_df,
                              mob_noOEC_RCTD_run@internal_vars$gene_list_reg,
                              mob_spatialRNA, mob_noOEC_RCTD_results$weights_doublet,
                              mob_noOEC_RCTD_run@cell_type_info$renorm)

```

```{r}

norm_weights_ <- norm_weights_noOEC
norm_weights_[which(norm_weights_ < 0.09)] <- 0

norm_weights_filt_noOEC <- norm_weights_[,which(!colSums(norm_weights_) == 0)]

```

```{r}

# colors for the cell types
rctd_cols_filt_noOEC <- as.factor(colnames(norm_weights_filt_noOEC))
names(rctd_cols_filt_noOEC) <- colnames(norm_weights_filt_noOEC)
levels(rctd_cols_filt_noOEC) <- gg_color_hue(length(colnames(norm_weights_filt_noOEC)))

```

```{r, fig.height=6, fig.width=8}

pos <- mob$pos
m <- norm_weights_filt_noOEC
cols <- rctd_cols_filt_noOEC

vizAllTopics(theta = m,
             pos = pos,
             topicOrder = seq_len(length(colnames(m))),
             cluster_cols = levels(cols),
             groups = NA,
             group_cols = NA, 
             r = 0.4,
             lwd = 0.01,
             plotTitle = "rctd no OEC mob predictions")

vizTopicClusters(theta = m,
                pos = pos,
                clusters = cols,
                sharedCol = TRUE,
                r = 0.4,
                lwd = 0.01)

```

# ==========================
# Additional Questions:

## corpus and optimal k

how does the:
1. size of the corpus (num docs, num genes, num terms)
2. or "complexity" of the corpus

influence the "optimal k"

potentially important because I believe that the models are being over fit to the input corpus and thus the optimal k determined is too large. It also leads to slow down because the larger the k, the more time the model takes to fit.

So if I can figure out what drives the model to find an optimal k and what increases k, I could use this to guide the construction of the input corpus. OD genes? removing genes expressed in all spots? removing genes with high expression to lower the total terms?


## corpus and speed

related to the above question. A larger k certainly makes it slower to fit the model, but perhaps the size or the corpus itself also influences the speed of fitting, regardless of the size of k.


try keeping K constant but modulating the size (doc x genes; also total terms) and measure time to fit. Also perhaps the "complexity". As in, certain topics may share a lot of the same genes instead of topics have unique genes.



I have run 10-75 (14) models for 23 different corpuses. So plot the speed versus doc x genes x terms to see if any correlation...do same for optimal K.

If no correlation for size of corpus, then must have to do with the "complexity: or at least the fact that model can keep updating to lower perplexity (and overfitting to the corpus)


```{r}

# collected in `model_metadata.R`

metadata <- data.frame(times = times,
                       ndocs = ndocs,
                       ngenes = ngenes,
                       nterms = nterms,
                       largest_k = largest_k,
                       optimal_k = optimal_k,
                       samples = samples,
                       groups = groups)

```

```{r}

ggplot(data = metadata) +
  geom_point(aes(x = times, y = nterms, color=ngenes)) +
  scale_color_viridis(option = "A", direction = -1)

ggplot(data = metadata) +
  geom_point(aes(x = times, y = nterms, color=groups))

ggplot(data = metadata) +
  geom_point(aes(x = times, y = nterms, color=as.character(metadata$largest_k)))

ggplot(data = metadata) +
  geom_point(aes(x = times, y = nterms, color=as.character(metadata$optimal_k)))

ggplot(data = metadata) +
  geom_point(aes(x = times, y = ngenes, color=groups))

ggplot(data = metadata) +
  geom_point(aes(x = times, y = ndocs, color=groups))

ggplot(data = metadata) +
  geom_point(aes(x = nterms, y = ngenes, color=groups))

ggplot(data = metadata) +
  geom_point(aes(x = ndocs, y = ngenes, color=log10(nterms))) +
  scale_color_viridis(option = "A", direction = -1)

ggplot(data = metadata) +
  geom_point(aes(x = ndocs, y = ngenes, color=times)) +
  scale_color_viridis(option = "A", direction = -1)

```

number of terms and number of genes both seem to be correlated with time, but both can be intertwined wrt time. Ex merfish has few genes but a lot more terms comparably and this may increase time as well.




## optimal k non-linear search

```{r}

fitLDA2 <- function(interval, corpus = corpus,
                      K = c(), Plx = c(), models = c(),
                      lower = min(interval),
                      mid = round((min(interval) + max(interval))/2),
                      upper = max(interval),
                      tol = .Machine$double.eps^0.25,
                      seed = 0) {
  
  # params for fitting model
  params <- list(seed = seed,
                   verbose = 0, keep = 1, estimate.alpha = TRUE)
  
  print("begin")
  cat("interval:", lower, mid, upper, "\n")
  
  # if optimal found:
  if(lower == mid | mid == upper) {
    # final adjustment in case the optimum was actually at end of the interval
    # because when computing mid, it rounds. 
    # ex: for a final interval 6,7, it rounds the mid to 6 and ends search, labeling 6 as optimal
    # although 7 may have actually been the lower value
    kopt <- K[which.min(Plx)]
    
    cat("optimal K estimated to be", kopt, "\n")
    
    # plot
    oix <- order(K) # order by K's
    kopt_ix <- which(K[oix] %in% kopt) # index of reordered k's that is optimal
    
    plot.new()
    plot(K[oix], Plx[oix], type="l")
    points(kopt, Plx[oix][kopt_ix], col = "red")
    
    return(list(models = models,
                kOpt = kopt,
                perplexities = Plx,
                Ks = K,
                fitCorpus = corpus))
  }
  
  # 1. check if perplexities have already been computed for k's.
  
  # if not, compute them.
  # Use mclapply to get values at least for first iteration when there will be multiple k's
  ks <- c(lower, mid, upper)
  notComputed <- ks[which(!ks %in% K)]
  cat("computing perplexities for:", notComputed, "\n")
  
  # returns list of lists, where each list is: [[1]]perplexity, [[2]]k, [[3]]LDAmodel
  fitmodels <- mclapply(notComputed, function(k){
    model <- topicmodels::LDA(corpus, k=k, control = params)
    p <- topicmodels::perplexity(model, corpus)
    return(c(p, k, model))
  }, mc.cores = detectCores(logical = TRUE) - 1)
  
  # append newly obtained perplexities, corresponding k's, and models. Need to be in same order
  for (i in seq(length(fitmodels))) {
    m <- fitmodels[[i]]
    Plx <- c(Plx, m[[1]])
    K <- c(K, m[[2]])
    models <- c(models, m[[3]])
  }
  # can't get these global lists to update
  # lapply(fitmodels, function(m){
  #   perp_vals <- c(perp_vals, m[1])
  #   k_coords <- c(k_coords, m[2])
  # })
  
  # 2. determine new interval
  
  # get perplexity values for the current k interval values (lower, mid, upper)
  plxs <- sapply(ks, function(k) {
     # get index of k and perplexity value for each element of current interval `ks`
    ix <- which(K %in% c(k))
    p <- Plx[ix]
    p
  })
  
  # perplexity values for the current interval `ks`
  fl <- plxs[1]
  fm <- plxs[2]
  fu <- plxs[3]
  
  cat("lower k", lower, "\n")
  cat("perplexity:", fl, "\n")
  cat("mid k", mid, "\n")
  cat("perplexity", fm, "\n")
  cat("upper k", upper, "\n")
  cat("perplexity", fu, "\n")
  
  if (fl < fu) {
    print('searching lower half')
    fitLDA2(interval = c(lower, mid),
            corpus = corpus,
            K = K,
            Plx = Plx,
            models = models)
  } else {
    print('searching upper half')
    fitLDA2(interval = c(mid, upper),
            corpus = corpus,
            K = K,
            Plx = Plx,
            models = models)
  }
}

```

ground truth check:
```{r}

# from meringue mob after fitting with fitLDA
dat_mob

# "function" f will be fitting LDA model with a given k, then find perplexity
# for testing, just have it return the perplexity for a given k

f <- function(K, dat = dat_mob) {
  
  per <- dat_mob[which(dat_mob$k == as.character(K)), ]$perplexities
  return(per)
  
}

```

```{r}

x <- seq(from = 2, to = 35, by = 1)
results <- optSearch(f, interval = c(2,35))
# results <- fitLDA2(f, i = c(2,35))

plot(x, f(x), type='l')
points(results[1], results[2], col='red')
results

```

test new function

```{r}

start_time <- Sys.time()

x <- seq(from = 2, to = 35, by = 1)

mob_fitLDA2_test <- fitLDA2(interval = x,
                            corpus = mob$slm)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

after the first split, the function starts looking in the upper half. So it ends up missing the true optimal K, which is 12.

But maybe doesn't have to be super precise as we end up collapsing topics into clusters anyways. Just have to be reasonably close

above it took 6.26 minutes versus 5.28 here. So maybe saved a little bit of time. Before I divide up the training processed between 7 cores. It really boils down to the time to train the highest K, plus anytime before hand it had to wait before getting an available core from training lower K models, which are faster. Here once it starts searching ranges, there is no more parallel processing, but the highest k model does gets started first. After it finishes, then the time that gets added on is the sum of training each additional model to obtain optimal. It seems like it takes about 4 searches. So 4 additional models of lower Ks. BUT if the interval includes models with large K's. then this might actually end up being slower than just doing all via parallel processing.



here's a model that took about 15 minutes for:
<!-- > k_ -->
<!--  [1] 10 15 20 25 30 35 40 45 50 55 60 65 70 75 -->

```{r}

start_time <- Sys.time()

mob_rep2_fitLDA2_test <- fitLDA2(interval = c(10,75),
                            corpus = mob_rep2$slm)

# mob_rep2_LDAs <- fitLDA(mob_rep2$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

maybe comes down to how many cores...fitLDA2 tries to approximate with this search algorithm and can be somewhat fast but only 1 core at a time.

Otherwise, can use fitLDA and do 7+ processes in parallel to brute force get the perplexities.


alternative:
fit lets say 6 models in parallel. Then fit a line/model.
Then solve for the minimum K. If it is not one of the K's already fitted, then fit it and that's it. So 7 processes total and 6 are run in parallel. Similar issue though..in beginning the largest is fit and takes longest. Then what if the last one is also big? then have to wait sequentially for the two biggest to finish. At least with parallel before, typically a smaller one finishes then finally the largest can get placed. So then just wait for largest and a smaller one sequentially. So this strategy probably would be a little faster, or could also be a lot longer

```{r}

fitLDA3 <- function(interval, p = 5, corpus, seed = 0){
  
  # # sequence across interval
  # s <- seq(min(interval), max(interval))
  # # split sequence into p segments
  # segs <- split(s, cut(s, p))
  # 
  # # for each segments, take first element,
  # # or if last one, take last elements
  # # selected elements are the Ks to fit
  # Ks <- sapply(seq(p), function(seg){
  #   if (seg == tail(seq(p), 1)) {
  #     k <- max(segs[[seg]])
  #   } else {
  #     k <- min(segs[[seg]])
  #   }
  #   k
  # })
  
  Ks <- round(seq(min(interval), max(interval), length = p))
  
  # params for fitting model
  params <- list(seed = seed,
                   verbose = 0, keep = 1, estimate.alpha = TRUE)
  
  # fit model and compute perplexity for each k
  # returns list of lists, where each list is: [[1]]perplexity, [[2]]LDAmodel
  cat("Training models for following K's:", Ks, "\n")
  fitmodels <- mclapply(Ks, function(k){
    model <- topicmodels::LDA(corpus, k=k, control = params)
    p <- topicmodels::perplexity(model, corpus)
    return(c(p, model))
  }, mc.cores = detectCores(logical = TRUE) - 1)
  
  plxs <- c() # y coords for model fitting
  models <- c()
  for (i in seq(length(fitmodels))) {
    m <- fitmodels[[i]]
    plxs <- c(plxs, m[[1]])
    models <- c(models, m[[2]])
  }
  
  # fit models and pick best one
  y <- plxs
  x <- Ks
  
  # polynomials, but maybe something more sophisticated like GAMs?
  # first degree 
  fit  <- lm(y~x)
  # second degree
  fit2 <- lm(y~poly(x,2,raw=TRUE))
  # third degree
  fit3 <- lm(y~poly(x,3,raw=TRUE))
  # fourth degree
  fit4 <- lm(y~poly(x,4,raw=TRUE))
  
  fits <- list(fit, fit2, fit3, fit4)
  
  xx <- seq(min(Ks), max(Ks), length=50)
  plot(x, y, pch=19)
  lines(xx, predict(fit, data.frame(x=xx)), col="red")
  lines(xx, predict(fit2, data.frame(x=xx)), col="green")
  lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
  lines(xx, predict(fit4, data.frame(x=xx)), col="purple")
  
  # pick best fit by highest r.squared value:
  rsqds <- sapply(fits, function(f){
    s <- summary(f)
    r2 <- s[["r.squared"]]
    r2
    #s
  })
  best <- fits[[which.max(rsqds)]]
  
  # find lowest predicted K
  xx <- seq(min(Ks), max(Ks))
  predictions <- predict(best, data.frame(x=xx))
  optK <- xx[which.min(as.vector(predictions))]

  # if optK not one of the initial sampled Ks, then a model has not been fitted yet
  # so fit a model:
  if (!optK %in% Ks){
    cat("Training putative optimal K", optK, "\n")
    model <- topicmodels::LDA(corpus, k=optK, control = params)
    p <- topicmodels::perplexity(model, corpus)

    Ks <- c(Ks, optK)
    plxs <- c(plxs, p)
    models <- c(models, model)
  }
  
  # final adjustment in case one of the sampled Ks was actually better
  # than the predicted
  optK <- Ks[which.min(plxs)]
  cat("Determined optimal K:", optK, "\n")
  
  # plot
  oix <- order(Ks) # order by K's
  kopt_ix <- which(Ks[oix] %in% optK) # index of reordered k's that is optimal

  plot(Ks[oix], plxs[oix], type="l")
  points(optK, plxs[oix][kopt_ix], col = "red")

  return(list(models = models,
              kOpt = optK,
              perplexities = plxs,
              Ks = Ks,
              fitCorpus = corpus))
  
}

```

```{r}

start_time <- Sys.time()

mob_fitLDA3_test <- fitLDA3(interval = c(2,75), p = 7,
                            corpus = mob$slm)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```

```{r}

start_time <- Sys.time()

mob_rep2_fitLDA3_test <- fitLDA3(interval = c(2,75), p = 7,
                            corpus = mob_rep2$slm)

# mob_rep2_LDAs <- fitLDA(mob_rep2$slm, k_, seed = 0)

total_t <- round(difftime(Sys.time(), start_time, units = "mins"), 2)
print(sprintf("Time to train LDA models was %smins", total_t))

```


## understanding getOD genes

```{r}

# cd from mob 

countsClean <- MERINGUE::cleanCounts(counts = cd, 
                                     min.reads = 100, 
                                     min.lib.size = 100, 
                                     plot=TRUE,
                                     verbose=TRUE)
# 7365 genes x 260 spots sparse mtx

mat <- Matrix::t(countsClean)
# 260 spots x 7365 genes sparse mat

dfm <- log(Matrix::colMeans(mat))
# log columns means: mean expression of each gene across spots
# will be called expression "magnitude"

dfv <- log(apply(mat, 2, var))
# variance of expression of each gene across spots

names(dfm) <- names(dfv) <- colnames(mat)
df <- data.frame(m = dfm, v = dfv)
# data frame where rows are genes, m = the means, v = the variance

vi <- which(is.finite(dfv))
# genes where the variance is finite, (not -Inf or Inf)

gam.k = 5 # this is the dimension of the "basis" functions used to fit. If lower will have more "wiggles"
# higher will be "smoother"
# will use lm model is gam.k < 2 otherwise will use gam
m <- lm(v ~ m, data = df[vi, ])
m <- mgcv::gam(v ~ s(m, k = gam.k), data = df[vi, ]) # s() is a smooth function in the GAM
# variance is the response (y) and mean is the covariate (correct name?) (x)
# use genes that have finite variances

df$res <- -Inf
df$res[vi] <- resid(m, type = "response")
# residuals. The raw values minus the fitted values. Again for just genes with finite variances
# we're looking for overdispersed genes. So genes with actual real variances larger than what would be
# expected from the model. And the model should take into account the fact that genes with 
# larger magnitudes will have larger variances by chance.
# Thus a gene would need to have very larger variance if it also was expressed at a high level 
# across all spots.

df$lp <- as.numeric(pf(exp(df$res), df1 = n.obs, df2 = n.obs, lower.tail = F, 
    log.p = T))
# residuals were log variance, so use e^value to transform back (?)
# build F-distribution (pf()); this is for the density. Asymetric distr from 0 to Inf.
# I think you get p-values for each residual (log p in this case)

df$lpa <- bh.adjust(df$lp, log = TRUE)
# adjust the p-vals

df$lpa <- MERINGUE:::bh.adjust(df$lp, log = TRUE)

df$qv <- as.numeric(qchisq(df$lp, n.cells - 1, lower.tail = FALSE, 
    log.p = TRUE)/n.cells)
# can also do chisqaured test using these p-values

ods <- which(df$lpa < log(alpha))
# the OD genes are ones with p-values less than alpha.
# as alpha increases, less stringent cutoff and more significant genes
# get ones with less variance coming up as significant.
# I think this alpha corresponds to the critical value/region?

df$gsf <- geneScaleFactors <- sqrt(pmax(min.adjusted.variance, 
    pmin(max.adjusted.variance, df$qv))/exp(df$v))
# for adjusting gene counts based on variance
norm.mat <- counts * df$gsf

# return(list(mat = norm.mat, ods = colnames(mat)[ods], 
#       df = df))


# changing alpha will definitely change the list of OD genes more than changing the smoothness of fit (and thus the residuals) via gamma

```

```{r}

hist(df$lpa, breaks = 1000)
abline(v = log(0.05), col = "red")

```






